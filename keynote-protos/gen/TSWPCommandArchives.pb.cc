// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSWPCommandArchives.proto

#include "TSWPCommandArchives.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace TSWP {
PROTOBUF_CONSTEXPR DummyCommandArchive::DummyCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.foo_)*/0u} {}
struct DummyCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DummyCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DummyCommandArchiveDefaultTypeInternal() {}
  union {
    DummyCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DummyCommandArchiveDefaultTypeInternal _DummyCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR TextCommandArchive::TextCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.restore_range_location_)*/0u
  , /*decltype(_impl_.restore_range_length_)*/0u
  , /*decltype(_impl_.redo_restore_range_location_)*/0u
  , /*decltype(_impl_.redo_restore_range_length_)*/0u
  , /*decltype(_impl_.text_command_flags_)*/0u
  , /*decltype(_impl_.kind_)*/0} {}
struct TextCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TextCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TextCommandArchiveDefaultTypeInternal() {}
  union {
    TextCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextCommandArchiveDefaultTypeInternal _TextCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR StorageActionCommandArchive::StorageActionCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.custom_format_keys_)*/{}
  , /*decltype(_impl_.coalescing_property_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.changed_data_reference_record_)*/nullptr
  , /*decltype(_impl_.text_command_flags_)*/0u
  , /*decltype(_impl_.kind_)*/0
  , /*decltype(_impl_.is_forward_inverse_command_)*/false
  , /*decltype(_impl_.coalesceable_)*/false
  , /*decltype(_impl_.coalescing_text_)*/false
  , /*decltype(_impl_.should_migrate_styles_)*/false
  , /*decltype(_impl_.wp_kind_)*/0} {}
struct StorageActionCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StorageActionCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StorageActionCommandArchiveDefaultTypeInternal() {}
  union {
    StorageActionCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StorageActionCommandArchiveDefaultTypeInternal _StorageActionCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR SetColumnStyleCommandArchive::SetColumnStyleCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr} {}
struct SetColumnStyleCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetColumnStyleCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetColumnStyleCommandArchiveDefaultTypeInternal() {}
  union {
    SetColumnStyleCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetColumnStyleCommandArchiveDefaultTypeInternal _SetColumnStyleCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ReplaceAllUsesOfStyleCommandArchive::ReplaceAllUsesOfStyleCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr} {}
struct ReplaceAllUsesOfStyleCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplaceAllUsesOfStyleCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplaceAllUsesOfStyleCommandArchiveDefaultTypeInternal() {}
  union {
    ReplaceAllUsesOfStyleCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplaceAllUsesOfStyleCommandArchiveDefaultTypeInternal _ReplaceAllUsesOfStyleCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR InsertColumnsCommandArchive::InsertColumnsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.column_index_)*/0u
  , /*decltype(_impl_.column_count_)*/0u} {}
struct InsertColumnsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertColumnsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertColumnsCommandArchiveDefaultTypeInternal() {}
  union {
    InsertColumnsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertColumnsCommandArchiveDefaultTypeInternal _InsertColumnsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR InsertRowsCommandArchive::InsertRowsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.row_index_)*/0u
  , /*decltype(_impl_.row_count_)*/0u} {}
struct InsertRowsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertRowsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertRowsCommandArchiveDefaultTypeInternal() {}
  union {
    InsertRowsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertRowsCommandArchiveDefaultTypeInternal _InsertRowsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR RemoveColumnsCommandArchive::RemoveColumnsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.column_index_)*/0u
  , /*decltype(_impl_.column_count_)*/0u} {}
struct RemoveColumnsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoveColumnsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoveColumnsCommandArchiveDefaultTypeInternal() {}
  union {
    RemoveColumnsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoveColumnsCommandArchiveDefaultTypeInternal _RemoveColumnsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR RemoveRowsCommandArchive::RemoveRowsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.row_index_)*/0u
  , /*decltype(_impl_.row_count_)*/0u} {}
struct RemoveRowsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoveRowsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoveRowsCommandArchiveDefaultTypeInternal() {}
  union {
    RemoveRowsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoveRowsCommandArchiveDefaultTypeInternal _RemoveRowsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MergeCellsCommandArchive::MergeCellsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.row_)*/0u
  , /*decltype(_impl_.column_)*/0u
  , /*decltype(_impl_.row_count_)*/0u
  , /*decltype(_impl_.column_count_)*/0u} {}
struct MergeCellsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MergeCellsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MergeCellsCommandArchiveDefaultTypeInternal() {}
  union {
    MergeCellsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MergeCellsCommandArchiveDefaultTypeInternal _MergeCellsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ApplyPlaceholderTextCommandArchive::ApplyPlaceholderTextCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.script_tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.selection_range_location_)*/0u
  , /*decltype(_impl_.selection_range_length_)*/0u} {}
struct ApplyPlaceholderTextCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApplyPlaceholderTextCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApplyPlaceholderTextCommandArchiveDefaultTypeInternal() {}
  union {
    ApplyPlaceholderTextCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApplyPlaceholderTextCommandArchiveDefaultTypeInternal _ApplyPlaceholderTextCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR UpdateDateTimeFieldCommandArchive::UpdateDateTimeFieldCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.date_time_field_)*/nullptr
  , /*decltype(_impl_.date_)*/nullptr
  , /*decltype(_impl_.date_style_)*/0
  , /*decltype(_impl_.time_style_)*/0} {}
struct UpdateDateTimeFieldCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateDateTimeFieldCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateDateTimeFieldCommandArchiveDefaultTypeInternal() {}
  union {
    UpdateDateTimeFieldCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateDateTimeFieldCommandArchiveDefaultTypeInternal _UpdateDateTimeFieldCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ApplyRubyTextCommandArchive::ApplyRubyTextCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ruby_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.selection_range_location_)*/0u
  , /*decltype(_impl_.selection_range_length_)*/0u} {}
struct ApplyRubyTextCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApplyRubyTextCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApplyRubyTextCommandArchiveDefaultTypeInternal() {}
  union {
    ApplyRubyTextCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApplyRubyTextCommandArchiveDefaultTypeInternal _ApplyRubyTextCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ModifyRubyTextCommandArchive::ModifyRubyTextCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ruby_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.ruby_field_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr} {}
struct ModifyRubyTextCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModifyRubyTextCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModifyRubyTextCommandArchiveDefaultTypeInternal() {}
  union {
    ModifyRubyTextCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModifyRubyTextCommandArchiveDefaultTypeInternal _ModifyRubyTextCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ModifyTOCSettingsBaseCommandArchive::ModifyTOCSettingsBaseCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.old_toc_settings_)*/nullptr
  , /*decltype(_impl_.new_toc_settings_)*/nullptr} {}
struct ModifyTOCSettingsBaseCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModifyTOCSettingsBaseCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModifyTOCSettingsBaseCommandArchiveDefaultTypeInternal() {}
  union {
    ModifyTOCSettingsBaseCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModifyTOCSettingsBaseCommandArchiveDefaultTypeInternal _ModifyTOCSettingsBaseCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ModifyTOCSettingsForTOCInfoCommandArchive::ModifyTOCSettingsForTOCInfoCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.toc_info_uuid_path_)*/nullptr} {}
struct ModifyTOCSettingsForTOCInfoCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModifyTOCSettingsForTOCInfoCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModifyTOCSettingsForTOCInfoCommandArchiveDefaultTypeInternal() {}
  union {
    ModifyTOCSettingsForTOCInfoCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModifyTOCSettingsForTOCInfoCommandArchiveDefaultTypeInternal _ModifyTOCSettingsForTOCInfoCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ModifyTOCSettingsPresetForThemeCommandArchive::ModifyTOCSettingsPresetForThemeCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.theme_)*/nullptr
  , /*decltype(_impl_.preset_index_)*/0u} {}
struct ModifyTOCSettingsPresetForThemeCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModifyTOCSettingsPresetForThemeCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModifyTOCSettingsPresetForThemeCommandArchiveDefaultTypeInternal() {}
  union {
    ModifyTOCSettingsPresetForThemeCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModifyTOCSettingsPresetForThemeCommandArchiveDefaultTypeInternal _ModifyTOCSettingsPresetForThemeCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR AnchorAttachmentCommandArchive::AnchorAttachmentCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.attachment_)*/nullptr
  , /*decltype(_impl_.h_offset_type_)*/0u
  , /*decltype(_impl_.h_offset_)*/0
  , /*decltype(_impl_.v_offset_type_)*/0u
  , /*decltype(_impl_.v_offset_)*/0
  , /*decltype(_impl_.undo_h_offset_type_)*/0u
  , /*decltype(_impl_.undo_h_offset_)*/0
  , /*decltype(_impl_.is_html_wrap_)*/false
  , /*decltype(_impl_.undo_is_html_wrap_)*/false
  , /*decltype(_impl_.undo_v_offset_type_)*/0u
  , /*decltype(_impl_.undo_v_offset_)*/0} {}
struct AnchorAttachmentCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnchorAttachmentCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnchorAttachmentCommandArchiveDefaultTypeInternal() {}
  union {
    AnchorAttachmentCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnchorAttachmentCommandArchiveDefaultTypeInternal _AnchorAttachmentCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR TextApplyThemeCommandArchive::TextApplyThemeCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr} {}
struct TextApplyThemeCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TextApplyThemeCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TextApplyThemeCommandArchiveDefaultTypeInternal() {}
  union {
    TextApplyThemeCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextApplyThemeCommandArchiveDefaultTypeInternal _TextApplyThemeCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MoveColumnsCommandArchive::MoveColumnsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.src_index_)*/0u
  , /*decltype(_impl_.dst_index_)*/0u
  , /*decltype(_impl_.count_)*/0u} {}
struct MoveColumnsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveColumnsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveColumnsCommandArchiveDefaultTypeInternal() {}
  union {
    MoveColumnsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveColumnsCommandArchiveDefaultTypeInternal _MoveColumnsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MoveRowsCommandArchive::MoveRowsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.src_index_)*/0u
  , /*decltype(_impl_.dst_index_)*/0u
  , /*decltype(_impl_.count_)*/0u} {}
struct MoveRowsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveRowsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveRowsCommandArchiveDefaultTypeInternal() {}
  union {
    MoveRowsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveRowsCommandArchiveDefaultTypeInternal _MoveRowsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ShapeApplyPresetCommandArchive::ShapeApplyPresetCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.undo_style_)*/nullptr} {}
struct ShapeApplyPresetCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeApplyPresetCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeApplyPresetCommandArchiveDefaultTypeInternal() {}
  union {
    ShapeApplyPresetCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeApplyPresetCommandArchiveDefaultTypeInternal _ShapeApplyPresetCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR StyleBaseCommandArchive::StyleBaseCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.theme_)*/nullptr
  , /*decltype(_impl_.style_)*/nullptr} {}
struct StyleBaseCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleBaseCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleBaseCommandArchiveDefaultTypeInternal() {}
  union {
    StyleBaseCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleBaseCommandArchiveDefaultTypeInternal _StyleBaseCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR StyleCreateCommandArchive::StyleCreateCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.preset_index_)*/0u} {}
struct StyleCreateCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleCreateCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleCreateCommandArchiveDefaultTypeInternal() {}
  union {
    StyleCreateCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleCreateCommandArchiveDefaultTypeInternal _StyleCreateCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR StyleRenameCommandArchive::StyleRenameCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.updated_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.old_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct StyleRenameCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleRenameCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleRenameCommandArchiveDefaultTypeInternal() {}
  union {
    StyleRenameCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleRenameCommandArchiveDefaultTypeInternal _StyleRenameCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR StyleUpdateCommandArchive::StyleUpdateCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.original_style_)*/nullptr
  , /*decltype(_impl_.updated_style_)*/nullptr} {}
struct StyleUpdateCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleUpdateCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleUpdateCommandArchiveDefaultTypeInternal() {}
  union {
    StyleUpdateCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleUpdateCommandArchiveDefaultTypeInternal _StyleUpdateCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR StyleDeleteCommandArchive::StyleDeleteCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.old_preset_index_)*/0u} {}
struct StyleDeleteCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleDeleteCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleDeleteCommandArchiveDefaultTypeInternal() {}
  union {
    StyleDeleteCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleDeleteCommandArchiveDefaultTypeInternal _StyleDeleteCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR StyleReorderCommandArchive::StyleReorderCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.old_preset_index_)*/0u
  , /*decltype(_impl_.new_preset_index_)*/0u} {}
struct StyleReorderCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleReorderCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleReorderCommandArchiveDefaultTypeInternal() {}
  union {
    StyleReorderCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleReorderCommandArchiveDefaultTypeInternal _StyleReorderCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR StyleUpdatePropertyMapCommandArchive::StyleUpdatePropertyMapCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct StyleUpdatePropertyMapCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleUpdatePropertyMapCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleUpdatePropertyMapCommandArchiveDefaultTypeInternal() {}
  union {
    StyleUpdatePropertyMapCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleUpdatePropertyMapCommandArchiveDefaultTypeInternal _StyleUpdatePropertyMapCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ShapeStyleSetValueCommandArchive::ShapeStyleSetValueCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.change_)*/nullptr} {}
struct ShapeStyleSetValueCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeStyleSetValueCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeStyleSetValueCommandArchiveDefaultTypeInternal() {}
  union {
    ShapeStyleSetValueCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeStyleSetValueCommandArchiveDefaultTypeInternal _ShapeStyleSetValueCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR SelectionTransformerArchive::SelectionTransformerArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.storage_uuid_path_)*/nullptr
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.transformed_to_noop_)*/false} {}
struct SelectionTransformerArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectionTransformerArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectionTransformerArchiveDefaultTypeInternal() {}
  union {
    SelectionTransformerArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectionTransformerArchiveDefaultTypeInternal _SelectionTransformerArchive_default_instance_;
PROTOBUF_CONSTEXPR PencilAnnotationSelectionTransformerArchive::PencilAnnotationSelectionTransformerArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.text_pencil_annotation_uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.storage_uuid_path_)*/nullptr} {}
struct PencilAnnotationSelectionTransformerArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PencilAnnotationSelectionTransformerArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PencilAnnotationSelectionTransformerArchiveDefaultTypeInternal() {}
  union {
    PencilAnnotationSelectionTransformerArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PencilAnnotationSelectionTransformerArchiveDefaultTypeInternal _PencilAnnotationSelectionTransformerArchive_default_instance_;
PROTOBUF_CONSTEXPR ShapeSelectionTransformerArchive::ShapeSelectionTransformerArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_uuid_path_)*/nullptr} {}
struct ShapeSelectionTransformerArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeSelectionTransformerArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeSelectionTransformerArchiveDefaultTypeInternal() {}
  union {
    ShapeSelectionTransformerArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeSelectionTransformerArchiveDefaultTypeInternal _ShapeSelectionTransformerArchive_default_instance_;
PROTOBUF_CONSTEXPR ShapeContentDescription::ShapeContentDescription(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.text_range_location_)*/0u
  , /*decltype(_impl_.text_range_length_)*/0u} {}
struct ShapeContentDescriptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeContentDescriptionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeContentDescriptionDefaultTypeInternal() {}
  union {
    ShapeContentDescription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeContentDescriptionDefaultTypeInternal _ShapeContentDescription_default_instance_;
PROTOBUF_CONSTEXPR ObjectPropertyArchive::ObjectPropertyArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.string_value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_path_value_)*/nullptr
  , /*decltype(_impl_.fill_value_)*/nullptr
  , /*decltype(_impl_.color_value_)*/nullptr
  , /*decltype(_impl_.shadow_value_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.bool_value_)*/false
  , /*decltype(_impl_.float_value_)*/0
  , /*decltype(_impl_.integer_value_)*/0} {}
struct ObjectPropertyArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ObjectPropertyArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ObjectPropertyArchiveDefaultTypeInternal() {}
  union {
    ObjectPropertyArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ObjectPropertyArchiveDefaultTypeInternal _ObjectPropertyArchive_default_instance_;
PROTOBUF_CONSTEXPR SetObjectPropertiesCommandArchive::SetObjectPropertiesCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.properties_)*/{}
  , /*decltype(_impl_.old_properties_)*/{}
  , /*decltype(_impl_.action_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.object_uuid_path_)*/nullptr} {}
struct SetObjectPropertiesCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetObjectPropertiesCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetObjectPropertiesCommandArchiveDefaultTypeInternal() {}
  union {
    SetObjectPropertiesCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetObjectPropertiesCommandArchiveDefaultTypeInternal _SetObjectPropertiesCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR UpdateFlowInfoCommandArchive::UpdateFlowInfoCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.text_box_id_paths_at_start_)*/{}
  , /*decltype(_impl_.suggested_text_box_id_paths_at_end_)*/{}
  , /*decltype(_impl_.undo_text_boxes_to_restore_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.flow_info_uuid_path_)*/nullptr
  , /*decltype(_impl_.text_box_id_path_to_add_or_remove_)*/nullptr
  , /*decltype(_impl_.undo_added_shape_info_)*/nullptr
  , /*decltype(_impl_.undo_removed_shape_info_)*/nullptr
  , /*decltype(_impl_.command_mode_)*/0} {}
struct UpdateFlowInfoCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateFlowInfoCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateFlowInfoCommandArchiveDefaultTypeInternal() {}
  union {
    UpdateFlowInfoCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateFlowInfoCommandArchiveDefaultTypeInternal _UpdateFlowInfoCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR AddFlowInfoCommandArchive::AddFlowInfoCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.flow_info_to_add_)*/nullptr
  , /*decltype(_impl_.flow_info_archive_)*/nullptr
  , /*decltype(_impl_.working_undo_object_)*/nullptr
  , /*decltype(_impl_.undo_user_interface_identifier_to_restore_)*/0u
  , /*decltype(_impl_.undo_next_user_interface_identifier_to_restore_)*/0u} {}
struct AddFlowInfoCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddFlowInfoCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddFlowInfoCommandArchiveDefaultTypeInternal() {}
  union {
    AddFlowInfoCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddFlowInfoCommandArchiveDefaultTypeInternal _AddFlowInfoCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR RemoveFlowInfoCommandArchive::RemoveFlowInfoCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.flow_info_uuid_path_)*/nullptr
  , /*decltype(_impl_.undo_object_)*/nullptr
  , /*decltype(_impl_.undo_user_interface_identifier_to_restore_)*/0u
  , /*decltype(_impl_.undo_next_user_interface_identifier_to_restore_)*/0u} {}
struct RemoveFlowInfoCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoveFlowInfoCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoveFlowInfoCommandArchiveDefaultTypeInternal() {}
  union {
    RemoveFlowInfoCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoveFlowInfoCommandArchiveDefaultTypeInternal _RemoveFlowInfoCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR TextCommentReplyCommandArchive::TextCommentReplyCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.annotation_uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_uuid_path_)*/nullptr
  , /*decltype(_impl_.forward_comment_)*/nullptr
  , /*decltype(_impl_.inverse_comment_)*/nullptr
  , /*decltype(_impl_.forward_variant_)*/0
  , /*decltype(_impl_.inverse_variant_)*/0} {}
struct TextCommentReplyCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TextCommentReplyCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TextCommentReplyCommandArchiveDefaultTypeInternal() {}
  union {
    TextCommentReplyCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextCommentReplyCommandArchiveDefaultTypeInternal _TextCommentReplyCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ContainedObjectsCommandArchive_AddBehaviorArgs::ContainedObjectsCommandArchive_AddBehaviorArgs(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.args_list_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ContainedObjectsCommandArchive_AddBehaviorArgsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainedObjectsCommandArchive_AddBehaviorArgsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainedObjectsCommandArchive_AddBehaviorArgsDefaultTypeInternal() {}
  union {
    ContainedObjectsCommandArchive_AddBehaviorArgs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainedObjectsCommandArchive_AddBehaviorArgsDefaultTypeInternal _ContainedObjectsCommandArchive_AddBehaviorArgs_default_instance_;
PROTOBUF_CONSTEXPR ContainedObjectsCommandArchive_RemoveBehaviorArgs::ContainedObjectsCommandArchive_RemoveBehaviorArgs(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.args_list_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ContainedObjectsCommandArchive_RemoveBehaviorArgsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainedObjectsCommandArchive_RemoveBehaviorArgsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainedObjectsCommandArchive_RemoveBehaviorArgsDefaultTypeInternal() {}
  union {
    ContainedObjectsCommandArchive_RemoveBehaviorArgs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainedObjectsCommandArchive_RemoveBehaviorArgsDefaultTypeInternal _ContainedObjectsCommandArchive_RemoveBehaviorArgs_default_instance_;
PROTOBUF_CONSTEXPR ContainedObjectsCommandArchive_RearrangeBehaviorArgs::ContainedObjectsCommandArchive_RearrangeBehaviorArgs(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.args_list_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ContainedObjectsCommandArchive_RearrangeBehaviorArgsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainedObjectsCommandArchive_RearrangeBehaviorArgsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainedObjectsCommandArchive_RearrangeBehaviorArgsDefaultTypeInternal() {}
  union {
    ContainedObjectsCommandArchive_RearrangeBehaviorArgs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainedObjectsCommandArchive_RearrangeBehaviorArgsDefaultTypeInternal _ContainedObjectsCommandArchive_RearrangeBehaviorArgs_default_instance_;
PROTOBUF_CONSTEXPR ContainedObjectsCommandArchive::ContainedObjectsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.objects_)*/{}
  , /*decltype(_impl_.container_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.target_)*/nullptr
  , /*decltype(_impl_.undo_object_for_commit_)*/nullptr
  , /*decltype(_impl_.undo_object_for_make_inverse_)*/nullptr
  , /*decltype(_impl_.add_behavior_args_)*/nullptr
  , /*decltype(_impl_.remove_behavior_args_)*/nullptr
  , /*decltype(_impl_.rearrange_behavior_args_)*/nullptr} {}
struct ContainedObjectsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainedObjectsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainedObjectsCommandArchiveDefaultTypeInternal() {}
  union {
    ContainedObjectsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainedObjectsCommandArchiveDefaultTypeInternal _ContainedObjectsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR EquationInfoGeometryCommandArchive::EquationInfoGeometryCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct EquationInfoGeometryCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EquationInfoGeometryCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EquationInfoGeometryCommandArchiveDefaultTypeInternal() {}
  union {
    EquationInfoGeometryCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EquationInfoGeometryCommandArchiveDefaultTypeInternal _EquationInfoGeometryCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR CharacterStyleChangePropertyCommand_GArchive::CharacterStyleChangePropertyCommand_GArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.range_list_)*/{}
  , /*decltype(_impl_.change_list_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.range_list_undefined_)*/false
  , /*decltype(_impl_.change_list_undefined_)*/false
  , /*decltype(_impl_.disable_character_style_promotion_)*/false} {}
struct CharacterStyleChangePropertyCommand_GArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CharacterStyleChangePropertyCommand_GArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CharacterStyleChangePropertyCommand_GArchiveDefaultTypeInternal() {}
  union {
    CharacterStyleChangePropertyCommand_GArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CharacterStyleChangePropertyCommand_GArchiveDefaultTypeInternal _CharacterStyleChangePropertyCommand_GArchive_default_instance_;
PROTOBUF_CONSTEXPR ParagraphStyleChangePropertyCommand_GArchive::ParagraphStyleChangePropertyCommand_GArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.range_list_)*/{}
  , /*decltype(_impl_.change_list_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.range_list_undefined_)*/false
  , /*decltype(_impl_.change_list_undefined_)*/false} {}
struct ParagraphStyleChangePropertyCommand_GArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ParagraphStyleChangePropertyCommand_GArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ParagraphStyleChangePropertyCommand_GArchiveDefaultTypeInternal() {}
  union {
    ParagraphStyleChangePropertyCommand_GArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ParagraphStyleChangePropertyCommand_GArchiveDefaultTypeInternal _ParagraphStyleChangePropertyCommand_GArchive_default_instance_;
}  // namespace TSWP
static ::_pb::Metadata file_level_metadata_TSWPCommandArchives_2eproto[47];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_TSWPCommandArchives_2eproto[4];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_TSWPCommandArchives_2eproto = nullptr;

const uint32_t TableStruct_TSWPCommandArchives_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::TSWP::DummyCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::DummyCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::DummyCommandArchive, _impl_.foo_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.undo_transaction_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.restore_range_location_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.restore_range_length_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.redo_restore_range_location_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.redo_restore_range_length_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.text_command_flags_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.kind_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::TSWP::StorageActionCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StorageActionCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::StorageActionCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StorageActionCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StorageActionCommandArchive, _impl_.undo_transaction_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StorageActionCommandArchive, _impl_.text_command_flags_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StorageActionCommandArchive, _impl_.kind_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StorageActionCommandArchive, _impl_.custom_format_keys_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StorageActionCommandArchive, _impl_.is_forward_inverse_command_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StorageActionCommandArchive, _impl_.coalesceable_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StorageActionCommandArchive, _impl_.coalescing_text_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StorageActionCommandArchive, _impl_.should_migrate_styles_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StorageActionCommandArchive, _impl_.changed_data_reference_record_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StorageActionCommandArchive, _impl_.coalescing_property_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StorageActionCommandArchive, _impl_.wp_kind_),
  1,
  2,
  3,
  5,
  6,
  ~0u,
  7,
  8,
  9,
  10,
  4,
  0,
  11,
  PROTOBUF_FIELD_OFFSET(::TSWP::SetColumnStyleCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::SetColumnStyleCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::SetColumnStyleCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::SetColumnStyleCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::SetColumnStyleCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::ReplaceAllUsesOfStyleCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ReplaceAllUsesOfStyleCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ReplaceAllUsesOfStyleCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ReplaceAllUsesOfStyleCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ReplaceAllUsesOfStyleCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertColumnsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertColumnsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertColumnsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertColumnsCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertColumnsCommandArchive, _impl_.column_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertColumnsCommandArchive, _impl_.column_count_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertColumnsCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertRowsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertRowsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertRowsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertRowsCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertRowsCommandArchive, _impl_.row_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertRowsCommandArchive, _impl_.row_count_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertRowsCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveColumnsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveColumnsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveColumnsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveColumnsCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveColumnsCommandArchive, _impl_.column_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveColumnsCommandArchive, _impl_.column_count_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveColumnsCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRowsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRowsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRowsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRowsCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRowsCommandArchive, _impl_.row_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRowsCommandArchive, _impl_.row_count_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRowsCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _impl_.row_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _impl_.column_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _impl_.row_count_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _impl_.column_count_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  3,
  4,
  5,
  6,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyPlaceholderTextCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyPlaceholderTextCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyPlaceholderTextCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyPlaceholderTextCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyPlaceholderTextCommandArchive, _impl_.selection_range_location_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyPlaceholderTextCommandArchive, _impl_.selection_range_length_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyPlaceholderTextCommandArchive, _impl_.undo_transaction_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyPlaceholderTextCommandArchive, _impl_.script_tag_),
  1,
  2,
  4,
  5,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateDateTimeFieldCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateDateTimeFieldCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateDateTimeFieldCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateDateTimeFieldCommandArchive, _impl_.date_time_field_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateDateTimeFieldCommandArchive, _impl_.date_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateDateTimeFieldCommandArchive, _impl_.date_style_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateDateTimeFieldCommandArchive, _impl_.time_style_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyRubyTextCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyRubyTextCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyRubyTextCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyRubyTextCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyRubyTextCommandArchive, _impl_.selection_range_location_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyRubyTextCommandArchive, _impl_.selection_range_length_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyRubyTextCommandArchive, _impl_.ruby_text_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyRubyTextCommandArchive, _impl_.undo_transaction_),
  1,
  2,
  4,
  5,
  0,
  3,
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyRubyTextCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyRubyTextCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyRubyTextCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyRubyTextCommandArchive, _impl_.ruby_field_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyRubyTextCommandArchive, _impl_.ruby_text_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyRubyTextCommandArchive, _impl_.base_text_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyRubyTextCommandArchive, _impl_.undo_transaction_),
  2,
  3,
  0,
  1,
  4,
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsBaseCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsBaseCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsBaseCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsBaseCommandArchive, _impl_.old_toc_settings_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsBaseCommandArchive, _impl_.new_toc_settings_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive, _impl_.toc_info_uuid_path_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive, _impl_.theme_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive, _impl_.preset_index_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.attachment_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.h_offset_type_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.h_offset_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.v_offset_type_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.v_offset_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.is_html_wrap_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.undo_h_offset_type_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.undo_h_offset_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.undo_v_offset_type_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.undo_v_offset_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.undo_is_html_wrap_),
  0,
  1,
  2,
  3,
  4,
  5,
  8,
  6,
  7,
  10,
  11,
  9,
  PROTOBUF_FIELD_OFFSET(::TSWP::TextApplyThemeCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextApplyThemeCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::TextApplyThemeCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextApplyThemeCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextApplyThemeCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveColumnsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveColumnsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveColumnsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveColumnsCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveColumnsCommandArchive, _impl_.src_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveColumnsCommandArchive, _impl_.dst_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveColumnsCommandArchive, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveColumnsCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  3,
  4,
  5,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveRowsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveRowsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveRowsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveRowsCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveRowsCommandArchive, _impl_.src_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveRowsCommandArchive, _impl_.dst_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveRowsCommandArchive, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveRowsCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  3,
  4,
  5,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeApplyPresetCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeApplyPresetCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeApplyPresetCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeApplyPresetCommandArchive, _impl_.undo_style_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleBaseCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleBaseCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleBaseCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleBaseCommandArchive, _impl_.theme_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleBaseCommandArchive, _impl_.style_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleCreateCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleCreateCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleCreateCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleCreateCommandArchive, _impl_.preset_index_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleRenameCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleRenameCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleRenameCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleRenameCommandArchive, _impl_.updated_name_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleRenameCommandArchive, _impl_.old_name_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleUpdateCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleUpdateCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleUpdateCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleUpdateCommandArchive, _impl_.original_style_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleUpdateCommandArchive, _impl_.updated_style_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleDeleteCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleDeleteCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleDeleteCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleDeleteCommandArchive, _impl_.old_preset_index_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleReorderCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleReorderCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleReorderCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleReorderCommandArchive, _impl_.old_preset_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleReorderCommandArchive, _impl_.new_preset_index_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleUpdatePropertyMapCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleUpdatePropertyMapCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleUpdatePropertyMapCommandArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeStyleSetValueCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeStyleSetValueCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeStyleSetValueCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeStyleSetValueCommandArchive, _impl_.change_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSWP::SelectionTransformerArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::SelectionTransformerArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::SelectionTransformerArchive, _impl_.storage_uuid_path_),
  PROTOBUF_FIELD_OFFSET(::TSWP::SelectionTransformerArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TSWP::SelectionTransformerArchive, _impl_.transformed_to_noop_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::PencilAnnotationSelectionTransformerArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::PencilAnnotationSelectionTransformerArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::PencilAnnotationSelectionTransformerArchive, _impl_.storage_uuid_path_),
  PROTOBUF_FIELD_OFFSET(::TSWP::PencilAnnotationSelectionTransformerArchive, _impl_.text_pencil_annotation_uuid_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeSelectionTransformerArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeSelectionTransformerArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeSelectionTransformerArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeSelectionTransformerArchive, _impl_.storage_uuid_path_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeContentDescription, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeContentDescription, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeContentDescription, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeContentDescription, _impl_.text_range_location_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeContentDescription, _impl_.text_range_length_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::ObjectPropertyArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ObjectPropertyArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ObjectPropertyArchive, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ObjectPropertyArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ObjectPropertyArchive, _impl_.bool_value_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ObjectPropertyArchive, _impl_.float_value_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ObjectPropertyArchive, _impl_.integer_value_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ObjectPropertyArchive, _impl_.string_value_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ObjectPropertyArchive, _impl_.id_path_value_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ObjectPropertyArchive, _impl_.fill_value_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ObjectPropertyArchive, _impl_.color_value_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ObjectPropertyArchive, _impl_.shadow_value_),
  0,
  6,
  7,
  8,
  9,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TSWP::SetObjectPropertiesCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::SetObjectPropertiesCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::SetObjectPropertiesCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::SetObjectPropertiesCommandArchive, _impl_.object_uuid_path_),
  PROTOBUF_FIELD_OFFSET(::TSWP::SetObjectPropertiesCommandArchive, _impl_.properties_),
  PROTOBUF_FIELD_OFFSET(::TSWP::SetObjectPropertiesCommandArchive, _impl_.action_string_),
  PROTOBUF_FIELD_OFFSET(::TSWP::SetObjectPropertiesCommandArchive, _impl_.old_properties_),
  1,
  2,
  ~0u,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateFlowInfoCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateFlowInfoCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateFlowInfoCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateFlowInfoCommandArchive, _impl_.command_mode_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateFlowInfoCommandArchive, _impl_.flow_info_uuid_path_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateFlowInfoCommandArchive, _impl_.text_box_id_path_to_add_or_remove_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateFlowInfoCommandArchive, _impl_.text_box_id_paths_at_start_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateFlowInfoCommandArchive, _impl_.suggested_text_box_id_paths_at_end_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateFlowInfoCommandArchive, _impl_.undo_text_boxes_to_restore_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateFlowInfoCommandArchive, _impl_.undo_added_shape_info_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateFlowInfoCommandArchive, _impl_.undo_removed_shape_info_),
  0,
  5,
  1,
  2,
  ~0u,
  ~0u,
  ~0u,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TSWP::AddFlowInfoCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AddFlowInfoCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::AddFlowInfoCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AddFlowInfoCommandArchive, _impl_.flow_info_to_add_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AddFlowInfoCommandArchive, _impl_.flow_info_archive_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AddFlowInfoCommandArchive, _impl_.undo_user_interface_identifier_to_restore_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AddFlowInfoCommandArchive, _impl_.undo_next_user_interface_identifier_to_restore_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AddFlowInfoCommandArchive, _impl_.working_undo_object_),
  0,
  1,
  2,
  4,
  5,
  3,
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveFlowInfoCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveFlowInfoCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveFlowInfoCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveFlowInfoCommandArchive, _impl_.flow_info_uuid_path_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveFlowInfoCommandArchive, _impl_.undo_object_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveFlowInfoCommandArchive, _impl_.undo_user_interface_identifier_to_restore_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveFlowInfoCommandArchive, _impl_.undo_next_user_interface_identifier_to_restore_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommentReplyCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommentReplyCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommentReplyCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommentReplyCommandArchive, _impl_.storage_uuid_path_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommentReplyCommandArchive, _impl_.annotation_uuid_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommentReplyCommandArchive, _impl_.forward_comment_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommentReplyCommandArchive, _impl_.inverse_comment_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommentReplyCommandArchive, _impl_.forward_variant_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommentReplyCommandArchive, _impl_.inverse_variant_),
  1,
  2,
  0,
  3,
  4,
  5,
  6,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive_AddBehaviorArgs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive_AddBehaviorArgs, _impl_.args_list_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive_RemoveBehaviorArgs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive_RemoveBehaviorArgs, _impl_.args_list_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive_RearrangeBehaviorArgs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive_RearrangeBehaviorArgs, _impl_.args_list_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive, _impl_.target_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive, _impl_.objects_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive, _impl_.undo_object_for_commit_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive, _impl_.undo_object_for_make_inverse_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive, _impl_.add_behavior_args_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive, _impl_.remove_behavior_args_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive, _impl_.rearrange_behavior_args_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ContainedObjectsCommandArchive, _impl_.container_name_),
  1,
  2,
  ~0u,
  3,
  4,
  5,
  6,
  7,
  0,
  PROTOBUF_FIELD_OFFSET(::TSWP::EquationInfoGeometryCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::EquationInfoGeometryCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::EquationInfoGeometryCommandArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSWP::CharacterStyleChangePropertyCommand_GArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::CharacterStyleChangePropertyCommand_GArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::CharacterStyleChangePropertyCommand_GArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::CharacterStyleChangePropertyCommand_GArchive, _impl_.range_list_),
  PROTOBUF_FIELD_OFFSET(::TSWP::CharacterStyleChangePropertyCommand_GArchive, _impl_.range_list_undefined_),
  PROTOBUF_FIELD_OFFSET(::TSWP::CharacterStyleChangePropertyCommand_GArchive, _impl_.change_list_),
  PROTOBUF_FIELD_OFFSET(::TSWP::CharacterStyleChangePropertyCommand_GArchive, _impl_.change_list_undefined_),
  PROTOBUF_FIELD_OFFSET(::TSWP::CharacterStyleChangePropertyCommand_GArchive, _impl_.disable_character_style_promotion_),
  0,
  ~0u,
  1,
  ~0u,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSWP::ParagraphStyleChangePropertyCommand_GArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ParagraphStyleChangePropertyCommand_GArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ParagraphStyleChangePropertyCommand_GArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ParagraphStyleChangePropertyCommand_GArchive, _impl_.range_list_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ParagraphStyleChangePropertyCommand_GArchive, _impl_.range_list_undefined_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ParagraphStyleChangePropertyCommand_GArchive, _impl_.change_list_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ParagraphStyleChangePropertyCommand_GArchive, _impl_.change_list_undefined_),
  0,
  ~0u,
  1,
  ~0u,
  2,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, -1, sizeof(::TSWP::DummyCommandArchive)},
  { 8, 23, -1, sizeof(::TSWP::TextCommandArchive)},
  { 32, 51, -1, sizeof(::TSWP::StorageActionCommandArchive)},
  { 64, 73, -1, sizeof(::TSWP::SetColumnStyleCommandArchive)},
  { 76, 85, -1, sizeof(::TSWP::ReplaceAllUsesOfStyleCommandArchive)},
  { 88, 99, -1, sizeof(::TSWP::InsertColumnsCommandArchive)},
  { 104, 115, -1, sizeof(::TSWP::InsertRowsCommandArchive)},
  { 120, 131, -1, sizeof(::TSWP::RemoveColumnsCommandArchive)},
  { 136, 147, -1, sizeof(::TSWP::RemoveRowsCommandArchive)},
  { 152, 165, -1, sizeof(::TSWP::MergeCellsCommandArchive)},
  { 172, 184, -1, sizeof(::TSWP::ApplyPlaceholderTextCommandArchive)},
  { 190, 201, -1, sizeof(::TSWP::UpdateDateTimeFieldCommandArchive)},
  { 206, 218, -1, sizeof(::TSWP::ApplyRubyTextCommandArchive)},
  { 224, 235, -1, sizeof(::TSWP::ModifyRubyTextCommandArchive)},
  { 240, 249, -1, sizeof(::TSWP::ModifyTOCSettingsBaseCommandArchive)},
  { 252, 260, -1, sizeof(::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive)},
  { 262, 271, -1, sizeof(::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive)},
  { 274, 292, -1, sizeof(::TSWP::AnchorAttachmentCommandArchive)},
  { 304, 313, -1, sizeof(::TSWP::TextApplyThemeCommandArchive)},
  { 316, 328, -1, sizeof(::TSWP::MoveColumnsCommandArchive)},
  { 334, 346, -1, sizeof(::TSWP::MoveRowsCommandArchive)},
  { 352, 360, -1, sizeof(::TSWP::ShapeApplyPresetCommandArchive)},
  { 362, 371, -1, sizeof(::TSWP::StyleBaseCommandArchive)},
  { 374, 382, -1, sizeof(::TSWP::StyleCreateCommandArchive)},
  { 384, 393, -1, sizeof(::TSWP::StyleRenameCommandArchive)},
  { 396, 405, -1, sizeof(::TSWP::StyleUpdateCommandArchive)},
  { 408, 416, -1, sizeof(::TSWP::StyleDeleteCommandArchive)},
  { 418, 427, -1, sizeof(::TSWP::StyleReorderCommandArchive)},
  { 430, 437, -1, sizeof(::TSWP::StyleUpdatePropertyMapCommandArchive)},
  { 438, 446, -1, sizeof(::TSWP::ShapeStyleSetValueCommandArchive)},
  { 448, 457, -1, sizeof(::TSWP::SelectionTransformerArchive)},
  { 460, 468, -1, sizeof(::TSWP::PencilAnnotationSelectionTransformerArchive)},
  { 470, 478, -1, sizeof(::TSWP::ShapeSelectionTransformerArchive)},
  { 480, 489, -1, sizeof(::TSWP::ShapeContentDescription)},
  { 492, 508, -1, sizeof(::TSWP::ObjectPropertyArchive)},
  { 518, 529, -1, sizeof(::TSWP::SetObjectPropertiesCommandArchive)},
  { 534, 549, -1, sizeof(::TSWP::UpdateFlowInfoCommandArchive)},
  { 558, 570, -1, sizeof(::TSWP::AddFlowInfoCommandArchive)},
  { 576, 587, -1, sizeof(::TSWP::RemoveFlowInfoCommandArchive)},
  { 592, 605, -1, sizeof(::TSWP::TextCommentReplyCommandArchive)},
  { 612, -1, -1, sizeof(::TSWP::ContainedObjectsCommandArchive_AddBehaviorArgs)},
  { 619, -1, -1, sizeof(::TSWP::ContainedObjectsCommandArchive_RemoveBehaviorArgs)},
  { 626, -1, -1, sizeof(::TSWP::ContainedObjectsCommandArchive_RearrangeBehaviorArgs)},
  { 633, 648, -1, sizeof(::TSWP::ContainedObjectsCommandArchive)},
  { 657, 664, -1, sizeof(::TSWP::EquationInfoGeometryCommandArchive)},
  { 665, 677, -1, sizeof(::TSWP::CharacterStyleChangePropertyCommand_GArchive)},
  { 683, 694, -1, sizeof(::TSWP::ParagraphStyleChangePropertyCommand_GArchive)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::TSWP::_DummyCommandArchive_default_instance_._instance,
  &::TSWP::_TextCommandArchive_default_instance_._instance,
  &::TSWP::_StorageActionCommandArchive_default_instance_._instance,
  &::TSWP::_SetColumnStyleCommandArchive_default_instance_._instance,
  &::TSWP::_ReplaceAllUsesOfStyleCommandArchive_default_instance_._instance,
  &::TSWP::_InsertColumnsCommandArchive_default_instance_._instance,
  &::TSWP::_InsertRowsCommandArchive_default_instance_._instance,
  &::TSWP::_RemoveColumnsCommandArchive_default_instance_._instance,
  &::TSWP::_RemoveRowsCommandArchive_default_instance_._instance,
  &::TSWP::_MergeCellsCommandArchive_default_instance_._instance,
  &::TSWP::_ApplyPlaceholderTextCommandArchive_default_instance_._instance,
  &::TSWP::_UpdateDateTimeFieldCommandArchive_default_instance_._instance,
  &::TSWP::_ApplyRubyTextCommandArchive_default_instance_._instance,
  &::TSWP::_ModifyRubyTextCommandArchive_default_instance_._instance,
  &::TSWP::_ModifyTOCSettingsBaseCommandArchive_default_instance_._instance,
  &::TSWP::_ModifyTOCSettingsForTOCInfoCommandArchive_default_instance_._instance,
  &::TSWP::_ModifyTOCSettingsPresetForThemeCommandArchive_default_instance_._instance,
  &::TSWP::_AnchorAttachmentCommandArchive_default_instance_._instance,
  &::TSWP::_TextApplyThemeCommandArchive_default_instance_._instance,
  &::TSWP::_MoveColumnsCommandArchive_default_instance_._instance,
  &::TSWP::_MoveRowsCommandArchive_default_instance_._instance,
  &::TSWP::_ShapeApplyPresetCommandArchive_default_instance_._instance,
  &::TSWP::_StyleBaseCommandArchive_default_instance_._instance,
  &::TSWP::_StyleCreateCommandArchive_default_instance_._instance,
  &::TSWP::_StyleRenameCommandArchive_default_instance_._instance,
  &::TSWP::_StyleUpdateCommandArchive_default_instance_._instance,
  &::TSWP::_StyleDeleteCommandArchive_default_instance_._instance,
  &::TSWP::_StyleReorderCommandArchive_default_instance_._instance,
  &::TSWP::_StyleUpdatePropertyMapCommandArchive_default_instance_._instance,
  &::TSWP::_ShapeStyleSetValueCommandArchive_default_instance_._instance,
  &::TSWP::_SelectionTransformerArchive_default_instance_._instance,
  &::TSWP::_PencilAnnotationSelectionTransformerArchive_default_instance_._instance,
  &::TSWP::_ShapeSelectionTransformerArchive_default_instance_._instance,
  &::TSWP::_ShapeContentDescription_default_instance_._instance,
  &::TSWP::_ObjectPropertyArchive_default_instance_._instance,
  &::TSWP::_SetObjectPropertiesCommandArchive_default_instance_._instance,
  &::TSWP::_UpdateFlowInfoCommandArchive_default_instance_._instance,
  &::TSWP::_AddFlowInfoCommandArchive_default_instance_._instance,
  &::TSWP::_RemoveFlowInfoCommandArchive_default_instance_._instance,
  &::TSWP::_TextCommentReplyCommandArchive_default_instance_._instance,
  &::TSWP::_ContainedObjectsCommandArchive_AddBehaviorArgs_default_instance_._instance,
  &::TSWP::_ContainedObjectsCommandArchive_RemoveBehaviorArgs_default_instance_._instance,
  &::TSWP::_ContainedObjectsCommandArchive_RearrangeBehaviorArgs_default_instance_._instance,
  &::TSWP::_ContainedObjectsCommandArchive_default_instance_._instance,
  &::TSWP::_EquationInfoGeometryCommandArchive_default_instance_._instance,
  &::TSWP::_CharacterStyleChangePropertyCommand_GArchive_default_instance_._instance,
  &::TSWP::_ParagraphStyleChangePropertyCommand_GArchive_default_instance_._instance,
};

const char descriptor_table_protodef_TSWPCommandArchives_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\031TSWPCommandArchives.proto\022\004TSWP\032\021TSPMe"
  "ssages.proto\032\021TSSArchives.proto\032\021TSDArch"
  "ives.proto\032\030TSDCommandArchives.proto\032\021TS"
  "KArchives.proto\032\022TSWPArchives.proto\032\026TSW"
  "PArchives.sos.proto\"\"\n\023DummyCommandArchi"
  "ve\022\013\n\003foo\030\001 \002(\r\"\351\006\n\022TextCommandArchive\022\""
  "\n\005super\030\001 \001(\0132\023.TSK.CommandArchive\022\037\n\007st"
  "orage\030\002 \001(\0132\016.TSP.Reference\022/\n\020undo_tran"
  "saction\030\003 \001(\0132\025.TSWP.UndoTransaction\022\036\n\026"
  "restore_range_location\030\004 \001(\r\022\034\n\024restore_"
  "range_length\030\005 \001(\r\022#\n\033redo_restore_range"
  "_location\030\006 \001(\r\022!\n\031redo_restore_range_le"
  "ngth\030\007 \001(\r\022\032\n\022text_command_flags\030\t \001(\r\022;"
  "\n\004kind\030\n \001(\0162\035.TSWP.TextCommandArchive.K"
  "ind:\016kKindContained\"\375\003\n\004Kind\022\022\n\016kKindCon"
  "tained\020\000\022\024\n\020kKindReplaceText\020\001\022\016\n\nkKindP"
  "aste\020\002\022\027\n\023kKindParagraphStyle\020\003\022\022\n\016kKind"
  "ListStyle\020\004\022\035\n\031kKindIndentParagraphLevel"
  "\020\005\022\021\n\rkKindDragText\020\006\022\023\n\017kKindPasteStyle"
  "\020\007\022\034\n\030kKindApplyChangesInRange\020\010\022\034\n\030kKin"
  "dInsertCitationField\020\n\022 \n\034kKindInsertBib"
  "liographyEntry\020\013\022\035\n\031kKindFormatCitationF"
  "ields\020\014\022\034\n\030kKindInsertTOCSmartField\020\r\022\034\n"
  "\030kKindInsertDateTimeField\020\016\022\034\n\030kKindUpda"
  "teDateTimeField\020\017\022%\n!kKindSetParagraphFi"
  "rstTopicNumber\020\020\022\027\n\023kKindCharacterStyle\020"
  "\021\022\025\n\021kKindRevertStyles\020\022\022\031\n\025kKindSetPara"
  "graphBidi\020\023\"\210\r\n\033StorageActionCommandArch"
  "ive\022\"\n\005super\030\001 \001(\0132\023.TSK.CommandArchive\022"
  "\036\n\007storage\030\002 \001(\0132\r.TSP.UUIDPath\022/\n\020undo_"
  "transaction\030\003 \001(\0132\025.TSWP.UndoTransaction"
  "\022\032\n\022text_command_flags\030\004 \001(\r\022D\n\004kind\030\005 \001"
  "(\0162&.TSWP.StorageActionCommandArchive.Ki"
  "nd:\016kKindContained\022%\n\022custom_format_keys"
  "\030\006 \003(\0132\t.TSP.UUID\022\"\n\032is_forward_inverse_"
  "command\030\007 \001(\010\022\024\n\014coalesceable\030\010 \001(\010\022\027\n\017c"
  "oalescing_text\030\t \001(\010\022\035\n\025should_migrate_s"
  "tyles\030\n \001(\010\022\?\n\035changed_data_reference_re"
  "cord\030\013 \001(\0132\030.TSK.DataReferenceRecord\022\033\n\023"
  "coalescing_property\030\014 \001(\t\022.\n\007wp_kind\030\r \001"
  "(\0162\035.TSWP.StorageArchive.KindType\"\352\010\n\004Ki"
  "nd\022\022\n\016kKindContained\020\000\022\024\n\020kKindReplaceTe"
  "xt\020\001\022\016\n\nkKindPaste\020\002\022\027\n\023kKindParagraphSt"
  "yle\020\003\022\022\n\016kKindListStyle\020\004\022\035\n\031kKindIndent"
  "ParagraphLevel\020\005\022\021\n\rkKindDragText\020\006\022\023\n\017k"
  "KindPasteStyle\020\007\022\034\n\030kKindApplyChangesInR"
  "ange\020\010\022\034\n\030kKindInsertCitationField\020\n\022 \n\034"
  "kKindInsertBibliographyEntry\020\013\022\035\n\031kKindF"
  "ormatCitationFields\020\014\022\034\n\030kKindInsertTOCS"
  "martField\020\r\022\034\n\030kKindInsertDateTimeField\020"
  "\016\022\034\n\030kKindUpdateDateTimeField\020\017\022%\n!kKind"
  "SetParagraphFirstTopicNumber\020\020\022\027\n\023kKindC"
  "haracterStyle\020\021\022\025\n\021kKindRevertStyles\020\022\022\031"
  "\n\025kKindSetParagraphBidi\020\023\022\023\n\017kKindFormat"
  "Text\020\024\022\031\n\025kKindInsertAttachment\020\025\022\030\n\024kKi"
  "ndCreateHyperlink\020\026\022\030\n\024kKindModifyHyperl"
  "ink\020\027\022\030\n\024kKindRemoveHyperlink\020\030\022\033\n\027kKind"
  "ApplyHighlightText\020\031\022\036\n\032kKindPropagateSt"
  "yleChanges\020\032\022$\n kKindMovedAnchoredDrawab"
  "leInline\020\033\022\036\n\032kKindMoveDrawablesAttached"
  "\020\034\022\"\n\036kKindMoveMoveDrawablesFloating\020\035\022#"
  "\n\037kKindMoveInlineDrawableAnchored\020\036\022\031\n\025k"
  "KindAnchorAttachment\020\037\022\021\n\rkKindBookmark\020"
  " \022\027\n\023kKindReplaceSection\020!\022\036\n\032kKindApply"
  "PencilAnnotation\020\"\022\023\n\017kKindCreateRuby\020#\022"
  "\023\n\017kKindModifyRuby\020$\022\023\n\017kKindRemoveRuby\020"
  "%\022\024\n\020kKindTateChuYoko\020&\022\025\n\021kKindDropCapS"
  "tyle\020\'\022\023\n\017kKindMergeField\020(\022\031\n\025kKindModi"
  "fyMergeField\020)\022\036\n\032kKindMergeFieldTypeRep"
  "lace\020*\"\224\001\n\034SetColumnStyleCommandArchive\022"
  "\"\n\005super\030\001 \001(\0132\023.TSK.CommandArchive\022\037\n\007s"
  "torage\030\002 \001(\0132\016.TSP.Reference\022/\n\020undo_tra"
  "nsaction\030\003 \001(\0132\025.TSWP.UndoTransaction\"\233\001"
  "\n#ReplaceAllUsesOfStyleCommandArchive\022\"\n"
  "\005super\030\001 \001(\0132\023.TSK.CommandArchive\022\037\n\007sto"
  "rage\030\002 \001(\0132\016.TSP.Reference\022/\n\020undo_trans"
  "action\030\003 \001(\0132\025.TSWP.UndoTransaction\"\277\001\n\033"
  "InsertColumnsCommandArchive\022\"\n\005super\030\001 \001"
  "(\0132\023.TSK.CommandArchive\022\037\n\007storage\030\002 \001(\013"
  "2\016.TSP.Reference\022\024\n\014column_index\030\003 \001(\r\022\024"
  "\n\014column_count\030\004 \001(\r\022/\n\020undo_transaction"
  "\030\005 \001(\0132\025.TSWP.UndoTransaction\"\266\001\n\030Insert"
  "RowsCommandArchive\022\"\n\005super\030\001 \001(\0132\023.TSK."
  "CommandArchive\022\037\n\007storage\030\002 \001(\0132\016.TSP.Re"
  "ference\022\021\n\trow_index\030\003 \001(\r\022\021\n\trow_count\030"
  "\004 \001(\r\022/\n\020undo_transaction\030\005 \001(\0132\025.TSWP.U"
  "ndoTransaction\"\277\001\n\033RemoveColumnsCommandA"
  "rchive\022\"\n\005super\030\001 \001(\0132\023.TSK.CommandArchi"
  "ve\022\037\n\007storage\030\002 \001(\0132\016.TSP.Reference\022\024\n\014c"
  "olumn_index\030\003 \001(\r\022\024\n\014column_count\030\004 \001(\r\022"
  "/\n\020undo_transaction\030\005 \001(\0132\025.TSWP.UndoTra"
  "nsaction\"\266\001\n\030RemoveRowsCommandArchive\022\"\n"
  "\005super\030\001 \001(\0132\023.TSK.CommandArchive\022\037\n\007sto"
  "rage\030\002 \001(\0132\016.TSP.Reference\022\021\n\trow_index\030"
  "\003 \001(\r\022\021\n\trow_count\030\004 \001(\r\022/\n\020undo_transac"
  "tion\030\005 \001(\0132\025.TSWP.UndoTransaction\"\326\001\n\030Me"
  "rgeCellsCommandArchive\022\"\n\005super\030\001 \001(\0132\023."
  "TSK.CommandArchive\022\037\n\007storage\030\002 \001(\0132\016.TS"
  "P.Reference\022\013\n\003row\030\003 \001(\r\022\016\n\006column\030\004 \001(\r"
  "\022\021\n\trow_count\030\005 \001(\r\022\024\n\014column_count\030\006 \001("
  "\r\022/\n\020undo_transaction\030\007 \001(\0132\025.TSWP.UndoT"
  "ransaction\"\360\001\n\"ApplyPlaceholderTextComma"
  "ndArchive\022\"\n\005super\030\001 \001(\0132\023.TSK.CommandAr"
  "chive\022\037\n\007storage\030\002 \001(\0132\016.TSP.Reference\022 "
  "\n\030selection_range_location\030\003 \001(\r\022\036\n\026sele"
  "ction_range_length\030\004 \001(\r\022/\n\020undo_transac"
  "tion\030\005 \001(\0132\025.TSWP.UndoTransaction\022\022\n\nscr"
  "ipt_tag\030\006 \001(\t\"\246\002\n!UpdateDateTimeFieldCom"
  "mandArchive\022\'\n\005super\030\001 \001(\0132\030.TSWP.TextCo"
  "mmandArchive\022\'\n\017date_time_field\030\002 \001(\0132\016."
  "TSP.Reference\022\027\n\004date\030\003 \001(\0132\t.TSP.Date\022J"
  "\n\ndate_style\030\004 \001(\01626.TSWP.DateTimeSmartF"
  "ieldArchive.DateTimeFormatterStyle\022J\n\nti"
  "me_style\030\005 \001(\01626.TSWP.DateTimeSmartField"
  "Archive.DateTimeFormatterStyle\"\350\001\n\033Apply"
  "RubyTextCommandArchive\022\"\n\005super\030\001 \001(\0132\023."
  "TSK.CommandArchive\022\037\n\007storage\030\002 \001(\0132\016.TS"
  "P.Reference\022 \n\030selection_range_location\030"
  "\003 \001(\r\022\036\n\026selection_range_length\030\004 \001(\r\022\021\n"
  "\truby_text\030\005 \001(\t\022/\n\020undo_transaction\030\006 \001"
  "(\0132\025.TSWP.UndoTransaction\"\275\001\n\034ModifyRuby"
  "TextCommandArchive\022\"\n\005super\030\001 \001(\0132\023.TSK."
  "CommandArchive\022\"\n\nruby_field\030\002 \001(\0132\016.TSP"
  ".Reference\022\021\n\truby_text\030\003 \001(\t\022\021\n\tbase_te"
  "xt\030\004 \001(\t\022/\n\020undo_transaction\030\005 \001(\0132\025.TSW"
  "P.UndoTransaction\"\235\001\n#ModifyTOCSettingsB"
  "aseCommandArchive\022\"\n\005super\030\001 \001(\0132\023.TSK.C"
  "ommandArchive\022(\n\020old_toc_settings\030\002 \001(\0132"
  "\016.TSP.Reference\022(\n\020new_toc_settings\030\003 \001("
  "\0132\016.TSP.Reference\"\220\001\n)ModifyTOCSettingsF"
  "orTOCInfoCommandArchive\0228\n\005super\030\001 \001(\0132)"
  ".TSWP.ModifyTOCSettingsBaseCommandArchiv"
  "e\022)\n\022toc_info_uuid_path\030\002 \001(\0132\r.TSP.UUID"
  "Path\"\236\001\n-ModifyTOCSettingsPresetForTheme"
  "CommandArchive\0228\n\005super\030\001 \001(\0132).TSWP.Mod"
  "ifyTOCSettingsBaseCommandArchive\022\035\n\005them"
  "e\030\002 \001(\0132\016.TSP.Reference\022\024\n\014preset_index\030"
  "\003 \001(\r\"\337\002\n\036AnchorAttachmentCommandArchive"
  "\0220\n\005super\030\001 \001(\0132!.TSWP.StorageActionComm"
  "andArchive\022\"\n\nattachment\030\002 \001(\0132\016.TSP.Ref"
  "erence\022\025\n\rh_offset_type\030\003 \001(\r\022\020\n\010h_offse"
  "t\030\004 \001(\002\022\025\n\rv_offset_type\030\005 \001(\r\022\020\n\010v_offs"
  "et\030\006 \001(\002\022\024\n\014is_html_wrap\030\007 \001(\010\022\032\n\022undo_h"
  "_offset_type\030\010 \001(\r\022\025\n\rundo_h_offset\030\t \001("
  "\002\022\032\n\022undo_v_offset_type\030\n \001(\r\022\025\n\rundo_v_"
  "offset\030\013 \001(\002\022\031\n\021undo_is_html_wrap\030\014 \001(\010\""
  "\243\001\n\034TextApplyThemeCommandArchive\0221\n\005supe"
  "r\030\001 \001(\0132\".TSS.ApplyThemeChildCommandArch"
  "ive\022\037\n\007storage\030\002 \001(\0132\016.TSP.Reference\022/\n\020"
  "undo_transaction\030\006 \001(\0132\025.TSWP.UndoTransa"
  "ction\"\306\001\n\031MoveColumnsCommandArchive\022\"\n\005s"
  "uper\030\001 \001(\0132\023.TSK.CommandArchive\022\037\n\007stora"
  "ge\030\002 \001(\0132\016.TSP.Reference\022\021\n\tsrc_index\030\003 "
  "\001(\r\022\021\n\tdst_index\030\004 \001(\r\022\r\n\005count\030\005 \001(\r\022/\n"
  "\020undo_transaction\030\006 \001(\0132\025.TSWP.UndoTrans"
  "action\"\303\001\n\026MoveRowsCommandArchive\022\"\n\005sup"
  "er\030\001 \001(\0132\023.TSK.CommandArchive\022\037\n\007storage"
  "\030\002 \001(\0132\016.TSP.Reference\022\021\n\tsrc_index\030\003 \001("
  "\r\022\021\n\tdst_index\030\004 \001(\r\022\r\n\005count\030\005 \001(\r\022/\n\020u"
  "ndo_transaction\030\006 \001(\0132\025.TSWP.UndoTransac"
  "tion\"w\n\036ShapeApplyPresetCommandArchive\0221"
  "\n\005super\030\001 \002(\0132\".TSD.BaseApplyPresetComma"
  "ndArchive\022\"\n\nundo_style\030\002 \001(\0132\016.TSP.Refe"
  "rence\"{\n\027StyleBaseCommandArchive\022\"\n\005supe"
  "r\030\001 \001(\0132\023.TSK.CommandArchive\022\035\n\005theme\030\002 "
  "\001(\0132\016.TSP.Reference\022\035\n\005style\030\003 \001(\0132\016.TSP"
  ".Reference\"_\n\031StyleCreateCommandArchive\022"
  ",\n\005super\030\001 \001(\0132\035.TSWP.StyleBaseCommandAr"
  "chive\022\024\n\014preset_index\030\002 \001(\r\"q\n\031StyleRena"
  "meCommandArchive\022,\n\005super\030\001 \001(\0132\035.TSWP.S"
  "tyleBaseCommandArchive\022\024\n\014updated_name\030\002"
  " \001(\t\022\020\n\010old_name\030\003 \001(\t\"\230\001\n\031StyleUpdateCo"
  "mmandArchive\022,\n\005super\030\001 \001(\0132\035.TSWP.Style"
  "BaseCommandArchive\022&\n\016original_style\030\002 \001"
  "(\0132\016.TSP.Reference\022%\n\rupdated_style\030\003 \001("
  "\0132\016.TSP.Reference\"c\n\031StyleDeleteCommandA"
  "rchive\022,\n\005super\030\001 \001(\0132\035.TSWP.StyleBaseCo"
  "mmandArchive\022\030\n\020old_preset_index\030\002 \001(\r\"~"
  "\n\032StyleReorderCommandArchive\022,\n\005super\030\001 "
  "\001(\0132\035.TSWP.StyleBaseCommandArchive\022\030\n\020ol"
  "d_preset_index\030\002 \001(\r\022\030\n\020new_preset_index"
  "\030\003 \001(\r\"`\n$StyleUpdatePropertyMapCommandA"
  "rchive\0228\n\005super\030\001 \002(\0132).TSS.StyleUpdateP"
  "ropertyMapCommandArchive\"\224\001\n ShapeStyleS"
  "etValueCommandArchive\0223\n\005super\030\001 \002(\0132$.T"
  "SD.BaseStyleSetValueCommandArchive\022;\n\006ch"
  "ange\030\004 \001(\0132+.TSWPSOS.ShapeStylePropertyC"
  "hangeSetArchive\"\207\001\n\033SelectionTransformer"
  "Archive\022(\n\021storage_uuid_path\030\001 \002(\0132\r.TSP"
  ".UUIDPath\022!\n\tselection\030\002 \002(\0132\016.TSP.Refer"
  "ence\022\033\n\023transformed_to_noop\030\003 \001(\010\"|\n+Pen"
  "cilAnnotationSelectionTransformerArchive"
  "\022(\n\021storage_uuid_path\030\001 \002(\0132\r.TSP.UUIDPa"
  "th\022#\n\033text_pencil_annotation_uuid\030\002 \002(\t\""
  "\202\001\n ShapeSelectionTransformerArchive\0224\n\005"
  "super\030\001 \002(\0132%.TSD.ShapeSelectionTransfor"
  "merArchive\022(\n\021storage_uuid_path\030\002 \001(\0132\r."
  "TSP.UUIDPath\"\201\001\n\027ShapeContentDescription"
  "\022.\n\005super\030\001 \002(\0132\037.TSD.DrawableContentDes"
  "cription\022\033\n\023text_range_location\030\002 \001(\r\022\031\n"
  "\021text_range_length\030\003 \001(\r\"\272\002\n\025ObjectPrope"
  "rtyArchive\022\014\n\004name\030\001 \002(\t\022&\n\004type\030\002 \002(\0162\030"
  ".TSWP.ObjectPropertyType\022\022\n\nbool_value\030\003"
  " \001(\010\022\023\n\013float_value\030\004 \001(\002\022\025\n\rinteger_val"
  "ue\030\005 \001(\005\022\024\n\014string_value\030\006 \001(\t\022$\n\rid_pat"
  "h_value\030\007 \001(\0132\r.TSP.UUIDPath\022$\n\nfill_val"
  "ue\030\010 \001(\0132\020.TSD.FillArchive\022\037\n\013color_valu"
  "e\030\t \001(\0132\n.TSP.Color\022(\n\014shadow_value\030\n \001("
  "\0132\022.TSD.ShadowArchive\"\355\001\n!SetObjectPrope"
  "rtiesCommandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK"
  ".CommandArchive\022\'\n\020object_uuid_path\030\002 \002("
  "\0132\r.TSP.UUIDPath\022/\n\nproperties\030\003 \003(\0132\033.T"
  "SWP.ObjectPropertyArchive\022\025\n\raction_stri"
  "ng\030\004 \001(\t\0223\n\016old_properties\030\005 \003(\0132\033.TSWP."
  "ObjectPropertyArchive\"\311\004\n\034UpdateFlowInfo"
  "CommandArchive\022\"\n\005super\030\001 \001(\0132\023.TSK.Comm"
  "andArchive\022M\n\014command_mode\030\002 \001(\0162\'.TSWP."
  "UpdateFlowInfoCommandArchive.Mode:\016kMode"
  "Rearrange\022*\n\023flow_info_uuid_path\030\003 \001(\0132\r"
  ".TSP.UUIDPath\0228\n!text_box_id_path_to_add"
  "_or_remove\030\004 \001(\0132\r.TSP.UUIDPath\0221\n\032text_"
  "box_id_paths_at_start\030\005 \003(\0132\r.TSP.UUIDPa"
  "th\0229\n\"suggested_text_box_id_paths_at_end"
  "\030\006 \003(\0132\r.TSP.UUIDPath\0222\n\032undo_text_boxes"
  "_to_restore\030\007 \003(\0132\016.TSP.Reference\022-\n\025und"
  "o_added_shape_info\030\010 \001(\0132\016.TSP.Reference"
  "\022/\n\027undo_removed_shape_info\030\t \001(\0132\016.TSP."
  "Reference\"N\n\004Mode\022\022\n\016kModeRearrange\020\000\022\014\n"
  "\010kModeAdd\020\001\022\017\n\013kModeRemove\020\002\022\023\n\017kModeCom"
  "pensate\020\003\"\254\002\n\031AddFlowInfoCommandArchive\022"
  "\"\n\005super\030\001 \001(\0132\023.TSK.CommandArchive\022(\n\020f"
  "low_info_to_add\030\002 \001(\0132\016.TSP.Reference\022)\n"
  "\021flow_info_archive\030\003 \001(\0132\016.TSP.Reference"
  "\0221\n)undo_user_interface_identifier_to_re"
  "store\030\004 \001(\r\0226\n.undo_next_user_interface_"
  "identifier_to_restore\030\005 \001(\r\022+\n\023working_u"
  "ndo_object\030\006 \001(\0132\016.TSP.Reference\"\376\001\n\034Rem"
  "oveFlowInfoCommandArchive\022\"\n\005super\030\001 \001(\013"
  "2\023.TSK.CommandArchive\022*\n\023flow_info_uuid_"
  "path\030\002 \001(\0132\r.TSP.UUIDPath\022#\n\013undo_object"
  "\030\003 \001(\0132\016.TSP.Reference\0221\n)undo_user_inte"
  "rface_identifier_to_restore\030\004 \001(\r\0226\n.und"
  "o_next_user_interface_identifier_to_rest"
  "ore\030\005 \001(\r\"\303\002\n\036TextCommentReplyCommandArc"
  "hive\022\"\n\005super\030\001 \001(\0132\023.TSK.CommandArchive"
  "\022(\n\021storage_uuid_path\030\002 \001(\0132\r.TSP.UUIDPa"
  "th\022\027\n\017annotation_uuid\030\003 \001(\t\022\'\n\017forward_c"
  "omment\030\004 \001(\0132\016.TSP.Reference\022\'\n\017inverse_"
  "comment\030\005 \001(\0132\016.TSP.Reference\0223\n\017forward"
  "_variant\030\006 \001(\0162\032.TSD.CommentCommandVaria"
  "nt\0223\n\017inverse_variant\030\007 \001(\0162\032.TSD.Commen"
  "tCommandVariant\"\327\005\n\036ContainedObjectsComm"
  "andArchive\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandA"
  "rchive\022\036\n\006target\030\002 \002(\0132\016.TSP.Reference\022\037"
  "\n\007objects\030\003 \003(\0132\016.TSP.Reference\022.\n\026undo_"
  "object_for_commit\030\004 \001(\0132\016.TSP.Reference\022"
  "4\n\034undo_object_for_make_inverse\030\005 \001(\0132\016."
  "TSP.Reference\022O\n\021add_behavior_args\030\006 \001(\013"
  "24.TSWP.ContainedObjectsCommandArchive.A"
  "ddBehaviorArgs\022U\n\024remove_behavior_args\030\007"
  " \001(\01327.TSWP.ContainedObjectsCommandArchi"
  "ve.RemoveBehaviorArgs\022[\n\027rearrange_behav"
  "ior_args\030\010 \001(\0132:.TSWP.ContainedObjectsCo"
  "mmandArchive.RearrangeBehaviorArgs\022\026\n\016co"
  "ntainer_name\030\t \001(\t\032=\n\017AddBehaviorArgs\022*\n"
  "\targs_list\030\001 \003(\0132\027.TSK.AddIdOperationArg"
  "s\032C\n\022RemoveBehaviorArgs\022-\n\targs_list\030\001 \003"
  "(\0132\032.TSK.RemoveIdOperationArgs\032I\n\025Rearra"
  "ngeBehaviorArgs\0220\n\targs_list\030\001 \003(\0132\035.TSK"
  ".RearrangeIdOperationArgs\"Y\n\"EquationInf"
  "oGeometryCommandArchive\0223\n\005super\030\001 \001(\0132$"
  ".TSD.MediaInfoGeometryCommandArchive\"\256\002\n"
  ",CharacterStyleChangePropertyCommand_GAr"
  "chive\0220\n\005super\030\001 \002(\0132!.TSWP.StorageActio"
  "nCommandArchive\022\036\n\nrange_list\030\002 \003(\0132\n.TS"
  "P.Range\022\034\n\024range_list_undefined\030\003 \001(\010\022D\n"
  "\013change_list\030\004 \003(\0132/.TSWPSOS.CharacterSt"
  "ylePropertyChangeSetArchive\022\035\n\025change_li"
  "st_undefined\030\005 \001(\010\022)\n!disable_character_"
  "style_promotion\030\006 \002(\010\"\203\002\n,ParagraphStyle"
  "ChangePropertyCommand_GArchive\0220\n\005super\030"
  "\001 \002(\0132!.TSWP.StorageActionCommandArchive"
  "\022\036\n\nrange_list\030\002 \003(\0132\n.TSP.Range\022\034\n\024rang"
  "e_list_undefined\030\003 \001(\010\022D\n\013change_list\030\004 "
  "\003(\0132/.TSWPSOS.ParagraphStylePropertyChan"
  "geSetArchive\022\035\n\025change_list_undefined\030\005 "
  "\001(\010*\207\002\n\022ObjectPropertyType\022\033\n\027kObjectPro"
  "pertyTypeBool\020\000\022\034\n\030kObjectPropertyTypeFl"
  "oat\020\001\022\036\n\032kObjectPropertyTypeInteger\020\002\022\035\n"
  "\031kObjectPropertyTypeString\020\003\022\035\n\031kObjectP"
  "ropertyTypeIdPath\020\004\022\033\n\027kObjectPropertyTy"
  "peFill\020\005\022\034\n\030kObjectPropertyTypeColor\020\006\022\035"
  "\n\031kObjectPropertyTypeShadow\020\007"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_TSWPCommandArchives_2eproto_deps[7] = {
  &::descriptor_table_TSDArchives_2eproto,
  &::descriptor_table_TSDCommandArchives_2eproto,
  &::descriptor_table_TSKArchives_2eproto,
  &::descriptor_table_TSPMessages_2eproto,
  &::descriptor_table_TSSArchives_2eproto,
  &::descriptor_table_TSWPArchives_2eproto,
  &::descriptor_table_TSWPArchives_2esos_2eproto,
};
static ::_pbi::once_flag descriptor_table_TSWPCommandArchives_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_TSWPCommandArchives_2eproto = {
    false, false, 11709, descriptor_table_protodef_TSWPCommandArchives_2eproto,
    "TSWPCommandArchives.proto",
    &descriptor_table_TSWPCommandArchives_2eproto_once, descriptor_table_TSWPCommandArchives_2eproto_deps, 7, 47,
    schemas, file_default_instances, TableStruct_TSWPCommandArchives_2eproto::offsets,
    file_level_metadata_TSWPCommandArchives_2eproto, file_level_enum_descriptors_TSWPCommandArchives_2eproto,
    file_level_service_descriptors_TSWPCommandArchives_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_TSWPCommandArchives_2eproto_getter() {
  return &descriptor_table_TSWPCommandArchives_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_TSWPCommandArchives_2eproto(&descriptor_table_TSWPCommandArchives_2eproto);
namespace TSWP {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TextCommandArchive_Kind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSWPCommandArchives_2eproto);
  return file_level_enum_descriptors_TSWPCommandArchives_2eproto[0];
}
bool TextCommandArchive_Kind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TextCommandArchive_Kind TextCommandArchive::kKindContained;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindReplaceText;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindPaste;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindParagraphStyle;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindListStyle;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindIndentParagraphLevel;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindDragText;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindPasteStyle;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindApplyChangesInRange;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindInsertCitationField;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindInsertBibliographyEntry;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindFormatCitationFields;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindInsertTOCSmartField;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindInsertDateTimeField;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindUpdateDateTimeField;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindSetParagraphFirstTopicNumber;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindCharacterStyle;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindRevertStyles;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindSetParagraphBidi;
constexpr TextCommandArchive_Kind TextCommandArchive::Kind_MIN;
constexpr TextCommandArchive_Kind TextCommandArchive::Kind_MAX;
constexpr int TextCommandArchive::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StorageActionCommandArchive_Kind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSWPCommandArchives_2eproto);
  return file_level_enum_descriptors_TSWPCommandArchives_2eproto[1];
}
bool StorageActionCommandArchive_Kind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindContained;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindReplaceText;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindPaste;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindParagraphStyle;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindListStyle;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindIndentParagraphLevel;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindDragText;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindPasteStyle;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindApplyChangesInRange;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindInsertCitationField;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindInsertBibliographyEntry;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindFormatCitationFields;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindInsertTOCSmartField;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindInsertDateTimeField;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindUpdateDateTimeField;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindSetParagraphFirstTopicNumber;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindCharacterStyle;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindRevertStyles;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindSetParagraphBidi;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindFormatText;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindInsertAttachment;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindCreateHyperlink;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindModifyHyperlink;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindRemoveHyperlink;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindApplyHighlightText;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindPropagateStyleChanges;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindMovedAnchoredDrawableInline;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindMoveDrawablesAttached;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindMoveMoveDrawablesFloating;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindMoveInlineDrawableAnchored;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindAnchorAttachment;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindBookmark;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindReplaceSection;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindApplyPencilAnnotation;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindCreateRuby;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindModifyRuby;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindRemoveRuby;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindTateChuYoko;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindDropCapStyle;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindMergeField;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindModifyMergeField;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::kKindMergeFieldTypeReplace;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::Kind_MIN;
constexpr StorageActionCommandArchive_Kind StorageActionCommandArchive::Kind_MAX;
constexpr int StorageActionCommandArchive::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateFlowInfoCommandArchive_Mode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSWPCommandArchives_2eproto);
  return file_level_enum_descriptors_TSWPCommandArchives_2eproto[2];
}
bool UpdateFlowInfoCommandArchive_Mode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UpdateFlowInfoCommandArchive_Mode UpdateFlowInfoCommandArchive::kModeRearrange;
constexpr UpdateFlowInfoCommandArchive_Mode UpdateFlowInfoCommandArchive::kModeAdd;
constexpr UpdateFlowInfoCommandArchive_Mode UpdateFlowInfoCommandArchive::kModeRemove;
constexpr UpdateFlowInfoCommandArchive_Mode UpdateFlowInfoCommandArchive::kModeCompensate;
constexpr UpdateFlowInfoCommandArchive_Mode UpdateFlowInfoCommandArchive::Mode_MIN;
constexpr UpdateFlowInfoCommandArchive_Mode UpdateFlowInfoCommandArchive::Mode_MAX;
constexpr int UpdateFlowInfoCommandArchive::Mode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObjectPropertyType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSWPCommandArchives_2eproto);
  return file_level_enum_descriptors_TSWPCommandArchives_2eproto[3];
}
bool ObjectPropertyType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class DummyCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DummyCommandArchive>()._impl_._has_bits_);
  static void set_has_foo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

DummyCommandArchive::DummyCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.DummyCommandArchive)
}
DummyCommandArchive::DummyCommandArchive(const DummyCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DummyCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.foo_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.foo_ = from._impl_.foo_;
  // @@protoc_insertion_point(copy_constructor:TSWP.DummyCommandArchive)
}

inline void DummyCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.foo_){0u}
  };
}

DummyCommandArchive::~DummyCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.DummyCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DummyCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DummyCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DummyCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.DummyCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.foo_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DummyCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 foo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_foo(&has_bits);
          _impl_.foo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DummyCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.DummyCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 foo = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_foo(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.DummyCommandArchive)
  return target;
}

size_t DummyCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.DummyCommandArchive)
  size_t total_size = 0;

  // required uint32 foo = 1;
  if (_internal_has_foo()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_foo());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DummyCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DummyCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DummyCommandArchive::GetClassData() const { return &_class_data_; }


void DummyCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DummyCommandArchive*>(&to_msg);
  auto& from = static_cast<const DummyCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.DummyCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_foo()) {
    _this->_internal_set_foo(from._internal_foo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DummyCommandArchive::CopyFrom(const DummyCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.DummyCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DummyCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void DummyCommandArchive::InternalSwap(DummyCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.foo_, other->_impl_.foo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DummyCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[0]);
}

// ===================================================================

class TextCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<TextCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const TextCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const TextCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const TextCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_restore_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_restore_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_redo_restore_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_redo_restore_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_text_command_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::TSK::CommandArchive&
TextCommandArchive::_Internal::super(const TextCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
TextCommandArchive::_Internal::storage(const TextCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
TextCommandArchive::_Internal::undo_transaction(const TextCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void TextCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TextCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TextCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
TextCommandArchive::TextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.TextCommandArchive)
}
TextCommandArchive::TextCommandArchive(const TextCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TextCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.restore_range_location_){}
    , decltype(_impl_.restore_range_length_){}
    , decltype(_impl_.redo_restore_range_location_){}
    , decltype(_impl_.redo_restore_range_length_){}
    , decltype(_impl_.text_command_flags_){}
    , decltype(_impl_.kind_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.restore_range_location_, &from._impl_.restore_range_location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.kind_) -
    reinterpret_cast<char*>(&_impl_.restore_range_location_)) + sizeof(_impl_.kind_));
  // @@protoc_insertion_point(copy_constructor:TSWP.TextCommandArchive)
}

inline void TextCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.restore_range_location_){0u}
    , decltype(_impl_.restore_range_length_){0u}
    , decltype(_impl_.redo_restore_range_location_){0u}
    , decltype(_impl_.redo_restore_range_length_){0u}
    , decltype(_impl_.text_command_flags_){0u}
    , decltype(_impl_.kind_){0}
  };
}

TextCommandArchive::~TextCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.TextCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TextCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void TextCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TextCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.TextCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.restore_range_location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.text_command_flags_) -
        reinterpret_cast<char*>(&_impl_.restore_range_location_)) + sizeof(_impl_.text_command_flags_));
  }
  _impl_.kind_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TextCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 restore_range_location = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_restore_range_location(&has_bits);
          _impl_.restore_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 restore_range_length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_restore_range_length(&has_bits);
          _impl_.restore_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 redo_restore_range_location = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_redo_restore_range_location(&has_bits);
          _impl_.redo_restore_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 redo_restore_range_length = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_redo_restore_range_length(&has_bits);
          _impl_.redo_restore_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 text_command_flags = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_text_command_flags(&has_bits);
          _impl_.text_command_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.TextCommandArchive.Kind kind = 10 [default = kKindContained];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSWP::TextCommandArchive_Kind_IsValid(val))) {
            _internal_set_kind(static_cast<::TSWP::TextCommandArchive_Kind>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TextCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.TextCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  // optional uint32 restore_range_location = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_restore_range_location(), target);
  }

  // optional uint32 restore_range_length = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_restore_range_length(), target);
  }

  // optional uint32 redo_restore_range_location = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_redo_restore_range_location(), target);
  }

  // optional uint32 redo_restore_range_length = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_redo_restore_range_length(), target);
  }

  // optional uint32 text_command_flags = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_text_command_flags(), target);
  }

  // optional .TSWP.TextCommandArchive.Kind kind = 10 [default = kKindContained];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_kind(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.TextCommandArchive)
  return target;
}

size_t TextCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.TextCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 restore_range_location = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_restore_range_location());
    }

    // optional uint32 restore_range_length = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_restore_range_length());
    }

    // optional uint32 redo_restore_range_location = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redo_restore_range_location());
    }

    // optional uint32 redo_restore_range_length = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redo_restore_range_length());
    }

    // optional uint32 text_command_flags = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_text_command_flags());
    }

  }
  // optional .TSWP.TextCommandArchive.Kind kind = 10 [default = kKindContained];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TextCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TextCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TextCommandArchive::GetClassData() const { return &_class_data_; }


void TextCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TextCommandArchive*>(&to_msg);
  auto& from = static_cast<const TextCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.TextCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.restore_range_location_ = from._impl_.restore_range_location_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.restore_range_length_ = from._impl_.restore_range_length_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.redo_restore_range_location_ = from._impl_.redo_restore_range_location_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.redo_restore_range_length_ = from._impl_.redo_restore_range_length_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.text_command_flags_ = from._impl_.text_command_flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_kind(from._internal_kind());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TextCommandArchive::CopyFrom(const TextCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.TextCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void TextCommandArchive::InternalSwap(TextCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TextCommandArchive, _impl_.kind_)
      + sizeof(TextCommandArchive::_impl_.kind_)
      - PROTOBUF_FIELD_OFFSET(TextCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TextCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[1]);
}

// ===================================================================

class StorageActionCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StorageActionCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const StorageActionCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::UUIDPath& storage(const StorageActionCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const StorageActionCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_text_command_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_forward_inverse_command(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_coalesceable(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_coalescing_text(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_should_migrate_styles(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::TSK::DataReferenceRecord& changed_data_reference_record(const StorageActionCommandArchive* msg);
  static void set_has_changed_data_reference_record(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_coalescing_property(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_wp_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

const ::TSK::CommandArchive&
StorageActionCommandArchive::_Internal::super(const StorageActionCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::UUIDPath&
StorageActionCommandArchive::_Internal::storage(const StorageActionCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
StorageActionCommandArchive::_Internal::undo_transaction(const StorageActionCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
const ::TSK::DataReferenceRecord&
StorageActionCommandArchive::_Internal::changed_data_reference_record(const StorageActionCommandArchive* msg) {
  return *msg->_impl_.changed_data_reference_record_;
}
void StorageActionCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void StorageActionCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void StorageActionCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void StorageActionCommandArchive::clear_custom_format_keys() {
  _impl_.custom_format_keys_.Clear();
}
void StorageActionCommandArchive::clear_changed_data_reference_record() {
  if (_impl_.changed_data_reference_record_ != nullptr) _impl_.changed_data_reference_record_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
StorageActionCommandArchive::StorageActionCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.StorageActionCommandArchive)
}
StorageActionCommandArchive::StorageActionCommandArchive(const StorageActionCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StorageActionCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.custom_format_keys_){from._impl_.custom_format_keys_}
    , decltype(_impl_.coalescing_property_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.changed_data_reference_record_){nullptr}
    , decltype(_impl_.text_command_flags_){}
    , decltype(_impl_.kind_){}
    , decltype(_impl_.is_forward_inverse_command_){}
    , decltype(_impl_.coalesceable_){}
    , decltype(_impl_.coalescing_text_){}
    , decltype(_impl_.should_migrate_styles_){}
    , decltype(_impl_.wp_kind_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.coalescing_property_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.coalescing_property_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_coalescing_property()) {
    _this->_impl_.coalescing_property_.Set(from._internal_coalescing_property(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::UUIDPath(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  if (from._internal_has_changed_data_reference_record()) {
    _this->_impl_.changed_data_reference_record_ = new ::TSK::DataReferenceRecord(*from._impl_.changed_data_reference_record_);
  }
  ::memcpy(&_impl_.text_command_flags_, &from._impl_.text_command_flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.wp_kind_) -
    reinterpret_cast<char*>(&_impl_.text_command_flags_)) + sizeof(_impl_.wp_kind_));
  // @@protoc_insertion_point(copy_constructor:TSWP.StorageActionCommandArchive)
}

inline void StorageActionCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.custom_format_keys_){arena}
    , decltype(_impl_.coalescing_property_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.changed_data_reference_record_){nullptr}
    , decltype(_impl_.text_command_flags_){0u}
    , decltype(_impl_.kind_){0}
    , decltype(_impl_.is_forward_inverse_command_){false}
    , decltype(_impl_.coalesceable_){false}
    , decltype(_impl_.coalescing_text_){false}
    , decltype(_impl_.should_migrate_styles_){false}
    , decltype(_impl_.wp_kind_){0}
  };
  _impl_.coalescing_property_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.coalescing_property_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StorageActionCommandArchive::~StorageActionCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.StorageActionCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StorageActionCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.custom_format_keys_.~RepeatedPtrField();
  _impl_.coalescing_property_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
  if (this != internal_default_instance()) delete _impl_.changed_data_reference_record_;
}

void StorageActionCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StorageActionCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.StorageActionCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.custom_format_keys_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.coalescing_property_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.changed_data_reference_record_ != nullptr);
      _impl_.changed_data_reference_record_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.text_command_flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_forward_inverse_command_) -
        reinterpret_cast<char*>(&_impl_.text_command_flags_)) + sizeof(_impl_.is_forward_inverse_command_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.coalesceable_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.wp_kind_) -
        reinterpret_cast<char*>(&_impl_.coalesceable_)) + sizeof(_impl_.wp_kind_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StorageActionCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.UUIDPath storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 text_command_flags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_text_command_flags(&has_bits);
          _impl_.text_command_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.StorageActionCommandArchive.Kind kind = 5 [default = kKindContained];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSWP::StorageActionCommandArchive_Kind_IsValid(val))) {
            _internal_set_kind(static_cast<::TSWP::StorageActionCommandArchive_Kind>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.UUID custom_format_keys = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_custom_format_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool is_forward_inverse_command = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_is_forward_inverse_command(&has_bits);
          _impl_.is_forward_inverse_command_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool coalesceable = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_coalesceable(&has_bits);
          _impl_.coalesceable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool coalescing_text = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_coalescing_text(&has_bits);
          _impl_.coalescing_text_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool should_migrate_styles = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_should_migrate_styles(&has_bits);
          _impl_.should_migrate_styles_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSK.DataReferenceRecord changed_data_reference_record = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_changed_data_reference_record(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string coalescing_property = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_coalescing_property();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.StorageActionCommandArchive.coalescing_property");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.StorageArchive.KindType wp_kind = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSWP::StorageArchive_KindType_IsValid(val))) {
            _internal_set_wp_kind(static_cast<::TSWP::StorageArchive_KindType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(13, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StorageActionCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.StorageActionCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.UUIDPath storage = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  // optional uint32 text_command_flags = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_text_command_flags(), target);
  }

  // optional .TSWP.StorageActionCommandArchive.Kind kind = 5 [default = kKindContained];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_kind(), target);
  }

  // repeated .TSP.UUID custom_format_keys = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_custom_format_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_custom_format_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool is_forward_inverse_command = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_is_forward_inverse_command(), target);
  }

  // optional bool coalesceable = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_coalesceable(), target);
  }

  // optional bool coalescing_text = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_coalescing_text(), target);
  }

  // optional bool should_migrate_styles = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_should_migrate_styles(), target);
  }

  // optional .TSK.DataReferenceRecord changed_data_reference_record = 11;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::changed_data_reference_record(this),
        _Internal::changed_data_reference_record(this).GetCachedSize(), target, stream);
  }

  // optional string coalescing_property = 12;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_coalescing_property().data(), static_cast<int>(this->_internal_coalescing_property().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.StorageActionCommandArchive.coalescing_property");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_coalescing_property(), target);
  }

  // optional .TSWP.StorageArchive.KindType wp_kind = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      13, this->_internal_wp_kind(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.StorageActionCommandArchive)
  return target;
}

size_t StorageActionCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.StorageActionCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.UUID custom_format_keys = 6;
  total_size += 1UL * this->_internal_custom_format_keys_size();
  for (const auto& msg : this->_impl_.custom_format_keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string coalescing_property = 12;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_coalescing_property());
    }

    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.UUIDPath storage = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional .TSK.DataReferenceRecord changed_data_reference_record = 11;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.changed_data_reference_record_);
    }

    // optional uint32 text_command_flags = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_text_command_flags());
    }

    // optional .TSWP.StorageActionCommandArchive.Kind kind = 5 [default = kKindContained];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());
    }

    // optional bool is_forward_inverse_command = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional bool coalesceable = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool coalescing_text = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool should_migrate_styles = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional .TSWP.StorageArchive.KindType wp_kind = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_wp_kind());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StorageActionCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StorageActionCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StorageActionCommandArchive::GetClassData() const { return &_class_data_; }


void StorageActionCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StorageActionCommandArchive*>(&to_msg);
  auto& from = static_cast<const StorageActionCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.StorageActionCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.custom_format_keys_.MergeFrom(from._impl_.custom_format_keys_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_coalescing_property(from._internal_coalescing_property());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_storage()->::TSP::UUIDPath::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_changed_data_reference_record()->::TSK::DataReferenceRecord::MergeFrom(
          from._internal_changed_data_reference_record());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.text_command_flags_ = from._impl_.text_command_flags_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.kind_ = from._impl_.kind_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.is_forward_inverse_command_ = from._impl_.is_forward_inverse_command_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.coalesceable_ = from._impl_.coalesceable_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.coalescing_text_ = from._impl_.coalescing_text_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.should_migrate_styles_ = from._impl_.should_migrate_styles_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.wp_kind_ = from._impl_.wp_kind_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StorageActionCommandArchive::CopyFrom(const StorageActionCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.StorageActionCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StorageActionCommandArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.custom_format_keys_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  if (_internal_has_changed_data_reference_record()) {
    if (!_impl_.changed_data_reference_record_->IsInitialized()) return false;
  }
  return true;
}

void StorageActionCommandArchive::InternalSwap(StorageActionCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.custom_format_keys_.InternalSwap(&other->_impl_.custom_format_keys_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.coalescing_property_, lhs_arena,
      &other->_impl_.coalescing_property_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StorageActionCommandArchive, _impl_.wp_kind_)
      + sizeof(StorageActionCommandArchive::_impl_.wp_kind_)
      - PROTOBUF_FIELD_OFFSET(StorageActionCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StorageActionCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[2]);
}

// ===================================================================

class SetColumnStyleCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SetColumnStyleCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const SetColumnStyleCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const SetColumnStyleCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const SetColumnStyleCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
SetColumnStyleCommandArchive::_Internal::super(const SetColumnStyleCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
SetColumnStyleCommandArchive::_Internal::storage(const SetColumnStyleCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
SetColumnStyleCommandArchive::_Internal::undo_transaction(const SetColumnStyleCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void SetColumnStyleCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void SetColumnStyleCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void SetColumnStyleCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
SetColumnStyleCommandArchive::SetColumnStyleCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.SetColumnStyleCommandArchive)
}
SetColumnStyleCommandArchive::SetColumnStyleCommandArchive(const SetColumnStyleCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetColumnStyleCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.SetColumnStyleCommandArchive)
}

inline void SetColumnStyleCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
  };
}

SetColumnStyleCommandArchive::~SetColumnStyleCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.SetColumnStyleCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetColumnStyleCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void SetColumnStyleCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetColumnStyleCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.SetColumnStyleCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetColumnStyleCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetColumnStyleCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.SetColumnStyleCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.SetColumnStyleCommandArchive)
  return target;
}

size_t SetColumnStyleCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.SetColumnStyleCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetColumnStyleCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetColumnStyleCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetColumnStyleCommandArchive::GetClassData() const { return &_class_data_; }


void SetColumnStyleCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetColumnStyleCommandArchive*>(&to_msg);
  auto& from = static_cast<const SetColumnStyleCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.SetColumnStyleCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetColumnStyleCommandArchive::CopyFrom(const SetColumnStyleCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.SetColumnStyleCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetColumnStyleCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void SetColumnStyleCommandArchive::InternalSwap(SetColumnStyleCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetColumnStyleCommandArchive, _impl_.undo_transaction_)
      + sizeof(SetColumnStyleCommandArchive::_impl_.undo_transaction_)
      - PROTOBUF_FIELD_OFFSET(SetColumnStyleCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetColumnStyleCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[3]);
}

// ===================================================================

class ReplaceAllUsesOfStyleCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ReplaceAllUsesOfStyleCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ReplaceAllUsesOfStyleCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const ReplaceAllUsesOfStyleCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const ReplaceAllUsesOfStyleCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
ReplaceAllUsesOfStyleCommandArchive::_Internal::super(const ReplaceAllUsesOfStyleCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ReplaceAllUsesOfStyleCommandArchive::_Internal::storage(const ReplaceAllUsesOfStyleCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
ReplaceAllUsesOfStyleCommandArchive::_Internal::undo_transaction(const ReplaceAllUsesOfStyleCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void ReplaceAllUsesOfStyleCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ReplaceAllUsesOfStyleCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ReplaceAllUsesOfStyleCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
ReplaceAllUsesOfStyleCommandArchive::ReplaceAllUsesOfStyleCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ReplaceAllUsesOfStyleCommandArchive)
}
ReplaceAllUsesOfStyleCommandArchive::ReplaceAllUsesOfStyleCommandArchive(const ReplaceAllUsesOfStyleCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReplaceAllUsesOfStyleCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.ReplaceAllUsesOfStyleCommandArchive)
}

inline void ReplaceAllUsesOfStyleCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
  };
}

ReplaceAllUsesOfStyleCommandArchive::~ReplaceAllUsesOfStyleCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ReplaceAllUsesOfStyleCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReplaceAllUsesOfStyleCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void ReplaceAllUsesOfStyleCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReplaceAllUsesOfStyleCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ReplaceAllUsesOfStyleCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReplaceAllUsesOfStyleCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReplaceAllUsesOfStyleCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ReplaceAllUsesOfStyleCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ReplaceAllUsesOfStyleCommandArchive)
  return target;
}

size_t ReplaceAllUsesOfStyleCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ReplaceAllUsesOfStyleCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReplaceAllUsesOfStyleCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReplaceAllUsesOfStyleCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReplaceAllUsesOfStyleCommandArchive::GetClassData() const { return &_class_data_; }


void ReplaceAllUsesOfStyleCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReplaceAllUsesOfStyleCommandArchive*>(&to_msg);
  auto& from = static_cast<const ReplaceAllUsesOfStyleCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ReplaceAllUsesOfStyleCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReplaceAllUsesOfStyleCommandArchive::CopyFrom(const ReplaceAllUsesOfStyleCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ReplaceAllUsesOfStyleCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplaceAllUsesOfStyleCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void ReplaceAllUsesOfStyleCommandArchive::InternalSwap(ReplaceAllUsesOfStyleCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReplaceAllUsesOfStyleCommandArchive, _impl_.undo_transaction_)
      + sizeof(ReplaceAllUsesOfStyleCommandArchive::_impl_.undo_transaction_)
      - PROTOBUF_FIELD_OFFSET(ReplaceAllUsesOfStyleCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReplaceAllUsesOfStyleCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[4]);
}

// ===================================================================

class InsertColumnsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<InsertColumnsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const InsertColumnsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const InsertColumnsCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_column_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_column_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const InsertColumnsCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
InsertColumnsCommandArchive::_Internal::super(const InsertColumnsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
InsertColumnsCommandArchive::_Internal::storage(const InsertColumnsCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
InsertColumnsCommandArchive::_Internal::undo_transaction(const InsertColumnsCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void InsertColumnsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void InsertColumnsCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void InsertColumnsCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
InsertColumnsCommandArchive::InsertColumnsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.InsertColumnsCommandArchive)
}
InsertColumnsCommandArchive::InsertColumnsCommandArchive(const InsertColumnsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertColumnsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.column_index_){}
    , decltype(_impl_.column_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.column_index_, &from._impl_.column_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.column_count_) -
    reinterpret_cast<char*>(&_impl_.column_index_)) + sizeof(_impl_.column_count_));
  // @@protoc_insertion_point(copy_constructor:TSWP.InsertColumnsCommandArchive)
}

inline void InsertColumnsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.column_index_){0u}
    , decltype(_impl_.column_count_){0u}
  };
}

InsertColumnsCommandArchive::~InsertColumnsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.InsertColumnsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertColumnsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void InsertColumnsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertColumnsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.InsertColumnsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.column_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.column_count_) -
        reinterpret_cast<char*>(&_impl_.column_index_)) + sizeof(_impl_.column_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertColumnsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 column_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_column_index(&has_bits);
          _impl_.column_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 column_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_column_count(&has_bits);
          _impl_.column_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertColumnsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.InsertColumnsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 column_index = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_column_index(), target);
  }

  // optional uint32 column_count = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_column_count(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.InsertColumnsCommandArchive)
  return target;
}

size_t InsertColumnsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.InsertColumnsCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 column_index = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column_index());
    }

    // optional uint32 column_count = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertColumnsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertColumnsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertColumnsCommandArchive::GetClassData() const { return &_class_data_; }


void InsertColumnsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertColumnsCommandArchive*>(&to_msg);
  auto& from = static_cast<const InsertColumnsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.InsertColumnsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.column_index_ = from._impl_.column_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.column_count_ = from._impl_.column_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertColumnsCommandArchive::CopyFrom(const InsertColumnsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.InsertColumnsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertColumnsCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void InsertColumnsCommandArchive::InternalSwap(InsertColumnsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InsertColumnsCommandArchive, _impl_.column_count_)
      + sizeof(InsertColumnsCommandArchive::_impl_.column_count_)
      - PROTOBUF_FIELD_OFFSET(InsertColumnsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertColumnsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[5]);
}

// ===================================================================

class InsertRowsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<InsertRowsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const InsertRowsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const InsertRowsCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_row_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_row_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const InsertRowsCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
InsertRowsCommandArchive::_Internal::super(const InsertRowsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
InsertRowsCommandArchive::_Internal::storage(const InsertRowsCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
InsertRowsCommandArchive::_Internal::undo_transaction(const InsertRowsCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void InsertRowsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void InsertRowsCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void InsertRowsCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
InsertRowsCommandArchive::InsertRowsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.InsertRowsCommandArchive)
}
InsertRowsCommandArchive::InsertRowsCommandArchive(const InsertRowsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertRowsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.row_index_){}
    , decltype(_impl_.row_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.row_index_, &from._impl_.row_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.row_count_) -
    reinterpret_cast<char*>(&_impl_.row_index_)) + sizeof(_impl_.row_count_));
  // @@protoc_insertion_point(copy_constructor:TSWP.InsertRowsCommandArchive)
}

inline void InsertRowsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.row_index_){0u}
    , decltype(_impl_.row_count_){0u}
  };
}

InsertRowsCommandArchive::~InsertRowsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.InsertRowsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertRowsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void InsertRowsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertRowsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.InsertRowsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.row_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.row_count_) -
        reinterpret_cast<char*>(&_impl_.row_index_)) + sizeof(_impl_.row_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertRowsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 row_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_row_index(&has_bits);
          _impl_.row_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 row_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_row_count(&has_bits);
          _impl_.row_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertRowsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.InsertRowsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 row_index = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_row_index(), target);
  }

  // optional uint32 row_count = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_row_count(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.InsertRowsCommandArchive)
  return target;
}

size_t InsertRowsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.InsertRowsCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 row_index = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_row_index());
    }

    // optional uint32 row_count = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_row_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertRowsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertRowsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertRowsCommandArchive::GetClassData() const { return &_class_data_; }


void InsertRowsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertRowsCommandArchive*>(&to_msg);
  auto& from = static_cast<const InsertRowsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.InsertRowsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.row_index_ = from._impl_.row_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.row_count_ = from._impl_.row_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertRowsCommandArchive::CopyFrom(const InsertRowsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.InsertRowsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertRowsCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void InsertRowsCommandArchive::InternalSwap(InsertRowsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InsertRowsCommandArchive, _impl_.row_count_)
      + sizeof(InsertRowsCommandArchive::_impl_.row_count_)
      - PROTOBUF_FIELD_OFFSET(InsertRowsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertRowsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[6]);
}

// ===================================================================

class RemoveColumnsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoveColumnsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const RemoveColumnsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const RemoveColumnsCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_column_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_column_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const RemoveColumnsCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
RemoveColumnsCommandArchive::_Internal::super(const RemoveColumnsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
RemoveColumnsCommandArchive::_Internal::storage(const RemoveColumnsCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
RemoveColumnsCommandArchive::_Internal::undo_transaction(const RemoveColumnsCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void RemoveColumnsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RemoveColumnsCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RemoveColumnsCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
RemoveColumnsCommandArchive::RemoveColumnsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.RemoveColumnsCommandArchive)
}
RemoveColumnsCommandArchive::RemoveColumnsCommandArchive(const RemoveColumnsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemoveColumnsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.column_index_){}
    , decltype(_impl_.column_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.column_index_, &from._impl_.column_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.column_count_) -
    reinterpret_cast<char*>(&_impl_.column_index_)) + sizeof(_impl_.column_count_));
  // @@protoc_insertion_point(copy_constructor:TSWP.RemoveColumnsCommandArchive)
}

inline void RemoveColumnsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.column_index_){0u}
    , decltype(_impl_.column_count_){0u}
  };
}

RemoveColumnsCommandArchive::~RemoveColumnsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.RemoveColumnsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoveColumnsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void RemoveColumnsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoveColumnsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.RemoveColumnsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.column_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.column_count_) -
        reinterpret_cast<char*>(&_impl_.column_index_)) + sizeof(_impl_.column_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoveColumnsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 column_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_column_index(&has_bits);
          _impl_.column_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 column_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_column_count(&has_bits);
          _impl_.column_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoveColumnsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.RemoveColumnsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 column_index = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_column_index(), target);
  }

  // optional uint32 column_count = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_column_count(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.RemoveColumnsCommandArchive)
  return target;
}

size_t RemoveColumnsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.RemoveColumnsCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 column_index = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column_index());
    }

    // optional uint32 column_count = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoveColumnsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemoveColumnsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoveColumnsCommandArchive::GetClassData() const { return &_class_data_; }


void RemoveColumnsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemoveColumnsCommandArchive*>(&to_msg);
  auto& from = static_cast<const RemoveColumnsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.RemoveColumnsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.column_index_ = from._impl_.column_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.column_count_ = from._impl_.column_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoveColumnsCommandArchive::CopyFrom(const RemoveColumnsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.RemoveColumnsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveColumnsCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void RemoveColumnsCommandArchive::InternalSwap(RemoveColumnsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoveColumnsCommandArchive, _impl_.column_count_)
      + sizeof(RemoveColumnsCommandArchive::_impl_.column_count_)
      - PROTOBUF_FIELD_OFFSET(RemoveColumnsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoveColumnsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[7]);
}

// ===================================================================

class RemoveRowsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoveRowsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const RemoveRowsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const RemoveRowsCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_row_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_row_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const RemoveRowsCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
RemoveRowsCommandArchive::_Internal::super(const RemoveRowsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
RemoveRowsCommandArchive::_Internal::storage(const RemoveRowsCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
RemoveRowsCommandArchive::_Internal::undo_transaction(const RemoveRowsCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void RemoveRowsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RemoveRowsCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RemoveRowsCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
RemoveRowsCommandArchive::RemoveRowsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.RemoveRowsCommandArchive)
}
RemoveRowsCommandArchive::RemoveRowsCommandArchive(const RemoveRowsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemoveRowsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.row_index_){}
    , decltype(_impl_.row_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.row_index_, &from._impl_.row_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.row_count_) -
    reinterpret_cast<char*>(&_impl_.row_index_)) + sizeof(_impl_.row_count_));
  // @@protoc_insertion_point(copy_constructor:TSWP.RemoveRowsCommandArchive)
}

inline void RemoveRowsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.row_index_){0u}
    , decltype(_impl_.row_count_){0u}
  };
}

RemoveRowsCommandArchive::~RemoveRowsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.RemoveRowsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoveRowsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void RemoveRowsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoveRowsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.RemoveRowsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.row_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.row_count_) -
        reinterpret_cast<char*>(&_impl_.row_index_)) + sizeof(_impl_.row_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoveRowsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 row_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_row_index(&has_bits);
          _impl_.row_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 row_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_row_count(&has_bits);
          _impl_.row_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoveRowsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.RemoveRowsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 row_index = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_row_index(), target);
  }

  // optional uint32 row_count = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_row_count(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.RemoveRowsCommandArchive)
  return target;
}

size_t RemoveRowsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.RemoveRowsCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 row_index = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_row_index());
    }

    // optional uint32 row_count = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_row_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoveRowsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemoveRowsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoveRowsCommandArchive::GetClassData() const { return &_class_data_; }


void RemoveRowsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemoveRowsCommandArchive*>(&to_msg);
  auto& from = static_cast<const RemoveRowsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.RemoveRowsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.row_index_ = from._impl_.row_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.row_count_ = from._impl_.row_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoveRowsCommandArchive::CopyFrom(const RemoveRowsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.RemoveRowsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveRowsCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void RemoveRowsCommandArchive::InternalSwap(RemoveRowsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoveRowsCommandArchive, _impl_.row_count_)
      + sizeof(RemoveRowsCommandArchive::_impl_.row_count_)
      - PROTOBUF_FIELD_OFFSET(RemoveRowsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoveRowsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[8]);
}

// ===================================================================

class MergeCellsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MergeCellsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const MergeCellsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const MergeCellsCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_row(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_column(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_row_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_column_count(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const MergeCellsCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
MergeCellsCommandArchive::_Internal::super(const MergeCellsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
MergeCellsCommandArchive::_Internal::storage(const MergeCellsCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
MergeCellsCommandArchive::_Internal::undo_transaction(const MergeCellsCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void MergeCellsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MergeCellsCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MergeCellsCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
MergeCellsCommandArchive::MergeCellsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.MergeCellsCommandArchive)
}
MergeCellsCommandArchive::MergeCellsCommandArchive(const MergeCellsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MergeCellsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.row_){}
    , decltype(_impl_.column_){}
    , decltype(_impl_.row_count_){}
    , decltype(_impl_.column_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.row_, &from._impl_.row_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.column_count_) -
    reinterpret_cast<char*>(&_impl_.row_)) + sizeof(_impl_.column_count_));
  // @@protoc_insertion_point(copy_constructor:TSWP.MergeCellsCommandArchive)
}

inline void MergeCellsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.row_){0u}
    , decltype(_impl_.column_){0u}
    , decltype(_impl_.row_count_){0u}
    , decltype(_impl_.column_count_){0u}
  };
}

MergeCellsCommandArchive::~MergeCellsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.MergeCellsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MergeCellsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void MergeCellsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MergeCellsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.MergeCellsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&_impl_.row_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.column_count_) -
        reinterpret_cast<char*>(&_impl_.row_)) + sizeof(_impl_.column_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MergeCellsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 row = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_row(&has_bits);
          _impl_.row_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 column = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_column(&has_bits);
          _impl_.column_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 row_count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_row_count(&has_bits);
          _impl_.row_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 column_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_column_count(&has_bits);
          _impl_.column_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MergeCellsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.MergeCellsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 row = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_row(), target);
  }

  // optional uint32 column = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_column(), target);
  }

  // optional uint32 row_count = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_row_count(), target);
  }

  // optional uint32 column_count = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_column_count(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.MergeCellsCommandArchive)
  return target;
}

size_t MergeCellsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.MergeCellsCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 row = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_row());
    }

    // optional uint32 column = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column());
    }

    // optional uint32 row_count = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_row_count());
    }

    // optional uint32 column_count = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MergeCellsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MergeCellsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MergeCellsCommandArchive::GetClassData() const { return &_class_data_; }


void MergeCellsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MergeCellsCommandArchive*>(&to_msg);
  auto& from = static_cast<const MergeCellsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.MergeCellsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.row_ = from._impl_.row_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.column_ = from._impl_.column_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.row_count_ = from._impl_.row_count_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.column_count_ = from._impl_.column_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MergeCellsCommandArchive::CopyFrom(const MergeCellsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.MergeCellsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MergeCellsCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void MergeCellsCommandArchive::InternalSwap(MergeCellsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MergeCellsCommandArchive, _impl_.column_count_)
      + sizeof(MergeCellsCommandArchive::_impl_.column_count_)
      - PROTOBUF_FIELD_OFFSET(MergeCellsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MergeCellsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[9]);
}

// ===================================================================

class ApplyPlaceholderTextCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ApplyPlaceholderTextCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ApplyPlaceholderTextCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& storage(const ApplyPlaceholderTextCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_selection_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_selection_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const ApplyPlaceholderTextCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_script_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSK::CommandArchive&
ApplyPlaceholderTextCommandArchive::_Internal::super(const ApplyPlaceholderTextCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ApplyPlaceholderTextCommandArchive::_Internal::storage(const ApplyPlaceholderTextCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
ApplyPlaceholderTextCommandArchive::_Internal::undo_transaction(const ApplyPlaceholderTextCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void ApplyPlaceholderTextCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ApplyPlaceholderTextCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ApplyPlaceholderTextCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
ApplyPlaceholderTextCommandArchive::ApplyPlaceholderTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ApplyPlaceholderTextCommandArchive)
}
ApplyPlaceholderTextCommandArchive::ApplyPlaceholderTextCommandArchive(const ApplyPlaceholderTextCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApplyPlaceholderTextCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.script_tag_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){}
    , decltype(_impl_.selection_range_length_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.script_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.script_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_script_tag()) {
    _this->_impl_.script_tag_.Set(from._internal_script_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.selection_range_location_, &from._impl_.selection_range_location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.selection_range_length_) -
    reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.selection_range_length_));
  // @@protoc_insertion_point(copy_constructor:TSWP.ApplyPlaceholderTextCommandArchive)
}

inline void ApplyPlaceholderTextCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.script_tag_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){0u}
    , decltype(_impl_.selection_range_length_){0u}
  };
  _impl_.script_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.script_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ApplyPlaceholderTextCommandArchive::~ApplyPlaceholderTextCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ApplyPlaceholderTextCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApplyPlaceholderTextCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.script_tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void ApplyPlaceholderTextCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApplyPlaceholderTextCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ApplyPlaceholderTextCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.script_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_.selection_range_location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.selection_range_length_) -
        reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.selection_range_length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplyPlaceholderTextCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_location = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_selection_range_location(&has_bits);
          _impl_.selection_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_selection_range_length(&has_bits);
          _impl_.selection_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string script_tag = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_script_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.ApplyPlaceholderTextCommandArchive.script_tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApplyPlaceholderTextCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ApplyPlaceholderTextCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 selection_range_location = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_selection_range_location(), target);
  }

  // optional uint32 selection_range_length = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_selection_range_length(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  // optional string script_tag = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_script_tag().data(), static_cast<int>(this->_internal_script_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.ApplyPlaceholderTextCommandArchive.script_tag");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_script_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ApplyPlaceholderTextCommandArchive)
  return target;
}

size_t ApplyPlaceholderTextCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ApplyPlaceholderTextCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string script_tag = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_script_tag());
    }

    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 selection_range_location = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_location());
    }

    // optional uint32 selection_range_length = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_length());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApplyPlaceholderTextCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApplyPlaceholderTextCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApplyPlaceholderTextCommandArchive::GetClassData() const { return &_class_data_; }


void ApplyPlaceholderTextCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApplyPlaceholderTextCommandArchive*>(&to_msg);
  auto& from = static_cast<const ApplyPlaceholderTextCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ApplyPlaceholderTextCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_script_tag(from._internal_script_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.selection_range_location_ = from._impl_.selection_range_location_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.selection_range_length_ = from._impl_.selection_range_length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApplyPlaceholderTextCommandArchive::CopyFrom(const ApplyPlaceholderTextCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ApplyPlaceholderTextCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyPlaceholderTextCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void ApplyPlaceholderTextCommandArchive::InternalSwap(ApplyPlaceholderTextCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.script_tag_, lhs_arena,
      &other->_impl_.script_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ApplyPlaceholderTextCommandArchive, _impl_.selection_range_length_)
      + sizeof(ApplyPlaceholderTextCommandArchive::_impl_.selection_range_length_)
      - PROTOBUF_FIELD_OFFSET(ApplyPlaceholderTextCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplyPlaceholderTextCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[10]);
}

// ===================================================================

class UpdateDateTimeFieldCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<UpdateDateTimeFieldCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::TextCommandArchive& super(const UpdateDateTimeFieldCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& date_time_field(const UpdateDateTimeFieldCommandArchive* msg);
  static void set_has_date_time_field(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Date& date(const UpdateDateTimeFieldCommandArchive* msg);
  static void set_has_date(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_date_style(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_time_style(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::TSWP::TextCommandArchive&
UpdateDateTimeFieldCommandArchive::_Internal::super(const UpdateDateTimeFieldCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
UpdateDateTimeFieldCommandArchive::_Internal::date_time_field(const UpdateDateTimeFieldCommandArchive* msg) {
  return *msg->_impl_.date_time_field_;
}
const ::TSP::Date&
UpdateDateTimeFieldCommandArchive::_Internal::date(const UpdateDateTimeFieldCommandArchive* msg) {
  return *msg->_impl_.date_;
}
void UpdateDateTimeFieldCommandArchive::clear_date_time_field() {
  if (_impl_.date_time_field_ != nullptr) _impl_.date_time_field_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void UpdateDateTimeFieldCommandArchive::clear_date() {
  if (_impl_.date_ != nullptr) _impl_.date_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
UpdateDateTimeFieldCommandArchive::UpdateDateTimeFieldCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.UpdateDateTimeFieldCommandArchive)
}
UpdateDateTimeFieldCommandArchive::UpdateDateTimeFieldCommandArchive(const UpdateDateTimeFieldCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateDateTimeFieldCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.date_time_field_){nullptr}
    , decltype(_impl_.date_){nullptr}
    , decltype(_impl_.date_style_){}
    , decltype(_impl_.time_style_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::TextCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_date_time_field()) {
    _this->_impl_.date_time_field_ = new ::TSP::Reference(*from._impl_.date_time_field_);
  }
  if (from._internal_has_date()) {
    _this->_impl_.date_ = new ::TSP::Date(*from._impl_.date_);
  }
  ::memcpy(&_impl_.date_style_, &from._impl_.date_style_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.time_style_) -
    reinterpret_cast<char*>(&_impl_.date_style_)) + sizeof(_impl_.time_style_));
  // @@protoc_insertion_point(copy_constructor:TSWP.UpdateDateTimeFieldCommandArchive)
}

inline void UpdateDateTimeFieldCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.date_time_field_){nullptr}
    , decltype(_impl_.date_){nullptr}
    , decltype(_impl_.date_style_){0}
    , decltype(_impl_.time_style_){0}
  };
}

UpdateDateTimeFieldCommandArchive::~UpdateDateTimeFieldCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.UpdateDateTimeFieldCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateDateTimeFieldCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.date_time_field_;
  if (this != internal_default_instance()) delete _impl_.date_;
}

void UpdateDateTimeFieldCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateDateTimeFieldCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.UpdateDateTimeFieldCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.date_time_field_ != nullptr);
      _impl_.date_time_field_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.date_ != nullptr);
      _impl_.date_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.date_style_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.time_style_) -
        reinterpret_cast<char*>(&_impl_.date_style_)) + sizeof(_impl_.time_style_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateDateTimeFieldCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.TextCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference date_time_field = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_date_time_field(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Date date = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_date(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle date_style = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle_IsValid(val))) {
            _internal_set_date_style(static_cast<::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle time_style = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle_IsValid(val))) {
            _internal_set_time_style(static_cast<::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateDateTimeFieldCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.UpdateDateTimeFieldCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.TextCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference date_time_field = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::date_time_field(this),
        _Internal::date_time_field(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Date date = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::date(this),
        _Internal::date(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle date_style = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_date_style(), target);
  }

  // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle time_style = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_time_style(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.UpdateDateTimeFieldCommandArchive)
  return target;
}

size_t UpdateDateTimeFieldCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.UpdateDateTimeFieldCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSWP.TextCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference date_time_field = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.date_time_field_);
    }

    // optional .TSP.Date date = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.date_);
    }

    // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle date_style = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_date_style());
    }

    // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle time_style = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_time_style());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateDateTimeFieldCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateDateTimeFieldCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateDateTimeFieldCommandArchive::GetClassData() const { return &_class_data_; }


void UpdateDateTimeFieldCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateDateTimeFieldCommandArchive*>(&to_msg);
  auto& from = static_cast<const UpdateDateTimeFieldCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.UpdateDateTimeFieldCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::TextCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_date_time_field()->::TSP::Reference::MergeFrom(
          from._internal_date_time_field());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_date()->::TSP::Date::MergeFrom(
          from._internal_date());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.date_style_ = from._impl_.date_style_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.time_style_ = from._impl_.time_style_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateDateTimeFieldCommandArchive::CopyFrom(const UpdateDateTimeFieldCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.UpdateDateTimeFieldCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateDateTimeFieldCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_date_time_field()) {
    if (!_impl_.date_time_field_->IsInitialized()) return false;
  }
  if (_internal_has_date()) {
    if (!_impl_.date_->IsInitialized()) return false;
  }
  return true;
}

void UpdateDateTimeFieldCommandArchive::InternalSwap(UpdateDateTimeFieldCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateDateTimeFieldCommandArchive, _impl_.time_style_)
      + sizeof(UpdateDateTimeFieldCommandArchive::_impl_.time_style_)
      - PROTOBUF_FIELD_OFFSET(UpdateDateTimeFieldCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateDateTimeFieldCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[11]);
}

// ===================================================================

class ApplyRubyTextCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ApplyRubyTextCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ApplyRubyTextCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& storage(const ApplyRubyTextCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_selection_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_selection_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ruby_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const ApplyRubyTextCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::TSK::CommandArchive&
ApplyRubyTextCommandArchive::_Internal::super(const ApplyRubyTextCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ApplyRubyTextCommandArchive::_Internal::storage(const ApplyRubyTextCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
ApplyRubyTextCommandArchive::_Internal::undo_transaction(const ApplyRubyTextCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void ApplyRubyTextCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ApplyRubyTextCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ApplyRubyTextCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
ApplyRubyTextCommandArchive::ApplyRubyTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ApplyRubyTextCommandArchive)
}
ApplyRubyTextCommandArchive::ApplyRubyTextCommandArchive(const ApplyRubyTextCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApplyRubyTextCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ruby_text_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){}
    , decltype(_impl_.selection_range_length_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ruby_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ruby_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ruby_text()) {
    _this->_impl_.ruby_text_.Set(from._internal_ruby_text(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.selection_range_location_, &from._impl_.selection_range_location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.selection_range_length_) -
    reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.selection_range_length_));
  // @@protoc_insertion_point(copy_constructor:TSWP.ApplyRubyTextCommandArchive)
}

inline void ApplyRubyTextCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ruby_text_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){0u}
    , decltype(_impl_.selection_range_length_){0u}
  };
  _impl_.ruby_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ruby_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ApplyRubyTextCommandArchive::~ApplyRubyTextCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ApplyRubyTextCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApplyRubyTextCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ruby_text_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void ApplyRubyTextCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApplyRubyTextCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ApplyRubyTextCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ruby_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_.selection_range_location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.selection_range_length_) -
        reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.selection_range_length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplyRubyTextCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_location = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_selection_range_location(&has_bits);
          _impl_.selection_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_selection_range_length(&has_bits);
          _impl_.selection_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ruby_text = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_ruby_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.ApplyRubyTextCommandArchive.ruby_text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApplyRubyTextCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ApplyRubyTextCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 selection_range_location = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_selection_range_location(), target);
  }

  // optional uint32 selection_range_length = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_selection_range_length(), target);
  }

  // optional string ruby_text = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ruby_text().data(), static_cast<int>(this->_internal_ruby_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.ApplyRubyTextCommandArchive.ruby_text");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_ruby_text(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ApplyRubyTextCommandArchive)
  return target;
}

size_t ApplyRubyTextCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ApplyRubyTextCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string ruby_text = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ruby_text());
    }

    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 selection_range_location = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_location());
    }

    // optional uint32 selection_range_length = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_length());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApplyRubyTextCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApplyRubyTextCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApplyRubyTextCommandArchive::GetClassData() const { return &_class_data_; }


void ApplyRubyTextCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApplyRubyTextCommandArchive*>(&to_msg);
  auto& from = static_cast<const ApplyRubyTextCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ApplyRubyTextCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ruby_text(from._internal_ruby_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.selection_range_location_ = from._impl_.selection_range_location_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.selection_range_length_ = from._impl_.selection_range_length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApplyRubyTextCommandArchive::CopyFrom(const ApplyRubyTextCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ApplyRubyTextCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyRubyTextCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void ApplyRubyTextCommandArchive::InternalSwap(ApplyRubyTextCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ruby_text_, lhs_arena,
      &other->_impl_.ruby_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ApplyRubyTextCommandArchive, _impl_.selection_range_length_)
      + sizeof(ApplyRubyTextCommandArchive::_impl_.selection_range_length_)
      - PROTOBUF_FIELD_OFFSET(ApplyRubyTextCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplyRubyTextCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[12]);
}

// ===================================================================

class ModifyRubyTextCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ModifyRubyTextCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ModifyRubyTextCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& ruby_field(const ModifyRubyTextCommandArchive* msg);
  static void set_has_ruby_field(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ruby_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_base_text(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const ModifyRubyTextCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::TSK::CommandArchive&
ModifyRubyTextCommandArchive::_Internal::super(const ModifyRubyTextCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ModifyRubyTextCommandArchive::_Internal::ruby_field(const ModifyRubyTextCommandArchive* msg) {
  return *msg->_impl_.ruby_field_;
}
const ::TSWP::UndoTransaction&
ModifyRubyTextCommandArchive::_Internal::undo_transaction(const ModifyRubyTextCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void ModifyRubyTextCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ModifyRubyTextCommandArchive::clear_ruby_field() {
  if (_impl_.ruby_field_ != nullptr) _impl_.ruby_field_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void ModifyRubyTextCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
ModifyRubyTextCommandArchive::ModifyRubyTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ModifyRubyTextCommandArchive)
}
ModifyRubyTextCommandArchive::ModifyRubyTextCommandArchive(const ModifyRubyTextCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModifyRubyTextCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ruby_text_){}
    , decltype(_impl_.base_text_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.ruby_field_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ruby_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ruby_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ruby_text()) {
    _this->_impl_.ruby_text_.Set(from._internal_ruby_text(), 
      _this->GetArenaForAllocation());
  }
  _impl_.base_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_base_text()) {
    _this->_impl_.base_text_.Set(from._internal_base_text(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_ruby_field()) {
    _this->_impl_.ruby_field_ = new ::TSP::Reference(*from._impl_.ruby_field_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.ModifyRubyTextCommandArchive)
}

inline void ModifyRubyTextCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ruby_text_){}
    , decltype(_impl_.base_text_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.ruby_field_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
  };
  _impl_.ruby_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ruby_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.base_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModifyRubyTextCommandArchive::~ModifyRubyTextCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ModifyRubyTextCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModifyRubyTextCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ruby_text_.Destroy();
  _impl_.base_text_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.ruby_field_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void ModifyRubyTextCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModifyRubyTextCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ModifyRubyTextCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ruby_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.base_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.ruby_field_ != nullptr);
      _impl_.ruby_field_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModifyRubyTextCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference ruby_field = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ruby_field(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ruby_text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ruby_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.ModifyRubyTextCommandArchive.ruby_text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string base_text = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_base_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.ModifyRubyTextCommandArchive.base_text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModifyRubyTextCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ModifyRubyTextCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference ruby_field = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::ruby_field(this),
        _Internal::ruby_field(this).GetCachedSize(), target, stream);
  }

  // optional string ruby_text = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ruby_text().data(), static_cast<int>(this->_internal_ruby_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.ModifyRubyTextCommandArchive.ruby_text");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ruby_text(), target);
  }

  // optional string base_text = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_base_text().data(), static_cast<int>(this->_internal_base_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.ModifyRubyTextCommandArchive.base_text");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_base_text(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ModifyRubyTextCommandArchive)
  return target;
}

size_t ModifyRubyTextCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ModifyRubyTextCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string ruby_text = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ruby_text());
    }

    // optional string base_text = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_base_text());
    }

    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference ruby_field = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ruby_field_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModifyRubyTextCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModifyRubyTextCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModifyRubyTextCommandArchive::GetClassData() const { return &_class_data_; }


void ModifyRubyTextCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModifyRubyTextCommandArchive*>(&to_msg);
  auto& from = static_cast<const ModifyRubyTextCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ModifyRubyTextCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ruby_text(from._internal_ruby_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_base_text(from._internal_base_text());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_ruby_field()->::TSP::Reference::MergeFrom(
          from._internal_ruby_field());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModifyRubyTextCommandArchive::CopyFrom(const ModifyRubyTextCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ModifyRubyTextCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModifyRubyTextCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_ruby_field()) {
    if (!_impl_.ruby_field_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void ModifyRubyTextCommandArchive::InternalSwap(ModifyRubyTextCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ruby_text_, lhs_arena,
      &other->_impl_.ruby_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.base_text_, lhs_arena,
      &other->_impl_.base_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModifyRubyTextCommandArchive, _impl_.undo_transaction_)
      + sizeof(ModifyRubyTextCommandArchive::_impl_.undo_transaction_)
      - PROTOBUF_FIELD_OFFSET(ModifyRubyTextCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModifyRubyTextCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[13]);
}

// ===================================================================

class ModifyTOCSettingsBaseCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ModifyTOCSettingsBaseCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ModifyTOCSettingsBaseCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& old_toc_settings(const ModifyTOCSettingsBaseCommandArchive* msg);
  static void set_has_old_toc_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& new_toc_settings(const ModifyTOCSettingsBaseCommandArchive* msg);
  static void set_has_new_toc_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
ModifyTOCSettingsBaseCommandArchive::_Internal::super(const ModifyTOCSettingsBaseCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ModifyTOCSettingsBaseCommandArchive::_Internal::old_toc_settings(const ModifyTOCSettingsBaseCommandArchive* msg) {
  return *msg->_impl_.old_toc_settings_;
}
const ::TSP::Reference&
ModifyTOCSettingsBaseCommandArchive::_Internal::new_toc_settings(const ModifyTOCSettingsBaseCommandArchive* msg) {
  return *msg->_impl_.new_toc_settings_;
}
void ModifyTOCSettingsBaseCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ModifyTOCSettingsBaseCommandArchive::clear_old_toc_settings() {
  if (_impl_.old_toc_settings_ != nullptr) _impl_.old_toc_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ModifyTOCSettingsBaseCommandArchive::clear_new_toc_settings() {
  if (_impl_.new_toc_settings_ != nullptr) _impl_.new_toc_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
ModifyTOCSettingsBaseCommandArchive::ModifyTOCSettingsBaseCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ModifyTOCSettingsBaseCommandArchive)
}
ModifyTOCSettingsBaseCommandArchive::ModifyTOCSettingsBaseCommandArchive(const ModifyTOCSettingsBaseCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModifyTOCSettingsBaseCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_toc_settings_){nullptr}
    , decltype(_impl_.new_toc_settings_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_old_toc_settings()) {
    _this->_impl_.old_toc_settings_ = new ::TSP::Reference(*from._impl_.old_toc_settings_);
  }
  if (from._internal_has_new_toc_settings()) {
    _this->_impl_.new_toc_settings_ = new ::TSP::Reference(*from._impl_.new_toc_settings_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.ModifyTOCSettingsBaseCommandArchive)
}

inline void ModifyTOCSettingsBaseCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_toc_settings_){nullptr}
    , decltype(_impl_.new_toc_settings_){nullptr}
  };
}

ModifyTOCSettingsBaseCommandArchive::~ModifyTOCSettingsBaseCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ModifyTOCSettingsBaseCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModifyTOCSettingsBaseCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.old_toc_settings_;
  if (this != internal_default_instance()) delete _impl_.new_toc_settings_;
}

void ModifyTOCSettingsBaseCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModifyTOCSettingsBaseCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ModifyTOCSettingsBaseCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.old_toc_settings_ != nullptr);
      _impl_.old_toc_settings_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.new_toc_settings_ != nullptr);
      _impl_.new_toc_settings_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModifyTOCSettingsBaseCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference old_toc_settings = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_toc_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference new_toc_settings = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_toc_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModifyTOCSettingsBaseCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ModifyTOCSettingsBaseCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference old_toc_settings = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::old_toc_settings(this),
        _Internal::old_toc_settings(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference new_toc_settings = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::new_toc_settings(this),
        _Internal::new_toc_settings(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ModifyTOCSettingsBaseCommandArchive)
  return target;
}

size_t ModifyTOCSettingsBaseCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ModifyTOCSettingsBaseCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference old_toc_settings = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.old_toc_settings_);
    }

    // optional .TSP.Reference new_toc_settings = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.new_toc_settings_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModifyTOCSettingsBaseCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModifyTOCSettingsBaseCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModifyTOCSettingsBaseCommandArchive::GetClassData() const { return &_class_data_; }


void ModifyTOCSettingsBaseCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModifyTOCSettingsBaseCommandArchive*>(&to_msg);
  auto& from = static_cast<const ModifyTOCSettingsBaseCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ModifyTOCSettingsBaseCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_old_toc_settings()->::TSP::Reference::MergeFrom(
          from._internal_old_toc_settings());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_new_toc_settings()->::TSP::Reference::MergeFrom(
          from._internal_new_toc_settings());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModifyTOCSettingsBaseCommandArchive::CopyFrom(const ModifyTOCSettingsBaseCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ModifyTOCSettingsBaseCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModifyTOCSettingsBaseCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_old_toc_settings()) {
    if (!_impl_.old_toc_settings_->IsInitialized()) return false;
  }
  if (_internal_has_new_toc_settings()) {
    if (!_impl_.new_toc_settings_->IsInitialized()) return false;
  }
  return true;
}

void ModifyTOCSettingsBaseCommandArchive::InternalSwap(ModifyTOCSettingsBaseCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModifyTOCSettingsBaseCommandArchive, _impl_.new_toc_settings_)
      + sizeof(ModifyTOCSettingsBaseCommandArchive::_impl_.new_toc_settings_)
      - PROTOBUF_FIELD_OFFSET(ModifyTOCSettingsBaseCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModifyTOCSettingsBaseCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[14]);
}

// ===================================================================

class ModifyTOCSettingsForTOCInfoCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ModifyTOCSettingsForTOCInfoCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::ModifyTOCSettingsBaseCommandArchive& super(const ModifyTOCSettingsForTOCInfoCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::UUIDPath& toc_info_uuid_path(const ModifyTOCSettingsForTOCInfoCommandArchive* msg);
  static void set_has_toc_info_uuid_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSWP::ModifyTOCSettingsBaseCommandArchive&
ModifyTOCSettingsForTOCInfoCommandArchive::_Internal::super(const ModifyTOCSettingsForTOCInfoCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::UUIDPath&
ModifyTOCSettingsForTOCInfoCommandArchive::_Internal::toc_info_uuid_path(const ModifyTOCSettingsForTOCInfoCommandArchive* msg) {
  return *msg->_impl_.toc_info_uuid_path_;
}
void ModifyTOCSettingsForTOCInfoCommandArchive::clear_toc_info_uuid_path() {
  if (_impl_.toc_info_uuid_path_ != nullptr) _impl_.toc_info_uuid_path_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ModifyTOCSettingsForTOCInfoCommandArchive::ModifyTOCSettingsForTOCInfoCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
}
ModifyTOCSettingsForTOCInfoCommandArchive::ModifyTOCSettingsForTOCInfoCommandArchive(const ModifyTOCSettingsForTOCInfoCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModifyTOCSettingsForTOCInfoCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.toc_info_uuid_path_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::ModifyTOCSettingsBaseCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_toc_info_uuid_path()) {
    _this->_impl_.toc_info_uuid_path_ = new ::TSP::UUIDPath(*from._impl_.toc_info_uuid_path_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
}

inline void ModifyTOCSettingsForTOCInfoCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.toc_info_uuid_path_){nullptr}
  };
}

ModifyTOCSettingsForTOCInfoCommandArchive::~ModifyTOCSettingsForTOCInfoCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModifyTOCSettingsForTOCInfoCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.toc_info_uuid_path_;
}

void ModifyTOCSettingsForTOCInfoCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModifyTOCSettingsForTOCInfoCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.toc_info_uuid_path_ != nullptr);
      _impl_.toc_info_uuid_path_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModifyTOCSettingsForTOCInfoCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.UUIDPath toc_info_uuid_path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_toc_info_uuid_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModifyTOCSettingsForTOCInfoCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.UUIDPath toc_info_uuid_path = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::toc_info_uuid_path(this),
        _Internal::toc_info_uuid_path(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
  return target;
}

size_t ModifyTOCSettingsForTOCInfoCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.UUIDPath toc_info_uuid_path = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.toc_info_uuid_path_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModifyTOCSettingsForTOCInfoCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModifyTOCSettingsForTOCInfoCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModifyTOCSettingsForTOCInfoCommandArchive::GetClassData() const { return &_class_data_; }


void ModifyTOCSettingsForTOCInfoCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModifyTOCSettingsForTOCInfoCommandArchive*>(&to_msg);
  auto& from = static_cast<const ModifyTOCSettingsForTOCInfoCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::ModifyTOCSettingsBaseCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_toc_info_uuid_path()->::TSP::UUIDPath::MergeFrom(
          from._internal_toc_info_uuid_path());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModifyTOCSettingsForTOCInfoCommandArchive::CopyFrom(const ModifyTOCSettingsForTOCInfoCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModifyTOCSettingsForTOCInfoCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_toc_info_uuid_path()) {
    if (!_impl_.toc_info_uuid_path_->IsInitialized()) return false;
  }
  return true;
}

void ModifyTOCSettingsForTOCInfoCommandArchive::InternalSwap(ModifyTOCSettingsForTOCInfoCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModifyTOCSettingsForTOCInfoCommandArchive, _impl_.toc_info_uuid_path_)
      + sizeof(ModifyTOCSettingsForTOCInfoCommandArchive::_impl_.toc_info_uuid_path_)
      - PROTOBUF_FIELD_OFFSET(ModifyTOCSettingsForTOCInfoCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModifyTOCSettingsForTOCInfoCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[15]);
}

// ===================================================================

class ModifyTOCSettingsPresetForThemeCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ModifyTOCSettingsPresetForThemeCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::ModifyTOCSettingsBaseCommandArchive& super(const ModifyTOCSettingsPresetForThemeCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& theme(const ModifyTOCSettingsPresetForThemeCommandArchive* msg);
  static void set_has_theme(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_preset_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSWP::ModifyTOCSettingsBaseCommandArchive&
ModifyTOCSettingsPresetForThemeCommandArchive::_Internal::super(const ModifyTOCSettingsPresetForThemeCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ModifyTOCSettingsPresetForThemeCommandArchive::_Internal::theme(const ModifyTOCSettingsPresetForThemeCommandArchive* msg) {
  return *msg->_impl_.theme_;
}
void ModifyTOCSettingsPresetForThemeCommandArchive::clear_theme() {
  if (_impl_.theme_ != nullptr) _impl_.theme_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ModifyTOCSettingsPresetForThemeCommandArchive::ModifyTOCSettingsPresetForThemeCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
}
ModifyTOCSettingsPresetForThemeCommandArchive::ModifyTOCSettingsPresetForThemeCommandArchive(const ModifyTOCSettingsPresetForThemeCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModifyTOCSettingsPresetForThemeCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.theme_){nullptr}
    , decltype(_impl_.preset_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::ModifyTOCSettingsBaseCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_theme()) {
    _this->_impl_.theme_ = new ::TSP::Reference(*from._impl_.theme_);
  }
  _this->_impl_.preset_index_ = from._impl_.preset_index_;
  // @@protoc_insertion_point(copy_constructor:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
}

inline void ModifyTOCSettingsPresetForThemeCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.theme_){nullptr}
    , decltype(_impl_.preset_index_){0u}
  };
}

ModifyTOCSettingsPresetForThemeCommandArchive::~ModifyTOCSettingsPresetForThemeCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModifyTOCSettingsPresetForThemeCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.theme_;
}

void ModifyTOCSettingsPresetForThemeCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModifyTOCSettingsPresetForThemeCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.theme_ != nullptr);
      _impl_.theme_->Clear();
    }
  }
  _impl_.preset_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModifyTOCSettingsPresetForThemeCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference theme = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_theme(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 preset_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_preset_index(&has_bits);
          _impl_.preset_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModifyTOCSettingsPresetForThemeCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference theme = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::theme(this),
        _Internal::theme(this).GetCachedSize(), target, stream);
  }

  // optional uint32 preset_index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_preset_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
  return target;
}

size_t ModifyTOCSettingsPresetForThemeCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference theme = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.theme_);
    }

    // optional uint32 preset_index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_preset_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModifyTOCSettingsPresetForThemeCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModifyTOCSettingsPresetForThemeCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModifyTOCSettingsPresetForThemeCommandArchive::GetClassData() const { return &_class_data_; }


void ModifyTOCSettingsPresetForThemeCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModifyTOCSettingsPresetForThemeCommandArchive*>(&to_msg);
  auto& from = static_cast<const ModifyTOCSettingsPresetForThemeCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::ModifyTOCSettingsBaseCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_theme()->::TSP::Reference::MergeFrom(
          from._internal_theme());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.preset_index_ = from._impl_.preset_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModifyTOCSettingsPresetForThemeCommandArchive::CopyFrom(const ModifyTOCSettingsPresetForThemeCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModifyTOCSettingsPresetForThemeCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_theme()) {
    if (!_impl_.theme_->IsInitialized()) return false;
  }
  return true;
}

void ModifyTOCSettingsPresetForThemeCommandArchive::InternalSwap(ModifyTOCSettingsPresetForThemeCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModifyTOCSettingsPresetForThemeCommandArchive, _impl_.preset_index_)
      + sizeof(ModifyTOCSettingsPresetForThemeCommandArchive::_impl_.preset_index_)
      - PROTOBUF_FIELD_OFFSET(ModifyTOCSettingsPresetForThemeCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModifyTOCSettingsPresetForThemeCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[16]);
}

// ===================================================================

class AnchorAttachmentCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<AnchorAttachmentCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::StorageActionCommandArchive& super(const AnchorAttachmentCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& attachment(const AnchorAttachmentCommandArchive* msg);
  static void set_has_attachment(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_h_offset_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_h_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_v_offset_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_v_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_html_wrap(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_undo_h_offset_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_undo_h_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_undo_v_offset_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_undo_v_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_undo_is_html_wrap(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::TSWP::StorageActionCommandArchive&
AnchorAttachmentCommandArchive::_Internal::super(const AnchorAttachmentCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
AnchorAttachmentCommandArchive::_Internal::attachment(const AnchorAttachmentCommandArchive* msg) {
  return *msg->_impl_.attachment_;
}
void AnchorAttachmentCommandArchive::clear_attachment() {
  if (_impl_.attachment_ != nullptr) _impl_.attachment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
AnchorAttachmentCommandArchive::AnchorAttachmentCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.AnchorAttachmentCommandArchive)
}
AnchorAttachmentCommandArchive::AnchorAttachmentCommandArchive(const AnchorAttachmentCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AnchorAttachmentCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.attachment_){nullptr}
    , decltype(_impl_.h_offset_type_){}
    , decltype(_impl_.h_offset_){}
    , decltype(_impl_.v_offset_type_){}
    , decltype(_impl_.v_offset_){}
    , decltype(_impl_.undo_h_offset_type_){}
    , decltype(_impl_.undo_h_offset_){}
    , decltype(_impl_.is_html_wrap_){}
    , decltype(_impl_.undo_is_html_wrap_){}
    , decltype(_impl_.undo_v_offset_type_){}
    , decltype(_impl_.undo_v_offset_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::StorageActionCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_attachment()) {
    _this->_impl_.attachment_ = new ::TSP::Reference(*from._impl_.attachment_);
  }
  ::memcpy(&_impl_.h_offset_type_, &from._impl_.h_offset_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.undo_v_offset_) -
    reinterpret_cast<char*>(&_impl_.h_offset_type_)) + sizeof(_impl_.undo_v_offset_));
  // @@protoc_insertion_point(copy_constructor:TSWP.AnchorAttachmentCommandArchive)
}

inline void AnchorAttachmentCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.attachment_){nullptr}
    , decltype(_impl_.h_offset_type_){0u}
    , decltype(_impl_.h_offset_){0}
    , decltype(_impl_.v_offset_type_){0u}
    , decltype(_impl_.v_offset_){0}
    , decltype(_impl_.undo_h_offset_type_){0u}
    , decltype(_impl_.undo_h_offset_){0}
    , decltype(_impl_.is_html_wrap_){false}
    , decltype(_impl_.undo_is_html_wrap_){false}
    , decltype(_impl_.undo_v_offset_type_){0u}
    , decltype(_impl_.undo_v_offset_){0}
  };
}

AnchorAttachmentCommandArchive::~AnchorAttachmentCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.AnchorAttachmentCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AnchorAttachmentCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.attachment_;
}

void AnchorAttachmentCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AnchorAttachmentCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.AnchorAttachmentCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.attachment_ != nullptr);
      _impl_.attachment_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.h_offset_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.undo_h_offset_) -
        reinterpret_cast<char*>(&_impl_.h_offset_type_)) + sizeof(_impl_.undo_h_offset_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.is_html_wrap_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.undo_v_offset_) -
        reinterpret_cast<char*>(&_impl_.is_html_wrap_)) + sizeof(_impl_.undo_v_offset_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnchorAttachmentCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.StorageActionCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference attachment = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_attachment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 h_offset_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_h_offset_type(&has_bits);
          _impl_.h_offset_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float h_offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_h_offset(&has_bits);
          _impl_.h_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 v_offset_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_v_offset_type(&has_bits);
          _impl_.v_offset_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float v_offset = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_v_offset(&has_bits);
          _impl_.v_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_html_wrap = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_is_html_wrap(&has_bits);
          _impl_.is_html_wrap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 undo_h_offset_type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_undo_h_offset_type(&has_bits);
          _impl_.undo_h_offset_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float undo_h_offset = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_undo_h_offset(&has_bits);
          _impl_.undo_h_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 undo_v_offset_type = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_undo_v_offset_type(&has_bits);
          _impl_.undo_v_offset_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float undo_v_offset = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_undo_v_offset(&has_bits);
          _impl_.undo_v_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool undo_is_html_wrap = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_undo_is_html_wrap(&has_bits);
          _impl_.undo_is_html_wrap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AnchorAttachmentCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.AnchorAttachmentCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.StorageActionCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference attachment = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::attachment(this),
        _Internal::attachment(this).GetCachedSize(), target, stream);
  }

  // optional uint32 h_offset_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_h_offset_type(), target);
  }

  // optional float h_offset = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_h_offset(), target);
  }

  // optional uint32 v_offset_type = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_v_offset_type(), target);
  }

  // optional float v_offset = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_v_offset(), target);
  }

  // optional bool is_html_wrap = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_is_html_wrap(), target);
  }

  // optional uint32 undo_h_offset_type = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_undo_h_offset_type(), target);
  }

  // optional float undo_h_offset = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_undo_h_offset(), target);
  }

  // optional uint32 undo_v_offset_type = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_undo_v_offset_type(), target);
  }

  // optional float undo_v_offset = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_undo_v_offset(), target);
  }

  // optional bool undo_is_html_wrap = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_undo_is_html_wrap(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.AnchorAttachmentCommandArchive)
  return target;
}

size_t AnchorAttachmentCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.AnchorAttachmentCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSWP.StorageActionCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference attachment = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.attachment_);
    }

    // optional uint32 h_offset_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_h_offset_type());
    }

    // optional float h_offset = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional uint32 v_offset_type = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_v_offset_type());
    }

    // optional float v_offset = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional uint32 undo_h_offset_type = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undo_h_offset_type());
    }

    // optional float undo_h_offset = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional bool is_html_wrap = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool undo_is_html_wrap = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional uint32 undo_v_offset_type = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undo_v_offset_type());
    }

    // optional float undo_v_offset = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AnchorAttachmentCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AnchorAttachmentCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AnchorAttachmentCommandArchive::GetClassData() const { return &_class_data_; }


void AnchorAttachmentCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AnchorAttachmentCommandArchive*>(&to_msg);
  auto& from = static_cast<const AnchorAttachmentCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.AnchorAttachmentCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::StorageActionCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_attachment()->::TSP::Reference::MergeFrom(
          from._internal_attachment());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.h_offset_type_ = from._impl_.h_offset_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.h_offset_ = from._impl_.h_offset_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.v_offset_type_ = from._impl_.v_offset_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.v_offset_ = from._impl_.v_offset_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.undo_h_offset_type_ = from._impl_.undo_h_offset_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.undo_h_offset_ = from._impl_.undo_h_offset_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.is_html_wrap_ = from._impl_.is_html_wrap_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.undo_is_html_wrap_ = from._impl_.undo_is_html_wrap_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.undo_v_offset_type_ = from._impl_.undo_v_offset_type_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.undo_v_offset_ = from._impl_.undo_v_offset_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AnchorAttachmentCommandArchive::CopyFrom(const AnchorAttachmentCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.AnchorAttachmentCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnchorAttachmentCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_attachment()) {
    if (!_impl_.attachment_->IsInitialized()) return false;
  }
  return true;
}

void AnchorAttachmentCommandArchive::InternalSwap(AnchorAttachmentCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AnchorAttachmentCommandArchive, _impl_.undo_v_offset_)
      + sizeof(AnchorAttachmentCommandArchive::_impl_.undo_v_offset_)
      - PROTOBUF_FIELD_OFFSET(AnchorAttachmentCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AnchorAttachmentCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[17]);
}

// ===================================================================

class TextApplyThemeCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<TextApplyThemeCommandArchive>()._impl_._has_bits_);
  static const ::TSS::ApplyThemeChildCommandArchive& super(const TextApplyThemeCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const TextApplyThemeCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const TextApplyThemeCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSS::ApplyThemeChildCommandArchive&
TextApplyThemeCommandArchive::_Internal::super(const TextApplyThemeCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
TextApplyThemeCommandArchive::_Internal::storage(const TextApplyThemeCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
TextApplyThemeCommandArchive::_Internal::undo_transaction(const TextApplyThemeCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void TextApplyThemeCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TextApplyThemeCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TextApplyThemeCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
TextApplyThemeCommandArchive::TextApplyThemeCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.TextApplyThemeCommandArchive)
}
TextApplyThemeCommandArchive::TextApplyThemeCommandArchive(const TextApplyThemeCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TextApplyThemeCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSS::ApplyThemeChildCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.TextApplyThemeCommandArchive)
}

inline void TextApplyThemeCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
  };
}

TextApplyThemeCommandArchive::~TextApplyThemeCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.TextApplyThemeCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TextApplyThemeCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void TextApplyThemeCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TextApplyThemeCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.TextApplyThemeCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TextApplyThemeCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSS.ApplyThemeChildCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TextApplyThemeCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.TextApplyThemeCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSS.ApplyThemeChildCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.TextApplyThemeCommandArchive)
  return target;
}

size_t TextApplyThemeCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.TextApplyThemeCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSS.ApplyThemeChildCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TextApplyThemeCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TextApplyThemeCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TextApplyThemeCommandArchive::GetClassData() const { return &_class_data_; }


void TextApplyThemeCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TextApplyThemeCommandArchive*>(&to_msg);
  auto& from = static_cast<const TextApplyThemeCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.TextApplyThemeCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSS::ApplyThemeChildCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TextApplyThemeCommandArchive::CopyFrom(const TextApplyThemeCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.TextApplyThemeCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextApplyThemeCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void TextApplyThemeCommandArchive::InternalSwap(TextApplyThemeCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TextApplyThemeCommandArchive, _impl_.undo_transaction_)
      + sizeof(TextApplyThemeCommandArchive::_impl_.undo_transaction_)
      - PROTOBUF_FIELD_OFFSET(TextApplyThemeCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TextApplyThemeCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[18]);
}

// ===================================================================

class MoveColumnsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MoveColumnsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const MoveColumnsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const MoveColumnsCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_src_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dst_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const MoveColumnsCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
MoveColumnsCommandArchive::_Internal::super(const MoveColumnsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
MoveColumnsCommandArchive::_Internal::storage(const MoveColumnsCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
MoveColumnsCommandArchive::_Internal::undo_transaction(const MoveColumnsCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void MoveColumnsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MoveColumnsCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MoveColumnsCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
MoveColumnsCommandArchive::MoveColumnsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.MoveColumnsCommandArchive)
}
MoveColumnsCommandArchive::MoveColumnsCommandArchive(const MoveColumnsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveColumnsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.src_index_){}
    , decltype(_impl_.dst_index_){}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.src_index_, &from._impl_.src_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) -
    reinterpret_cast<char*>(&_impl_.src_index_)) + sizeof(_impl_.count_));
  // @@protoc_insertion_point(copy_constructor:TSWP.MoveColumnsCommandArchive)
}

inline void MoveColumnsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.src_index_){0u}
    , decltype(_impl_.dst_index_){0u}
    , decltype(_impl_.count_){0u}
  };
}

MoveColumnsCommandArchive::~MoveColumnsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.MoveColumnsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveColumnsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void MoveColumnsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveColumnsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.MoveColumnsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.src_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.count_) -
        reinterpret_cast<char*>(&_impl_.src_index_)) + sizeof(_impl_.count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveColumnsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 src_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_src_index(&has_bits);
          _impl_.src_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dst_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_dst_index(&has_bits);
          _impl_.dst_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveColumnsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.MoveColumnsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 src_index = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_src_index(), target);
  }

  // optional uint32 dst_index = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_dst_index(), target);
  }

  // optional uint32 count = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_count(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.MoveColumnsCommandArchive)
  return target;
}

size_t MoveColumnsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.MoveColumnsCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 src_index = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_src_index());
    }

    // optional uint32 dst_index = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dst_index());
    }

    // optional uint32 count = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveColumnsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveColumnsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveColumnsCommandArchive::GetClassData() const { return &_class_data_; }


void MoveColumnsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveColumnsCommandArchive*>(&to_msg);
  auto& from = static_cast<const MoveColumnsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.MoveColumnsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.src_index_ = from._impl_.src_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.dst_index_ = from._impl_.dst_index_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveColumnsCommandArchive::CopyFrom(const MoveColumnsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.MoveColumnsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveColumnsCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void MoveColumnsCommandArchive::InternalSwap(MoveColumnsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveColumnsCommandArchive, _impl_.count_)
      + sizeof(MoveColumnsCommandArchive::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(MoveColumnsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveColumnsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[19]);
}

// ===================================================================

class MoveRowsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MoveRowsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const MoveRowsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const MoveRowsCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_src_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dst_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const MoveRowsCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
MoveRowsCommandArchive::_Internal::super(const MoveRowsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
MoveRowsCommandArchive::_Internal::storage(const MoveRowsCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
MoveRowsCommandArchive::_Internal::undo_transaction(const MoveRowsCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void MoveRowsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MoveRowsCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MoveRowsCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
MoveRowsCommandArchive::MoveRowsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.MoveRowsCommandArchive)
}
MoveRowsCommandArchive::MoveRowsCommandArchive(const MoveRowsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveRowsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.src_index_){}
    , decltype(_impl_.dst_index_){}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.src_index_, &from._impl_.src_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) -
    reinterpret_cast<char*>(&_impl_.src_index_)) + sizeof(_impl_.count_));
  // @@protoc_insertion_point(copy_constructor:TSWP.MoveRowsCommandArchive)
}

inline void MoveRowsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.src_index_){0u}
    , decltype(_impl_.dst_index_){0u}
    , decltype(_impl_.count_){0u}
  };
}

MoveRowsCommandArchive::~MoveRowsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.MoveRowsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveRowsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void MoveRowsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveRowsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.MoveRowsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.src_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.count_) -
        reinterpret_cast<char*>(&_impl_.src_index_)) + sizeof(_impl_.count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveRowsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 src_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_src_index(&has_bits);
          _impl_.src_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dst_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_dst_index(&has_bits);
          _impl_.dst_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveRowsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.MoveRowsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 src_index = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_src_index(), target);
  }

  // optional uint32 dst_index = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_dst_index(), target);
  }

  // optional uint32 count = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_count(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.MoveRowsCommandArchive)
  return target;
}

size_t MoveRowsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.MoveRowsCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 src_index = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_src_index());
    }

    // optional uint32 dst_index = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dst_index());
    }

    // optional uint32 count = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveRowsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveRowsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveRowsCommandArchive::GetClassData() const { return &_class_data_; }


void MoveRowsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveRowsCommandArchive*>(&to_msg);
  auto& from = static_cast<const MoveRowsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.MoveRowsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.src_index_ = from._impl_.src_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.dst_index_ = from._impl_.dst_index_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveRowsCommandArchive::CopyFrom(const MoveRowsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.MoveRowsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveRowsCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void MoveRowsCommandArchive::InternalSwap(MoveRowsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveRowsCommandArchive, _impl_.count_)
      + sizeof(MoveRowsCommandArchive::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(MoveRowsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveRowsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[20]);
}

// ===================================================================

class ShapeApplyPresetCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapeApplyPresetCommandArchive>()._impl_._has_bits_);
  static const ::TSD::BaseApplyPresetCommandArchive& super(const ShapeApplyPresetCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& undo_style(const ShapeApplyPresetCommandArchive* msg);
  static void set_has_undo_style(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::BaseApplyPresetCommandArchive&
ShapeApplyPresetCommandArchive::_Internal::super(const ShapeApplyPresetCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ShapeApplyPresetCommandArchive::_Internal::undo_style(const ShapeApplyPresetCommandArchive* msg) {
  return *msg->_impl_.undo_style_;
}
void ShapeApplyPresetCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ShapeApplyPresetCommandArchive::clear_undo_style() {
  if (_impl_.undo_style_ != nullptr) _impl_.undo_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ShapeApplyPresetCommandArchive::ShapeApplyPresetCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ShapeApplyPresetCommandArchive)
}
ShapeApplyPresetCommandArchive::ShapeApplyPresetCommandArchive(const ShapeApplyPresetCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapeApplyPresetCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_style_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::BaseApplyPresetCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_undo_style()) {
    _this->_impl_.undo_style_ = new ::TSP::Reference(*from._impl_.undo_style_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.ShapeApplyPresetCommandArchive)
}

inline void ShapeApplyPresetCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_style_){nullptr}
  };
}

ShapeApplyPresetCommandArchive::~ShapeApplyPresetCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ShapeApplyPresetCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeApplyPresetCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.undo_style_;
}

void ShapeApplyPresetCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapeApplyPresetCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ShapeApplyPresetCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_style_ != nullptr);
      _impl_.undo_style_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapeApplyPresetCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.BaseApplyPresetCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference undo_style = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeApplyPresetCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ShapeApplyPresetCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.BaseApplyPresetCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference undo_style = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_style(this),
        _Internal::undo_style(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ShapeApplyPresetCommandArchive)
  return target;
}

size_t ShapeApplyPresetCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ShapeApplyPresetCommandArchive)
  size_t total_size = 0;

  // required .TSD.BaseApplyPresetCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Reference undo_style = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_style_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapeApplyPresetCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapeApplyPresetCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapeApplyPresetCommandArchive::GetClassData() const { return &_class_data_; }


void ShapeApplyPresetCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapeApplyPresetCommandArchive*>(&to_msg);
  auto& from = static_cast<const ShapeApplyPresetCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ShapeApplyPresetCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::BaseApplyPresetCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_style()->::TSP::Reference::MergeFrom(
          from._internal_undo_style());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapeApplyPresetCommandArchive::CopyFrom(const ShapeApplyPresetCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ShapeApplyPresetCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeApplyPresetCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_undo_style()) {
    if (!_impl_.undo_style_->IsInitialized()) return false;
  }
  return true;
}

void ShapeApplyPresetCommandArchive::InternalSwap(ShapeApplyPresetCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShapeApplyPresetCommandArchive, _impl_.undo_style_)
      + sizeof(ShapeApplyPresetCommandArchive::_impl_.undo_style_)
      - PROTOBUF_FIELD_OFFSET(ShapeApplyPresetCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapeApplyPresetCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[21]);
}

// ===================================================================

class StyleBaseCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyleBaseCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const StyleBaseCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& theme(const StyleBaseCommandArchive* msg);
  static void set_has_theme(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& style(const StyleBaseCommandArchive* msg);
  static void set_has_style(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
StyleBaseCommandArchive::_Internal::super(const StyleBaseCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
StyleBaseCommandArchive::_Internal::theme(const StyleBaseCommandArchive* msg) {
  return *msg->_impl_.theme_;
}
const ::TSP::Reference&
StyleBaseCommandArchive::_Internal::style(const StyleBaseCommandArchive* msg) {
  return *msg->_impl_.style_;
}
void StyleBaseCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void StyleBaseCommandArchive::clear_theme() {
  if (_impl_.theme_ != nullptr) _impl_.theme_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void StyleBaseCommandArchive::clear_style() {
  if (_impl_.style_ != nullptr) _impl_.style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
StyleBaseCommandArchive::StyleBaseCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.StyleBaseCommandArchive)
}
StyleBaseCommandArchive::StyleBaseCommandArchive(const StyleBaseCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyleBaseCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.theme_){nullptr}
    , decltype(_impl_.style_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_theme()) {
    _this->_impl_.theme_ = new ::TSP::Reference(*from._impl_.theme_);
  }
  if (from._internal_has_style()) {
    _this->_impl_.style_ = new ::TSP::Reference(*from._impl_.style_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.StyleBaseCommandArchive)
}

inline void StyleBaseCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.theme_){nullptr}
    , decltype(_impl_.style_){nullptr}
  };
}

StyleBaseCommandArchive::~StyleBaseCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.StyleBaseCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleBaseCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.theme_;
  if (this != internal_default_instance()) delete _impl_.style_;
}

void StyleBaseCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyleBaseCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.StyleBaseCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.theme_ != nullptr);
      _impl_.theme_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.style_ != nullptr);
      _impl_.style_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyleBaseCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference theme = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_theme(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleBaseCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.StyleBaseCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference theme = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::theme(this),
        _Internal::theme(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference style = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::style(this),
        _Internal::style(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.StyleBaseCommandArchive)
  return target;
}

size_t StyleBaseCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.StyleBaseCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference theme = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.theme_);
    }

    // optional .TSP.Reference style = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.style_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleBaseCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyleBaseCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleBaseCommandArchive::GetClassData() const { return &_class_data_; }


void StyleBaseCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyleBaseCommandArchive*>(&to_msg);
  auto& from = static_cast<const StyleBaseCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.StyleBaseCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_theme()->::TSP::Reference::MergeFrom(
          from._internal_theme());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_style()->::TSP::Reference::MergeFrom(
          from._internal_style());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyleBaseCommandArchive::CopyFrom(const StyleBaseCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.StyleBaseCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleBaseCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_theme()) {
    if (!_impl_.theme_->IsInitialized()) return false;
  }
  if (_internal_has_style()) {
    if (!_impl_.style_->IsInitialized()) return false;
  }
  return true;
}

void StyleBaseCommandArchive::InternalSwap(StyleBaseCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StyleBaseCommandArchive, _impl_.style_)
      + sizeof(StyleBaseCommandArchive::_impl_.style_)
      - PROTOBUF_FIELD_OFFSET(StyleBaseCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StyleBaseCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[22]);
}

// ===================================================================

class StyleCreateCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyleCreateCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::StyleBaseCommandArchive& super(const StyleCreateCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_preset_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSWP::StyleBaseCommandArchive&
StyleCreateCommandArchive::_Internal::super(const StyleCreateCommandArchive* msg) {
  return *msg->_impl_.super_;
}
StyleCreateCommandArchive::StyleCreateCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.StyleCreateCommandArchive)
}
StyleCreateCommandArchive::StyleCreateCommandArchive(const StyleCreateCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyleCreateCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.preset_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::StyleBaseCommandArchive(*from._impl_.super_);
  }
  _this->_impl_.preset_index_ = from._impl_.preset_index_;
  // @@protoc_insertion_point(copy_constructor:TSWP.StyleCreateCommandArchive)
}

inline void StyleCreateCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.preset_index_){0u}
  };
}

StyleCreateCommandArchive::~StyleCreateCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.StyleCreateCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleCreateCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void StyleCreateCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyleCreateCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.StyleCreateCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.preset_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyleCreateCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.StyleBaseCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 preset_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_preset_index(&has_bits);
          _impl_.preset_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleCreateCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.StyleCreateCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.StyleBaseCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 preset_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_preset_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.StyleCreateCommandArchive)
  return target;
}

size_t StyleCreateCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.StyleCreateCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSWP.StyleBaseCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional uint32 preset_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_preset_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleCreateCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyleCreateCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleCreateCommandArchive::GetClassData() const { return &_class_data_; }


void StyleCreateCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyleCreateCommandArchive*>(&to_msg);
  auto& from = static_cast<const StyleCreateCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.StyleCreateCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::StyleBaseCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.preset_index_ = from._impl_.preset_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyleCreateCommandArchive::CopyFrom(const StyleCreateCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.StyleCreateCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleCreateCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void StyleCreateCommandArchive::InternalSwap(StyleCreateCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StyleCreateCommandArchive, _impl_.preset_index_)
      + sizeof(StyleCreateCommandArchive::_impl_.preset_index_)
      - PROTOBUF_FIELD_OFFSET(StyleCreateCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StyleCreateCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[23]);
}

// ===================================================================

class StyleRenameCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyleRenameCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::StyleBaseCommandArchive& super(const StyleRenameCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_updated_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_old_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSWP::StyleBaseCommandArchive&
StyleRenameCommandArchive::_Internal::super(const StyleRenameCommandArchive* msg) {
  return *msg->_impl_.super_;
}
StyleRenameCommandArchive::StyleRenameCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.StyleRenameCommandArchive)
}
StyleRenameCommandArchive::StyleRenameCommandArchive(const StyleRenameCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyleRenameCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.updated_name_){}
    , decltype(_impl_.old_name_){}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.updated_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.updated_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_updated_name()) {
    _this->_impl_.updated_name_.Set(from._internal_updated_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.old_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.old_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_old_name()) {
    _this->_impl_.old_name_.Set(from._internal_old_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::StyleBaseCommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.StyleRenameCommandArchive)
}

inline void StyleRenameCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.updated_name_){}
    , decltype(_impl_.old_name_){}
    , decltype(_impl_.super_){nullptr}
  };
  _impl_.updated_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.updated_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.old_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.old_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StyleRenameCommandArchive::~StyleRenameCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.StyleRenameCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleRenameCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.updated_name_.Destroy();
  _impl_.old_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void StyleRenameCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyleRenameCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.StyleRenameCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.updated_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.old_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyleRenameCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.StyleBaseCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string updated_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_updated_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.StyleRenameCommandArchive.updated_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string old_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_old_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.StyleRenameCommandArchive.old_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleRenameCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.StyleRenameCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.StyleBaseCommandArchive super = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional string updated_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_updated_name().data(), static_cast<int>(this->_internal_updated_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.StyleRenameCommandArchive.updated_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_updated_name(), target);
  }

  // optional string old_name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_old_name().data(), static_cast<int>(this->_internal_old_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.StyleRenameCommandArchive.old_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_old_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.StyleRenameCommandArchive)
  return target;
}

size_t StyleRenameCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.StyleRenameCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string updated_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_updated_name());
    }

    // optional string old_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_old_name());
    }

    // optional .TSWP.StyleBaseCommandArchive super = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleRenameCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyleRenameCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleRenameCommandArchive::GetClassData() const { return &_class_data_; }


void StyleRenameCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyleRenameCommandArchive*>(&to_msg);
  auto& from = static_cast<const StyleRenameCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.StyleRenameCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_updated_name(from._internal_updated_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_old_name(from._internal_old_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TSWP::StyleBaseCommandArchive::MergeFrom(
          from._internal_super());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyleRenameCommandArchive::CopyFrom(const StyleRenameCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.StyleRenameCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleRenameCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void StyleRenameCommandArchive::InternalSwap(StyleRenameCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.updated_name_, lhs_arena,
      &other->_impl_.updated_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.old_name_, lhs_arena,
      &other->_impl_.old_name_, rhs_arena
  );
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StyleRenameCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[24]);
}

// ===================================================================

class StyleUpdateCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyleUpdateCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::StyleBaseCommandArchive& super(const StyleUpdateCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& original_style(const StyleUpdateCommandArchive* msg);
  static void set_has_original_style(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& updated_style(const StyleUpdateCommandArchive* msg);
  static void set_has_updated_style(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSWP::StyleBaseCommandArchive&
StyleUpdateCommandArchive::_Internal::super(const StyleUpdateCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
StyleUpdateCommandArchive::_Internal::original_style(const StyleUpdateCommandArchive* msg) {
  return *msg->_impl_.original_style_;
}
const ::TSP::Reference&
StyleUpdateCommandArchive::_Internal::updated_style(const StyleUpdateCommandArchive* msg) {
  return *msg->_impl_.updated_style_;
}
void StyleUpdateCommandArchive::clear_original_style() {
  if (_impl_.original_style_ != nullptr) _impl_.original_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void StyleUpdateCommandArchive::clear_updated_style() {
  if (_impl_.updated_style_ != nullptr) _impl_.updated_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
StyleUpdateCommandArchive::StyleUpdateCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.StyleUpdateCommandArchive)
}
StyleUpdateCommandArchive::StyleUpdateCommandArchive(const StyleUpdateCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyleUpdateCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.original_style_){nullptr}
    , decltype(_impl_.updated_style_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::StyleBaseCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_original_style()) {
    _this->_impl_.original_style_ = new ::TSP::Reference(*from._impl_.original_style_);
  }
  if (from._internal_has_updated_style()) {
    _this->_impl_.updated_style_ = new ::TSP::Reference(*from._impl_.updated_style_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.StyleUpdateCommandArchive)
}

inline void StyleUpdateCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.original_style_){nullptr}
    , decltype(_impl_.updated_style_){nullptr}
  };
}

StyleUpdateCommandArchive::~StyleUpdateCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.StyleUpdateCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleUpdateCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.original_style_;
  if (this != internal_default_instance()) delete _impl_.updated_style_;
}

void StyleUpdateCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyleUpdateCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.StyleUpdateCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.original_style_ != nullptr);
      _impl_.original_style_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.updated_style_ != nullptr);
      _impl_.updated_style_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyleUpdateCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.StyleBaseCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference original_style = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_original_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference updated_style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_updated_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleUpdateCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.StyleUpdateCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.StyleBaseCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference original_style = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::original_style(this),
        _Internal::original_style(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference updated_style = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::updated_style(this),
        _Internal::updated_style(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.StyleUpdateCommandArchive)
  return target;
}

size_t StyleUpdateCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.StyleUpdateCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSWP.StyleBaseCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference original_style = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.original_style_);
    }

    // optional .TSP.Reference updated_style = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.updated_style_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleUpdateCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyleUpdateCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleUpdateCommandArchive::GetClassData() const { return &_class_data_; }


void StyleUpdateCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyleUpdateCommandArchive*>(&to_msg);
  auto& from = static_cast<const StyleUpdateCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.StyleUpdateCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::StyleBaseCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_original_style()->::TSP::Reference::MergeFrom(
          from._internal_original_style());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_updated_style()->::TSP::Reference::MergeFrom(
          from._internal_updated_style());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyleUpdateCommandArchive::CopyFrom(const StyleUpdateCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.StyleUpdateCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleUpdateCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_original_style()) {
    if (!_impl_.original_style_->IsInitialized()) return false;
  }
  if (_internal_has_updated_style()) {
    if (!_impl_.updated_style_->IsInitialized()) return false;
  }
  return true;
}

void StyleUpdateCommandArchive::InternalSwap(StyleUpdateCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StyleUpdateCommandArchive, _impl_.updated_style_)
      + sizeof(StyleUpdateCommandArchive::_impl_.updated_style_)
      - PROTOBUF_FIELD_OFFSET(StyleUpdateCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StyleUpdateCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[25]);
}

// ===================================================================

class StyleDeleteCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyleDeleteCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::StyleBaseCommandArchive& super(const StyleDeleteCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_old_preset_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSWP::StyleBaseCommandArchive&
StyleDeleteCommandArchive::_Internal::super(const StyleDeleteCommandArchive* msg) {
  return *msg->_impl_.super_;
}
StyleDeleteCommandArchive::StyleDeleteCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.StyleDeleteCommandArchive)
}
StyleDeleteCommandArchive::StyleDeleteCommandArchive(const StyleDeleteCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyleDeleteCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_preset_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::StyleBaseCommandArchive(*from._impl_.super_);
  }
  _this->_impl_.old_preset_index_ = from._impl_.old_preset_index_;
  // @@protoc_insertion_point(copy_constructor:TSWP.StyleDeleteCommandArchive)
}

inline void StyleDeleteCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_preset_index_){0u}
  };
}

StyleDeleteCommandArchive::~StyleDeleteCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.StyleDeleteCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleDeleteCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void StyleDeleteCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyleDeleteCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.StyleDeleteCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.old_preset_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyleDeleteCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.StyleBaseCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 old_preset_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_old_preset_index(&has_bits);
          _impl_.old_preset_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleDeleteCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.StyleDeleteCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.StyleBaseCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 old_preset_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_old_preset_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.StyleDeleteCommandArchive)
  return target;
}

size_t StyleDeleteCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.StyleDeleteCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSWP.StyleBaseCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional uint32 old_preset_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_old_preset_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleDeleteCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyleDeleteCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleDeleteCommandArchive::GetClassData() const { return &_class_data_; }


void StyleDeleteCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyleDeleteCommandArchive*>(&to_msg);
  auto& from = static_cast<const StyleDeleteCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.StyleDeleteCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::StyleBaseCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.old_preset_index_ = from._impl_.old_preset_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyleDeleteCommandArchive::CopyFrom(const StyleDeleteCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.StyleDeleteCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleDeleteCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void StyleDeleteCommandArchive::InternalSwap(StyleDeleteCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StyleDeleteCommandArchive, _impl_.old_preset_index_)
      + sizeof(StyleDeleteCommandArchive::_impl_.old_preset_index_)
      - PROTOBUF_FIELD_OFFSET(StyleDeleteCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StyleDeleteCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[26]);
}

// ===================================================================

class StyleReorderCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyleReorderCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::StyleBaseCommandArchive& super(const StyleReorderCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_old_preset_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_new_preset_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSWP::StyleBaseCommandArchive&
StyleReorderCommandArchive::_Internal::super(const StyleReorderCommandArchive* msg) {
  return *msg->_impl_.super_;
}
StyleReorderCommandArchive::StyleReorderCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.StyleReorderCommandArchive)
}
StyleReorderCommandArchive::StyleReorderCommandArchive(const StyleReorderCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyleReorderCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_preset_index_){}
    , decltype(_impl_.new_preset_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::StyleBaseCommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.old_preset_index_, &from._impl_.old_preset_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.new_preset_index_) -
    reinterpret_cast<char*>(&_impl_.old_preset_index_)) + sizeof(_impl_.new_preset_index_));
  // @@protoc_insertion_point(copy_constructor:TSWP.StyleReorderCommandArchive)
}

inline void StyleReorderCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_preset_index_){0u}
    , decltype(_impl_.new_preset_index_){0u}
  };
}

StyleReorderCommandArchive::~StyleReorderCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.StyleReorderCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleReorderCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void StyleReorderCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyleReorderCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.StyleReorderCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.old_preset_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.new_preset_index_) -
        reinterpret_cast<char*>(&_impl_.old_preset_index_)) + sizeof(_impl_.new_preset_index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyleReorderCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.StyleBaseCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 old_preset_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_old_preset_index(&has_bits);
          _impl_.old_preset_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 new_preset_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_new_preset_index(&has_bits);
          _impl_.new_preset_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleReorderCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.StyleReorderCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.StyleBaseCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 old_preset_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_old_preset_index(), target);
  }

  // optional uint32 new_preset_index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_new_preset_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.StyleReorderCommandArchive)
  return target;
}

size_t StyleReorderCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.StyleReorderCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSWP.StyleBaseCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional uint32 old_preset_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_old_preset_index());
    }

    // optional uint32 new_preset_index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_new_preset_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleReorderCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyleReorderCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleReorderCommandArchive::GetClassData() const { return &_class_data_; }


void StyleReorderCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyleReorderCommandArchive*>(&to_msg);
  auto& from = static_cast<const StyleReorderCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.StyleReorderCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::StyleBaseCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.old_preset_index_ = from._impl_.old_preset_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.new_preset_index_ = from._impl_.new_preset_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyleReorderCommandArchive::CopyFrom(const StyleReorderCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.StyleReorderCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleReorderCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void StyleReorderCommandArchive::InternalSwap(StyleReorderCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StyleReorderCommandArchive, _impl_.new_preset_index_)
      + sizeof(StyleReorderCommandArchive::_impl_.new_preset_index_)
      - PROTOBUF_FIELD_OFFSET(StyleReorderCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StyleReorderCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[27]);
}

// ===================================================================

class StyleUpdatePropertyMapCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyleUpdatePropertyMapCommandArchive>()._impl_._has_bits_);
  static const ::TSS::StyleUpdatePropertyMapCommandArchive& super(const StyleUpdatePropertyMapCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSS::StyleUpdatePropertyMapCommandArchive&
StyleUpdatePropertyMapCommandArchive::_Internal::super(const StyleUpdatePropertyMapCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void StyleUpdatePropertyMapCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
StyleUpdatePropertyMapCommandArchive::StyleUpdatePropertyMapCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.StyleUpdatePropertyMapCommandArchive)
}
StyleUpdatePropertyMapCommandArchive::StyleUpdatePropertyMapCommandArchive(const StyleUpdatePropertyMapCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyleUpdatePropertyMapCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSS::StyleUpdatePropertyMapCommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.StyleUpdatePropertyMapCommandArchive)
}

inline void StyleUpdatePropertyMapCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

StyleUpdatePropertyMapCommandArchive::~StyleUpdatePropertyMapCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.StyleUpdatePropertyMapCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleUpdatePropertyMapCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void StyleUpdatePropertyMapCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyleUpdatePropertyMapCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.StyleUpdatePropertyMapCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyleUpdatePropertyMapCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSS.StyleUpdatePropertyMapCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleUpdatePropertyMapCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.StyleUpdatePropertyMapCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSS.StyleUpdatePropertyMapCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.StyleUpdatePropertyMapCommandArchive)
  return target;
}

size_t StyleUpdatePropertyMapCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.StyleUpdatePropertyMapCommandArchive)
  size_t total_size = 0;

  // required .TSS.StyleUpdatePropertyMapCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleUpdatePropertyMapCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyleUpdatePropertyMapCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleUpdatePropertyMapCommandArchive::GetClassData() const { return &_class_data_; }


void StyleUpdatePropertyMapCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyleUpdatePropertyMapCommandArchive*>(&to_msg);
  auto& from = static_cast<const StyleUpdatePropertyMapCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.StyleUpdatePropertyMapCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSS::StyleUpdatePropertyMapCommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyleUpdatePropertyMapCommandArchive::CopyFrom(const StyleUpdatePropertyMapCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.StyleUpdatePropertyMapCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleUpdatePropertyMapCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void StyleUpdatePropertyMapCommandArchive::InternalSwap(StyleUpdatePropertyMapCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StyleUpdatePropertyMapCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[28]);
}

// ===================================================================

class ShapeStyleSetValueCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapeStyleSetValueCommandArchive>()._impl_._has_bits_);
  static const ::TSD::BaseStyleSetValueCommandArchive& super(const ShapeStyleSetValueCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSWPSOS::ShapeStylePropertyChangeSetArchive& change(const ShapeStyleSetValueCommandArchive* msg);
  static void set_has_change(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::BaseStyleSetValueCommandArchive&
ShapeStyleSetValueCommandArchive::_Internal::super(const ShapeStyleSetValueCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSWPSOS::ShapeStylePropertyChangeSetArchive&
ShapeStyleSetValueCommandArchive::_Internal::change(const ShapeStyleSetValueCommandArchive* msg) {
  return *msg->_impl_.change_;
}
void ShapeStyleSetValueCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ShapeStyleSetValueCommandArchive::clear_change() {
  if (_impl_.change_ != nullptr) _impl_.change_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ShapeStyleSetValueCommandArchive::ShapeStyleSetValueCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ShapeStyleSetValueCommandArchive)
}
ShapeStyleSetValueCommandArchive::ShapeStyleSetValueCommandArchive(const ShapeStyleSetValueCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapeStyleSetValueCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.change_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::BaseStyleSetValueCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_change()) {
    _this->_impl_.change_ = new ::TSWPSOS::ShapeStylePropertyChangeSetArchive(*from._impl_.change_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.ShapeStyleSetValueCommandArchive)
}

inline void ShapeStyleSetValueCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.change_){nullptr}
  };
}

ShapeStyleSetValueCommandArchive::~ShapeStyleSetValueCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ShapeStyleSetValueCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeStyleSetValueCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.change_;
}

void ShapeStyleSetValueCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapeStyleSetValueCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ShapeStyleSetValueCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.change_ != nullptr);
      _impl_.change_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapeStyleSetValueCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.BaseStyleSetValueCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWPSOS.ShapeStylePropertyChangeSetArchive change = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_change(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeStyleSetValueCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ShapeStyleSetValueCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.BaseStyleSetValueCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSWPSOS.ShapeStylePropertyChangeSetArchive change = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::change(this),
        _Internal::change(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ShapeStyleSetValueCommandArchive)
  return target;
}

size_t ShapeStyleSetValueCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ShapeStyleSetValueCommandArchive)
  size_t total_size = 0;

  // required .TSD.BaseStyleSetValueCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSWPSOS.ShapeStylePropertyChangeSetArchive change = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.change_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapeStyleSetValueCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapeStyleSetValueCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapeStyleSetValueCommandArchive::GetClassData() const { return &_class_data_; }


void ShapeStyleSetValueCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapeStyleSetValueCommandArchive*>(&to_msg);
  auto& from = static_cast<const ShapeStyleSetValueCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ShapeStyleSetValueCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::BaseStyleSetValueCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_change()->::TSWPSOS::ShapeStylePropertyChangeSetArchive::MergeFrom(
          from._internal_change());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapeStyleSetValueCommandArchive::CopyFrom(const ShapeStyleSetValueCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ShapeStyleSetValueCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeStyleSetValueCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_change()) {
    if (!_impl_.change_->IsInitialized()) return false;
  }
  return true;
}

void ShapeStyleSetValueCommandArchive::InternalSwap(ShapeStyleSetValueCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShapeStyleSetValueCommandArchive, _impl_.change_)
      + sizeof(ShapeStyleSetValueCommandArchive::_impl_.change_)
      - PROTOBUF_FIELD_OFFSET(ShapeStyleSetValueCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapeStyleSetValueCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[29]);
}

// ===================================================================

class SelectionTransformerArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SelectionTransformerArchive>()._impl_._has_bits_);
  static const ::TSP::UUIDPath& storage_uuid_path(const SelectionTransformerArchive* msg);
  static void set_has_storage_uuid_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& selection(const SelectionTransformerArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_transformed_to_noop(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSP::UUIDPath&
SelectionTransformerArchive::_Internal::storage_uuid_path(const SelectionTransformerArchive* msg) {
  return *msg->_impl_.storage_uuid_path_;
}
const ::TSP::Reference&
SelectionTransformerArchive::_Internal::selection(const SelectionTransformerArchive* msg) {
  return *msg->_impl_.selection_;
}
void SelectionTransformerArchive::clear_storage_uuid_path() {
  if (_impl_.storage_uuid_path_ != nullptr) _impl_.storage_uuid_path_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void SelectionTransformerArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
SelectionTransformerArchive::SelectionTransformerArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.SelectionTransformerArchive)
}
SelectionTransformerArchive::SelectionTransformerArchive(const SelectionTransformerArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SelectionTransformerArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.storage_uuid_path_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.transformed_to_noop_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_storage_uuid_path()) {
    _this->_impl_.storage_uuid_path_ = new ::TSP::UUIDPath(*from._impl_.storage_uuid_path_);
  }
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TSP::Reference(*from._impl_.selection_);
  }
  _this->_impl_.transformed_to_noop_ = from._impl_.transformed_to_noop_;
  // @@protoc_insertion_point(copy_constructor:TSWP.SelectionTransformerArchive)
}

inline void SelectionTransformerArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.storage_uuid_path_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.transformed_to_noop_){false}
  };
}

SelectionTransformerArchive::~SelectionTransformerArchive() {
  // @@protoc_insertion_point(destructor:TSWP.SelectionTransformerArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectionTransformerArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.storage_uuid_path_;
  if (this != internal_default_instance()) delete _impl_.selection_;
}

void SelectionTransformerArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SelectionTransformerArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.SelectionTransformerArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.storage_uuid_path_ != nullptr);
      _impl_.storage_uuid_path_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
  }
  _impl_.transformed_to_noop_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SelectionTransformerArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.UUIDPath storage_uuid_path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage_uuid_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference selection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool transformed_to_noop = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_transformed_to_noop(&has_bits);
          _impl_.transformed_to_noop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectionTransformerArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.SelectionTransformerArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.UUIDPath storage_uuid_path = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::storage_uuid_path(this),
        _Internal::storage_uuid_path(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference selection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // optional bool transformed_to_noop = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_transformed_to_noop(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.SelectionTransformerArchive)
  return target;
}

size_t SelectionTransformerArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSWP.SelectionTransformerArchive)
  size_t total_size = 0;

  if (_internal_has_storage_uuid_path()) {
    // required .TSP.UUIDPath storage_uuid_path = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.storage_uuid_path_);
  }

  if (_internal_has_selection()) {
    // required .TSP.Reference selection = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  return total_size;
}
size_t SelectionTransformerArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.SelectionTransformerArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TSP.UUIDPath storage_uuid_path = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.storage_uuid_path_);

    // required .TSP.Reference selection = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool transformed_to_noop = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SelectionTransformerArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SelectionTransformerArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SelectionTransformerArchive::GetClassData() const { return &_class_data_; }


void SelectionTransformerArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SelectionTransformerArchive*>(&to_msg);
  auto& from = static_cast<const SelectionTransformerArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.SelectionTransformerArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_storage_uuid_path()->::TSP::UUIDPath::MergeFrom(
          from._internal_storage_uuid_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_selection()->::TSP::Reference::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.transformed_to_noop_ = from._impl_.transformed_to_noop_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SelectionTransformerArchive::CopyFrom(const SelectionTransformerArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.SelectionTransformerArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectionTransformerArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_storage_uuid_path()) {
    if (!_impl_.storage_uuid_path_->IsInitialized()) return false;
  }
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  return true;
}

void SelectionTransformerArchive::InternalSwap(SelectionTransformerArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SelectionTransformerArchive, _impl_.transformed_to_noop_)
      + sizeof(SelectionTransformerArchive::_impl_.transformed_to_noop_)
      - PROTOBUF_FIELD_OFFSET(SelectionTransformerArchive, _impl_.storage_uuid_path_)>(
          reinterpret_cast<char*>(&_impl_.storage_uuid_path_),
          reinterpret_cast<char*>(&other->_impl_.storage_uuid_path_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SelectionTransformerArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[30]);
}

// ===================================================================

class PencilAnnotationSelectionTransformerArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PencilAnnotationSelectionTransformerArchive>()._impl_._has_bits_);
  static const ::TSP::UUIDPath& storage_uuid_path(const PencilAnnotationSelectionTransformerArchive* msg);
  static void set_has_storage_uuid_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_text_pencil_annotation_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSP::UUIDPath&
PencilAnnotationSelectionTransformerArchive::_Internal::storage_uuid_path(const PencilAnnotationSelectionTransformerArchive* msg) {
  return *msg->_impl_.storage_uuid_path_;
}
void PencilAnnotationSelectionTransformerArchive::clear_storage_uuid_path() {
  if (_impl_.storage_uuid_path_ != nullptr) _impl_.storage_uuid_path_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
PencilAnnotationSelectionTransformerArchive::PencilAnnotationSelectionTransformerArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.PencilAnnotationSelectionTransformerArchive)
}
PencilAnnotationSelectionTransformerArchive::PencilAnnotationSelectionTransformerArchive(const PencilAnnotationSelectionTransformerArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PencilAnnotationSelectionTransformerArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_pencil_annotation_uuid_){}
    , decltype(_impl_.storage_uuid_path_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.text_pencil_annotation_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_pencil_annotation_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text_pencil_annotation_uuid()) {
    _this->_impl_.text_pencil_annotation_uuid_.Set(from._internal_text_pencil_annotation_uuid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_storage_uuid_path()) {
    _this->_impl_.storage_uuid_path_ = new ::TSP::UUIDPath(*from._impl_.storage_uuid_path_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.PencilAnnotationSelectionTransformerArchive)
}

inline void PencilAnnotationSelectionTransformerArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_pencil_annotation_uuid_){}
    , decltype(_impl_.storage_uuid_path_){nullptr}
  };
  _impl_.text_pencil_annotation_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_pencil_annotation_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PencilAnnotationSelectionTransformerArchive::~PencilAnnotationSelectionTransformerArchive() {
  // @@protoc_insertion_point(destructor:TSWP.PencilAnnotationSelectionTransformerArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PencilAnnotationSelectionTransformerArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_pencil_annotation_uuid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.storage_uuid_path_;
}

void PencilAnnotationSelectionTransformerArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PencilAnnotationSelectionTransformerArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.PencilAnnotationSelectionTransformerArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.text_pencil_annotation_uuid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_uuid_path_ != nullptr);
      _impl_.storage_uuid_path_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PencilAnnotationSelectionTransformerArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.UUIDPath storage_uuid_path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage_uuid_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string text_pencil_annotation_uuid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_text_pencil_annotation_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.PencilAnnotationSelectionTransformerArchive.text_pencil_annotation_uuid");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PencilAnnotationSelectionTransformerArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.PencilAnnotationSelectionTransformerArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.UUIDPath storage_uuid_path = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::storage_uuid_path(this),
        _Internal::storage_uuid_path(this).GetCachedSize(), target, stream);
  }

  // required string text_pencil_annotation_uuid = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_text_pencil_annotation_uuid().data(), static_cast<int>(this->_internal_text_pencil_annotation_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.PencilAnnotationSelectionTransformerArchive.text_pencil_annotation_uuid");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_text_pencil_annotation_uuid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.PencilAnnotationSelectionTransformerArchive)
  return target;
}

size_t PencilAnnotationSelectionTransformerArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSWP.PencilAnnotationSelectionTransformerArchive)
  size_t total_size = 0;

  if (_internal_has_text_pencil_annotation_uuid()) {
    // required string text_pencil_annotation_uuid = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text_pencil_annotation_uuid());
  }

  if (_internal_has_storage_uuid_path()) {
    // required .TSP.UUIDPath storage_uuid_path = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.storage_uuid_path_);
  }

  return total_size;
}
size_t PencilAnnotationSelectionTransformerArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.PencilAnnotationSelectionTransformerArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string text_pencil_annotation_uuid = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text_pencil_annotation_uuid());

    // required .TSP.UUIDPath storage_uuid_path = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.storage_uuid_path_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PencilAnnotationSelectionTransformerArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PencilAnnotationSelectionTransformerArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PencilAnnotationSelectionTransformerArchive::GetClassData() const { return &_class_data_; }


void PencilAnnotationSelectionTransformerArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PencilAnnotationSelectionTransformerArchive*>(&to_msg);
  auto& from = static_cast<const PencilAnnotationSelectionTransformerArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.PencilAnnotationSelectionTransformerArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_text_pencil_annotation_uuid(from._internal_text_pencil_annotation_uuid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage_uuid_path()->::TSP::UUIDPath::MergeFrom(
          from._internal_storage_uuid_path());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PencilAnnotationSelectionTransformerArchive::CopyFrom(const PencilAnnotationSelectionTransformerArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.PencilAnnotationSelectionTransformerArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PencilAnnotationSelectionTransformerArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_storage_uuid_path()) {
    if (!_impl_.storage_uuid_path_->IsInitialized()) return false;
  }
  return true;
}

void PencilAnnotationSelectionTransformerArchive::InternalSwap(PencilAnnotationSelectionTransformerArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_pencil_annotation_uuid_, lhs_arena,
      &other->_impl_.text_pencil_annotation_uuid_, rhs_arena
  );
  swap(_impl_.storage_uuid_path_, other->_impl_.storage_uuid_path_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PencilAnnotationSelectionTransformerArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[31]);
}

// ===================================================================

class ShapeSelectionTransformerArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapeSelectionTransformerArchive>()._impl_._has_bits_);
  static const ::TSD::ShapeSelectionTransformerArchive& super(const ShapeSelectionTransformerArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::UUIDPath& storage_uuid_path(const ShapeSelectionTransformerArchive* msg);
  static void set_has_storage_uuid_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::ShapeSelectionTransformerArchive&
ShapeSelectionTransformerArchive::_Internal::super(const ShapeSelectionTransformerArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::UUIDPath&
ShapeSelectionTransformerArchive::_Internal::storage_uuid_path(const ShapeSelectionTransformerArchive* msg) {
  return *msg->_impl_.storage_uuid_path_;
}
void ShapeSelectionTransformerArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ShapeSelectionTransformerArchive::clear_storage_uuid_path() {
  if (_impl_.storage_uuid_path_ != nullptr) _impl_.storage_uuid_path_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ShapeSelectionTransformerArchive::ShapeSelectionTransformerArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ShapeSelectionTransformerArchive)
}
ShapeSelectionTransformerArchive::ShapeSelectionTransformerArchive(const ShapeSelectionTransformerArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapeSelectionTransformerArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_uuid_path_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::ShapeSelectionTransformerArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage_uuid_path()) {
    _this->_impl_.storage_uuid_path_ = new ::TSP::UUIDPath(*from._impl_.storage_uuid_path_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.ShapeSelectionTransformerArchive)
}

inline void ShapeSelectionTransformerArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_uuid_path_){nullptr}
  };
}

ShapeSelectionTransformerArchive::~ShapeSelectionTransformerArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ShapeSelectionTransformerArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeSelectionTransformerArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_uuid_path_;
}

void ShapeSelectionTransformerArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapeSelectionTransformerArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ShapeSelectionTransformerArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_uuid_path_ != nullptr);
      _impl_.storage_uuid_path_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapeSelectionTransformerArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.ShapeSelectionTransformerArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.UUIDPath storage_uuid_path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage_uuid_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeSelectionTransformerArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ShapeSelectionTransformerArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.ShapeSelectionTransformerArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.UUIDPath storage_uuid_path = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage_uuid_path(this),
        _Internal::storage_uuid_path(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ShapeSelectionTransformerArchive)
  return target;
}

size_t ShapeSelectionTransformerArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ShapeSelectionTransformerArchive)
  size_t total_size = 0;

  // required .TSD.ShapeSelectionTransformerArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.UUIDPath storage_uuid_path = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.storage_uuid_path_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapeSelectionTransformerArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapeSelectionTransformerArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapeSelectionTransformerArchive::GetClassData() const { return &_class_data_; }


void ShapeSelectionTransformerArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapeSelectionTransformerArchive*>(&to_msg);
  auto& from = static_cast<const ShapeSelectionTransformerArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ShapeSelectionTransformerArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::ShapeSelectionTransformerArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage_uuid_path()->::TSP::UUIDPath::MergeFrom(
          from._internal_storage_uuid_path());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapeSelectionTransformerArchive::CopyFrom(const ShapeSelectionTransformerArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ShapeSelectionTransformerArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeSelectionTransformerArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage_uuid_path()) {
    if (!_impl_.storage_uuid_path_->IsInitialized()) return false;
  }
  return true;
}

void ShapeSelectionTransformerArchive::InternalSwap(ShapeSelectionTransformerArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShapeSelectionTransformerArchive, _impl_.storage_uuid_path_)
      + sizeof(ShapeSelectionTransformerArchive::_impl_.storage_uuid_path_)
      - PROTOBUF_FIELD_OFFSET(ShapeSelectionTransformerArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapeSelectionTransformerArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[32]);
}

// ===================================================================

class ShapeContentDescription::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapeContentDescription>()._impl_._has_bits_);
  static const ::TSD::DrawableContentDescription& super(const ShapeContentDescription* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_text_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_text_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::DrawableContentDescription&
ShapeContentDescription::_Internal::super(const ShapeContentDescription* msg) {
  return *msg->_impl_.super_;
}
void ShapeContentDescription::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ShapeContentDescription::ShapeContentDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ShapeContentDescription)
}
ShapeContentDescription::ShapeContentDescription(const ShapeContentDescription& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapeContentDescription* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.text_range_location_){}
    , decltype(_impl_.text_range_length_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::DrawableContentDescription(*from._impl_.super_);
  }
  ::memcpy(&_impl_.text_range_location_, &from._impl_.text_range_location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.text_range_length_) -
    reinterpret_cast<char*>(&_impl_.text_range_location_)) + sizeof(_impl_.text_range_length_));
  // @@protoc_insertion_point(copy_constructor:TSWP.ShapeContentDescription)
}

inline void ShapeContentDescription::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.text_range_location_){0u}
    , decltype(_impl_.text_range_length_){0u}
  };
}

ShapeContentDescription::~ShapeContentDescription() {
  // @@protoc_insertion_point(destructor:TSWP.ShapeContentDescription)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeContentDescription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ShapeContentDescription::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapeContentDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ShapeContentDescription)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.text_range_location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.text_range_length_) -
        reinterpret_cast<char*>(&_impl_.text_range_location_)) + sizeof(_impl_.text_range_length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapeContentDescription::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.DrawableContentDescription super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 text_range_location = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_text_range_location(&has_bits);
          _impl_.text_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 text_range_length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_text_range_length(&has_bits);
          _impl_.text_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeContentDescription::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ShapeContentDescription)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.DrawableContentDescription super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 text_range_location = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_text_range_location(), target);
  }

  // optional uint32 text_range_length = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_text_range_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ShapeContentDescription)
  return target;
}

size_t ShapeContentDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ShapeContentDescription)
  size_t total_size = 0;

  // required .TSD.DrawableContentDescription super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint32 text_range_location = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_text_range_location());
    }

    // optional uint32 text_range_length = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_text_range_length());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapeContentDescription::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapeContentDescription::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapeContentDescription::GetClassData() const { return &_class_data_; }


void ShapeContentDescription::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapeContentDescription*>(&to_msg);
  auto& from = static_cast<const ShapeContentDescription&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ShapeContentDescription)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::DrawableContentDescription::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.text_range_location_ = from._impl_.text_range_location_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.text_range_length_ = from._impl_.text_range_length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapeContentDescription::CopyFrom(const ShapeContentDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ShapeContentDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeContentDescription::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ShapeContentDescription::InternalSwap(ShapeContentDescription* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShapeContentDescription, _impl_.text_range_length_)
      + sizeof(ShapeContentDescription::_impl_.text_range_length_)
      - PROTOBUF_FIELD_OFFSET(ShapeContentDescription, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapeContentDescription::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[33]);
}

// ===================================================================

class ObjectPropertyArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ObjectPropertyArchive>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_bool_value(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_float_value(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_integer_value(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_string_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::UUIDPath& id_path_value(const ObjectPropertyArchive* msg);
  static void set_has_id_path_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::FillArchive& fill_value(const ObjectPropertyArchive* msg);
  static void set_has_fill_value(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Color& color_value(const ObjectPropertyArchive* msg);
  static void set_has_color_value(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSD::ShadowArchive& shadow_value(const ObjectPropertyArchive* msg);
  static void set_has_shadow_value(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000041) ^ 0x00000041) != 0;
  }
};

const ::TSP::UUIDPath&
ObjectPropertyArchive::_Internal::id_path_value(const ObjectPropertyArchive* msg) {
  return *msg->_impl_.id_path_value_;
}
const ::TSD::FillArchive&
ObjectPropertyArchive::_Internal::fill_value(const ObjectPropertyArchive* msg) {
  return *msg->_impl_.fill_value_;
}
const ::TSP::Color&
ObjectPropertyArchive::_Internal::color_value(const ObjectPropertyArchive* msg) {
  return *msg->_impl_.color_value_;
}
const ::TSD::ShadowArchive&
ObjectPropertyArchive::_Internal::shadow_value(const ObjectPropertyArchive* msg) {
  return *msg->_impl_.shadow_value_;
}
void ObjectPropertyArchive::clear_id_path_value() {
  if (_impl_.id_path_value_ != nullptr) _impl_.id_path_value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ObjectPropertyArchive::clear_fill_value() {
  if (_impl_.fill_value_ != nullptr) _impl_.fill_value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void ObjectPropertyArchive::clear_color_value() {
  if (_impl_.color_value_ != nullptr) _impl_.color_value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void ObjectPropertyArchive::clear_shadow_value() {
  if (_impl_.shadow_value_ != nullptr) _impl_.shadow_value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
ObjectPropertyArchive::ObjectPropertyArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ObjectPropertyArchive)
}
ObjectPropertyArchive::ObjectPropertyArchive(const ObjectPropertyArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ObjectPropertyArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.string_value_){}
    , decltype(_impl_.id_path_value_){nullptr}
    , decltype(_impl_.fill_value_){nullptr}
    , decltype(_impl_.color_value_){nullptr}
    , decltype(_impl_.shadow_value_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.bool_value_){}
    , decltype(_impl_.float_value_){}
    , decltype(_impl_.integer_value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.string_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_string_value()) {
    _this->_impl_.string_value_.Set(from._internal_string_value(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_id_path_value()) {
    _this->_impl_.id_path_value_ = new ::TSP::UUIDPath(*from._impl_.id_path_value_);
  }
  if (from._internal_has_fill_value()) {
    _this->_impl_.fill_value_ = new ::TSD::FillArchive(*from._impl_.fill_value_);
  }
  if (from._internal_has_color_value()) {
    _this->_impl_.color_value_ = new ::TSP::Color(*from._impl_.color_value_);
  }
  if (from._internal_has_shadow_value()) {
    _this->_impl_.shadow_value_ = new ::TSD::ShadowArchive(*from._impl_.shadow_value_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.integer_value_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.integer_value_));
  // @@protoc_insertion_point(copy_constructor:TSWP.ObjectPropertyArchive)
}

inline void ObjectPropertyArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.string_value_){}
    , decltype(_impl_.id_path_value_){nullptr}
    , decltype(_impl_.fill_value_){nullptr}
    , decltype(_impl_.color_value_){nullptr}
    , decltype(_impl_.shadow_value_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.bool_value_){false}
    , decltype(_impl_.float_value_){0}
    , decltype(_impl_.integer_value_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.string_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ObjectPropertyArchive::~ObjectPropertyArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ObjectPropertyArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ObjectPropertyArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.string_value_.Destroy();
  if (this != internal_default_instance()) delete _impl_.id_path_value_;
  if (this != internal_default_instance()) delete _impl_.fill_value_;
  if (this != internal_default_instance()) delete _impl_.color_value_;
  if (this != internal_default_instance()) delete _impl_.shadow_value_;
}

void ObjectPropertyArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ObjectPropertyArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ObjectPropertyArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.string_value_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.id_path_value_ != nullptr);
      _impl_.id_path_value_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.fill_value_ != nullptr);
      _impl_.fill_value_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.color_value_ != nullptr);
      _impl_.color_value_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.shadow_value_ != nullptr);
      _impl_.shadow_value_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bool_value_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.bool_value_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.float_value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.integer_value_) -
        reinterpret_cast<char*>(&_impl_.float_value_)) + sizeof(_impl_.integer_value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectPropertyArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.ObjectPropertyArchive.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required .TSWP.ObjectPropertyType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSWP::ObjectPropertyType_IsValid(val))) {
            _internal_set_type(static_cast<::TSWP::ObjectPropertyType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool bool_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_bool_value(&has_bits);
          _impl_.bool_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float float_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_float_value(&has_bits);
          _impl_.float_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 integer_value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_integer_value(&has_bits);
          _impl_.integer_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string string_value = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_string_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.ObjectPropertyArchive.string_value");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.UUIDPath id_path_value = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_id_path_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.FillArchive fill_value = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_fill_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Color color_value = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_color_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ShadowArchive shadow_value = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_shadow_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectPropertyArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ObjectPropertyArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.ObjectPropertyArchive.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required .TSWP.ObjectPropertyType type = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional bool bool_value = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_bool_value(), target);
  }

  // optional float float_value = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_float_value(), target);
  }

  // optional int32 integer_value = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_integer_value(), target);
  }

  // optional string string_value = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_string_value().data(), static_cast<int>(this->_internal_string_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.ObjectPropertyArchive.string_value");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_string_value(), target);
  }

  // optional .TSP.UUIDPath id_path_value = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::id_path_value(this),
        _Internal::id_path_value(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.FillArchive fill_value = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::fill_value(this),
        _Internal::fill_value(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Color color_value = 9;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::color_value(this),
        _Internal::color_value(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ShadowArchive shadow_value = 10;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::shadow_value(this),
        _Internal::shadow_value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ObjectPropertyArchive)
  return target;
}

size_t ObjectPropertyArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSWP.ObjectPropertyArchive)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_type()) {
    // required .TSWP.ObjectPropertyType type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t ObjectPropertyArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ObjectPropertyArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000041) ^ 0x00000041) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required .TSWP.ObjectPropertyType type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003eu) {
    // optional string string_value = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_string_value());
    }

    // optional .TSP.UUIDPath id_path_value = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.id_path_value_);
    }

    // optional .TSD.FillArchive fill_value = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fill_value_);
    }

    // optional .TSP.Color color_value = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.color_value_);
    }

    // optional .TSD.ShadowArchive shadow_value = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shadow_value_);
    }

  }
  // optional bool bool_value = 3;
  if (cached_has_bits & 0x00000080u) {
    total_size += 1 + 1;
  }

  if (cached_has_bits & 0x00000300u) {
    // optional float float_value = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional int32 integer_value = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_integer_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectPropertyArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ObjectPropertyArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectPropertyArchive::GetClassData() const { return &_class_data_; }


void ObjectPropertyArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ObjectPropertyArchive*>(&to_msg);
  auto& from = static_cast<const ObjectPropertyArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ObjectPropertyArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_string_value(from._internal_string_value());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_id_path_value()->::TSP::UUIDPath::MergeFrom(
          from._internal_id_path_value());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_fill_value()->::TSD::FillArchive::MergeFrom(
          from._internal_fill_value());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_color_value()->::TSP::Color::MergeFrom(
          from._internal_color_value());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_shadow_value()->::TSD::ShadowArchive::MergeFrom(
          from._internal_shadow_value());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.bool_value_ = from._impl_.bool_value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.float_value_ = from._impl_.float_value_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.integer_value_ = from._impl_.integer_value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectPropertyArchive::CopyFrom(const ObjectPropertyArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ObjectPropertyArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectPropertyArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_id_path_value()) {
    if (!_impl_.id_path_value_->IsInitialized()) return false;
  }
  if (_internal_has_fill_value()) {
    if (!_impl_.fill_value_->IsInitialized()) return false;
  }
  if (_internal_has_color_value()) {
    if (!_impl_.color_value_->IsInitialized()) return false;
  }
  if (_internal_has_shadow_value()) {
    if (!_impl_.shadow_value_->IsInitialized()) return false;
  }
  return true;
}

void ObjectPropertyArchive::InternalSwap(ObjectPropertyArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.string_value_, lhs_arena,
      &other->_impl_.string_value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ObjectPropertyArchive, _impl_.integer_value_)
      + sizeof(ObjectPropertyArchive::_impl_.integer_value_)
      - PROTOBUF_FIELD_OFFSET(ObjectPropertyArchive, _impl_.id_path_value_)>(
          reinterpret_cast<char*>(&_impl_.id_path_value_),
          reinterpret_cast<char*>(&other->_impl_.id_path_value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectPropertyArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[34]);
}

// ===================================================================

class SetObjectPropertiesCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SetObjectPropertiesCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const SetObjectPropertiesCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::UUIDPath& object_uuid_path(const SetObjectPropertiesCommandArchive* msg);
  static void set_has_object_uuid_path(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_action_string(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

const ::TSK::CommandArchive&
SetObjectPropertiesCommandArchive::_Internal::super(const SetObjectPropertiesCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::UUIDPath&
SetObjectPropertiesCommandArchive::_Internal::object_uuid_path(const SetObjectPropertiesCommandArchive* msg) {
  return *msg->_impl_.object_uuid_path_;
}
void SetObjectPropertiesCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void SetObjectPropertiesCommandArchive::clear_object_uuid_path() {
  if (_impl_.object_uuid_path_ != nullptr) _impl_.object_uuid_path_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
SetObjectPropertiesCommandArchive::SetObjectPropertiesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.SetObjectPropertiesCommandArchive)
}
SetObjectPropertiesCommandArchive::SetObjectPropertiesCommandArchive(const SetObjectPropertiesCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetObjectPropertiesCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.properties_){from._impl_.properties_}
    , decltype(_impl_.old_properties_){from._impl_.old_properties_}
    , decltype(_impl_.action_string_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.object_uuid_path_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.action_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.action_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_action_string()) {
    _this->_impl_.action_string_.Set(from._internal_action_string(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_object_uuid_path()) {
    _this->_impl_.object_uuid_path_ = new ::TSP::UUIDPath(*from._impl_.object_uuid_path_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.SetObjectPropertiesCommandArchive)
}

inline void SetObjectPropertiesCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.properties_){arena}
    , decltype(_impl_.old_properties_){arena}
    , decltype(_impl_.action_string_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.object_uuid_path_){nullptr}
  };
  _impl_.action_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.action_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SetObjectPropertiesCommandArchive::~SetObjectPropertiesCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.SetObjectPropertiesCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetObjectPropertiesCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.properties_.~RepeatedPtrField();
  _impl_.old_properties_.~RepeatedPtrField();
  _impl_.action_string_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.object_uuid_path_;
}

void SetObjectPropertiesCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetObjectPropertiesCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.SetObjectPropertiesCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.properties_.Clear();
  _impl_.old_properties_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.action_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.object_uuid_path_ != nullptr);
      _impl_.object_uuid_path_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetObjectPropertiesCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.UUIDPath object_uuid_path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_object_uuid_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSWP.ObjectPropertyArchive properties = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string action_string = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_action_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.SetObjectPropertiesCommandArchive.action_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .TSWP.ObjectPropertyArchive old_properties = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_old_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetObjectPropertiesCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.SetObjectPropertiesCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSP.UUIDPath object_uuid_path = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::object_uuid_path(this),
        _Internal::object_uuid_path(this).GetCachedSize(), target, stream);
  }

  // repeated .TSWP.ObjectPropertyArchive properties = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string action_string = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_action_string().data(), static_cast<int>(this->_internal_action_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.SetObjectPropertiesCommandArchive.action_string");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_action_string(), target);
  }

  // repeated .TSWP.ObjectPropertyArchive old_properties = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_old_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_old_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.SetObjectPropertiesCommandArchive)
  return target;
}

size_t SetObjectPropertiesCommandArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSWP.SetObjectPropertiesCommandArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_object_uuid_path()) {
    // required .TSP.UUIDPath object_uuid_path = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.object_uuid_path_);
  }

  return total_size;
}
size_t SetObjectPropertiesCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.SetObjectPropertiesCommandArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSP.UUIDPath object_uuid_path = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.object_uuid_path_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSWP.ObjectPropertyArchive properties = 3;
  total_size += 1UL * this->_internal_properties_size();
  for (const auto& msg : this->_impl_.properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSWP.ObjectPropertyArchive old_properties = 5;
  total_size += 1UL * this->_internal_old_properties_size();
  for (const auto& msg : this->_impl_.old_properties_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string action_string = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_action_string());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetObjectPropertiesCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetObjectPropertiesCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetObjectPropertiesCommandArchive::GetClassData() const { return &_class_data_; }


void SetObjectPropertiesCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetObjectPropertiesCommandArchive*>(&to_msg);
  auto& from = static_cast<const SetObjectPropertiesCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.SetObjectPropertiesCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.properties_.MergeFrom(from._impl_.properties_);
  _this->_impl_.old_properties_.MergeFrom(from._impl_.old_properties_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_action_string(from._internal_action_string());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_object_uuid_path()->::TSP::UUIDPath::MergeFrom(
          from._internal_object_uuid_path());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetObjectPropertiesCommandArchive::CopyFrom(const SetObjectPropertiesCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.SetObjectPropertiesCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetObjectPropertiesCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.properties_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.old_properties_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_object_uuid_path()) {
    if (!_impl_.object_uuid_path_->IsInitialized()) return false;
  }
  return true;
}

void SetObjectPropertiesCommandArchive::InternalSwap(SetObjectPropertiesCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.properties_.InternalSwap(&other->_impl_.properties_);
  _impl_.old_properties_.InternalSwap(&other->_impl_.old_properties_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.action_string_, lhs_arena,
      &other->_impl_.action_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetObjectPropertiesCommandArchive, _impl_.object_uuid_path_)
      + sizeof(SetObjectPropertiesCommandArchive::_impl_.object_uuid_path_)
      - PROTOBUF_FIELD_OFFSET(SetObjectPropertiesCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetObjectPropertiesCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[35]);
}

// ===================================================================

class UpdateFlowInfoCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<UpdateFlowInfoCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const UpdateFlowInfoCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_command_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::UUIDPath& flow_info_uuid_path(const UpdateFlowInfoCommandArchive* msg);
  static void set_has_flow_info_uuid_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::UUIDPath& text_box_id_path_to_add_or_remove(const UpdateFlowInfoCommandArchive* msg);
  static void set_has_text_box_id_path_to_add_or_remove(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& undo_added_shape_info(const UpdateFlowInfoCommandArchive* msg);
  static void set_has_undo_added_shape_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& undo_removed_shape_info(const UpdateFlowInfoCommandArchive* msg);
  static void set_has_undo_removed_shape_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::TSK::CommandArchive&
UpdateFlowInfoCommandArchive::_Internal::super(const UpdateFlowInfoCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::UUIDPath&
UpdateFlowInfoCommandArchive::_Internal::flow_info_uuid_path(const UpdateFlowInfoCommandArchive* msg) {
  return *msg->_impl_.flow_info_uuid_path_;
}
const ::TSP::UUIDPath&
UpdateFlowInfoCommandArchive::_Internal::text_box_id_path_to_add_or_remove(const UpdateFlowInfoCommandArchive* msg) {
  return *msg->_impl_.text_box_id_path_to_add_or_remove_;
}
const ::TSP::Reference&
UpdateFlowInfoCommandArchive::_Internal::undo_added_shape_info(const UpdateFlowInfoCommandArchive* msg) {
  return *msg->_impl_.undo_added_shape_info_;
}
const ::TSP::Reference&
UpdateFlowInfoCommandArchive::_Internal::undo_removed_shape_info(const UpdateFlowInfoCommandArchive* msg) {
  return *msg->_impl_.undo_removed_shape_info_;
}
void UpdateFlowInfoCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void UpdateFlowInfoCommandArchive::clear_flow_info_uuid_path() {
  if (_impl_.flow_info_uuid_path_ != nullptr) _impl_.flow_info_uuid_path_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void UpdateFlowInfoCommandArchive::clear_text_box_id_path_to_add_or_remove() {
  if (_impl_.text_box_id_path_to_add_or_remove_ != nullptr) _impl_.text_box_id_path_to_add_or_remove_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void UpdateFlowInfoCommandArchive::clear_text_box_id_paths_at_start() {
  _impl_.text_box_id_paths_at_start_.Clear();
}
void UpdateFlowInfoCommandArchive::clear_suggested_text_box_id_paths_at_end() {
  _impl_.suggested_text_box_id_paths_at_end_.Clear();
}
void UpdateFlowInfoCommandArchive::clear_undo_text_boxes_to_restore() {
  _impl_.undo_text_boxes_to_restore_.Clear();
}
void UpdateFlowInfoCommandArchive::clear_undo_added_shape_info() {
  if (_impl_.undo_added_shape_info_ != nullptr) _impl_.undo_added_shape_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void UpdateFlowInfoCommandArchive::clear_undo_removed_shape_info() {
  if (_impl_.undo_removed_shape_info_ != nullptr) _impl_.undo_removed_shape_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
UpdateFlowInfoCommandArchive::UpdateFlowInfoCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.UpdateFlowInfoCommandArchive)
}
UpdateFlowInfoCommandArchive::UpdateFlowInfoCommandArchive(const UpdateFlowInfoCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateFlowInfoCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_box_id_paths_at_start_){from._impl_.text_box_id_paths_at_start_}
    , decltype(_impl_.suggested_text_box_id_paths_at_end_){from._impl_.suggested_text_box_id_paths_at_end_}
    , decltype(_impl_.undo_text_boxes_to_restore_){from._impl_.undo_text_boxes_to_restore_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.flow_info_uuid_path_){nullptr}
    , decltype(_impl_.text_box_id_path_to_add_or_remove_){nullptr}
    , decltype(_impl_.undo_added_shape_info_){nullptr}
    , decltype(_impl_.undo_removed_shape_info_){nullptr}
    , decltype(_impl_.command_mode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_flow_info_uuid_path()) {
    _this->_impl_.flow_info_uuid_path_ = new ::TSP::UUIDPath(*from._impl_.flow_info_uuid_path_);
  }
  if (from._internal_has_text_box_id_path_to_add_or_remove()) {
    _this->_impl_.text_box_id_path_to_add_or_remove_ = new ::TSP::UUIDPath(*from._impl_.text_box_id_path_to_add_or_remove_);
  }
  if (from._internal_has_undo_added_shape_info()) {
    _this->_impl_.undo_added_shape_info_ = new ::TSP::Reference(*from._impl_.undo_added_shape_info_);
  }
  if (from._internal_has_undo_removed_shape_info()) {
    _this->_impl_.undo_removed_shape_info_ = new ::TSP::Reference(*from._impl_.undo_removed_shape_info_);
  }
  _this->_impl_.command_mode_ = from._impl_.command_mode_;
  // @@protoc_insertion_point(copy_constructor:TSWP.UpdateFlowInfoCommandArchive)
}

inline void UpdateFlowInfoCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_box_id_paths_at_start_){arena}
    , decltype(_impl_.suggested_text_box_id_paths_at_end_){arena}
    , decltype(_impl_.undo_text_boxes_to_restore_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.flow_info_uuid_path_){nullptr}
    , decltype(_impl_.text_box_id_path_to_add_or_remove_){nullptr}
    , decltype(_impl_.undo_added_shape_info_){nullptr}
    , decltype(_impl_.undo_removed_shape_info_){nullptr}
    , decltype(_impl_.command_mode_){0}
  };
}

UpdateFlowInfoCommandArchive::~UpdateFlowInfoCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.UpdateFlowInfoCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateFlowInfoCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_box_id_paths_at_start_.~RepeatedPtrField();
  _impl_.suggested_text_box_id_paths_at_end_.~RepeatedPtrField();
  _impl_.undo_text_boxes_to_restore_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.flow_info_uuid_path_;
  if (this != internal_default_instance()) delete _impl_.text_box_id_path_to_add_or_remove_;
  if (this != internal_default_instance()) delete _impl_.undo_added_shape_info_;
  if (this != internal_default_instance()) delete _impl_.undo_removed_shape_info_;
}

void UpdateFlowInfoCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateFlowInfoCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.UpdateFlowInfoCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.text_box_id_paths_at_start_.Clear();
  _impl_.suggested_text_box_id_paths_at_end_.Clear();
  _impl_.undo_text_boxes_to_restore_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.flow_info_uuid_path_ != nullptr);
      _impl_.flow_info_uuid_path_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.text_box_id_path_to_add_or_remove_ != nullptr);
      _impl_.text_box_id_path_to_add_or_remove_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.undo_added_shape_info_ != nullptr);
      _impl_.undo_added_shape_info_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.undo_removed_shape_info_ != nullptr);
      _impl_.undo_removed_shape_info_->Clear();
    }
  }
  _impl_.command_mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateFlowInfoCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UpdateFlowInfoCommandArchive.Mode command_mode = 2 [default = kModeRearrange];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSWP::UpdateFlowInfoCommandArchive_Mode_IsValid(val))) {
            _internal_set_command_mode(static_cast<::TSWP::UpdateFlowInfoCommandArchive_Mode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.UUIDPath flow_info_uuid_path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_flow_info_uuid_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.UUIDPath text_box_id_path_to_add_or_remove = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_box_id_path_to_add_or_remove(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.UUIDPath text_box_id_paths_at_start = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_text_box_id_paths_at_start(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.UUIDPath suggested_text_box_id_paths_at_end = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_suggested_text_box_id_paths_at_end(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference undo_text_boxes_to_restore = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_undo_text_boxes_to_restore(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference undo_added_shape_info = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_added_shape_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference undo_removed_shape_info = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_removed_shape_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateFlowInfoCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.UpdateFlowInfoCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UpdateFlowInfoCommandArchive.Mode command_mode = 2 [default = kModeRearrange];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_command_mode(), target);
  }

  // optional .TSP.UUIDPath flow_info_uuid_path = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::flow_info_uuid_path(this),
        _Internal::flow_info_uuid_path(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.UUIDPath text_box_id_path_to_add_or_remove = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::text_box_id_path_to_add_or_remove(this),
        _Internal::text_box_id_path_to_add_or_remove(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.UUIDPath text_box_id_paths_at_start = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_text_box_id_paths_at_start_size()); i < n; i++) {
    const auto& repfield = this->_internal_text_box_id_paths_at_start(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.UUIDPath suggested_text_box_id_paths_at_end = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_suggested_text_box_id_paths_at_end_size()); i < n; i++) {
    const auto& repfield = this->_internal_suggested_text_box_id_paths_at_end(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference undo_text_boxes_to_restore = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_undo_text_boxes_to_restore_size()); i < n; i++) {
    const auto& repfield = this->_internal_undo_text_boxes_to_restore(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference undo_added_shape_info = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::undo_added_shape_info(this),
        _Internal::undo_added_shape_info(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference undo_removed_shape_info = 9;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::undo_removed_shape_info(this),
        _Internal::undo_removed_shape_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.UpdateFlowInfoCommandArchive)
  return target;
}

size_t UpdateFlowInfoCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.UpdateFlowInfoCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.UUIDPath text_box_id_paths_at_start = 5;
  total_size += 1UL * this->_internal_text_box_id_paths_at_start_size();
  for (const auto& msg : this->_impl_.text_box_id_paths_at_start_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.UUIDPath suggested_text_box_id_paths_at_end = 6;
  total_size += 1UL * this->_internal_suggested_text_box_id_paths_at_end_size();
  for (const auto& msg : this->_impl_.suggested_text_box_id_paths_at_end_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference undo_text_boxes_to_restore = 7;
  total_size += 1UL * this->_internal_undo_text_boxes_to_restore_size();
  for (const auto& msg : this->_impl_.undo_text_boxes_to_restore_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.UUIDPath flow_info_uuid_path = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.flow_info_uuid_path_);
    }

    // optional .TSP.UUIDPath text_box_id_path_to_add_or_remove = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.text_box_id_path_to_add_or_remove_);
    }

    // optional .TSP.Reference undo_added_shape_info = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_added_shape_info_);
    }

    // optional .TSP.Reference undo_removed_shape_info = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_removed_shape_info_);
    }

    // optional .TSWP.UpdateFlowInfoCommandArchive.Mode command_mode = 2 [default = kModeRearrange];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_command_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateFlowInfoCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateFlowInfoCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateFlowInfoCommandArchive::GetClassData() const { return &_class_data_; }


void UpdateFlowInfoCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateFlowInfoCommandArchive*>(&to_msg);
  auto& from = static_cast<const UpdateFlowInfoCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.UpdateFlowInfoCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.text_box_id_paths_at_start_.MergeFrom(from._impl_.text_box_id_paths_at_start_);
  _this->_impl_.suggested_text_box_id_paths_at_end_.MergeFrom(from._impl_.suggested_text_box_id_paths_at_end_);
  _this->_impl_.undo_text_boxes_to_restore_.MergeFrom(from._impl_.undo_text_boxes_to_restore_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_flow_info_uuid_path()->::TSP::UUIDPath::MergeFrom(
          from._internal_flow_info_uuid_path());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_text_box_id_path_to_add_or_remove()->::TSP::UUIDPath::MergeFrom(
          from._internal_text_box_id_path_to_add_or_remove());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_undo_added_shape_info()->::TSP::Reference::MergeFrom(
          from._internal_undo_added_shape_info());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_undo_removed_shape_info()->::TSP::Reference::MergeFrom(
          from._internal_undo_removed_shape_info());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.command_mode_ = from._impl_.command_mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateFlowInfoCommandArchive::CopyFrom(const UpdateFlowInfoCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.UpdateFlowInfoCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateFlowInfoCommandArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.text_box_id_paths_at_start_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.suggested_text_box_id_paths_at_end_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.undo_text_boxes_to_restore_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_flow_info_uuid_path()) {
    if (!_impl_.flow_info_uuid_path_->IsInitialized()) return false;
  }
  if (_internal_has_text_box_id_path_to_add_or_remove()) {
    if (!_impl_.text_box_id_path_to_add_or_remove_->IsInitialized()) return false;
  }
  if (_internal_has_undo_added_shape_info()) {
    if (!_impl_.undo_added_shape_info_->IsInitialized()) return false;
  }
  if (_internal_has_undo_removed_shape_info()) {
    if (!_impl_.undo_removed_shape_info_->IsInitialized()) return false;
  }
  return true;
}

void UpdateFlowInfoCommandArchive::InternalSwap(UpdateFlowInfoCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.text_box_id_paths_at_start_.InternalSwap(&other->_impl_.text_box_id_paths_at_start_);
  _impl_.suggested_text_box_id_paths_at_end_.InternalSwap(&other->_impl_.suggested_text_box_id_paths_at_end_);
  _impl_.undo_text_boxes_to_restore_.InternalSwap(&other->_impl_.undo_text_boxes_to_restore_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateFlowInfoCommandArchive, _impl_.command_mode_)
      + sizeof(UpdateFlowInfoCommandArchive::_impl_.command_mode_)
      - PROTOBUF_FIELD_OFFSET(UpdateFlowInfoCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateFlowInfoCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[36]);
}

// ===================================================================

class AddFlowInfoCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<AddFlowInfoCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const AddFlowInfoCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& flow_info_to_add(const AddFlowInfoCommandArchive* msg);
  static void set_has_flow_info_to_add(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& flow_info_archive(const AddFlowInfoCommandArchive* msg);
  static void set_has_flow_info_archive(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_undo_user_interface_identifier_to_restore(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_undo_next_user_interface_identifier_to_restore(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::Reference& working_undo_object(const AddFlowInfoCommandArchive* msg);
  static void set_has_working_undo_object(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::TSK::CommandArchive&
AddFlowInfoCommandArchive::_Internal::super(const AddFlowInfoCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
AddFlowInfoCommandArchive::_Internal::flow_info_to_add(const AddFlowInfoCommandArchive* msg) {
  return *msg->_impl_.flow_info_to_add_;
}
const ::TSP::Reference&
AddFlowInfoCommandArchive::_Internal::flow_info_archive(const AddFlowInfoCommandArchive* msg) {
  return *msg->_impl_.flow_info_archive_;
}
const ::TSP::Reference&
AddFlowInfoCommandArchive::_Internal::working_undo_object(const AddFlowInfoCommandArchive* msg) {
  return *msg->_impl_.working_undo_object_;
}
void AddFlowInfoCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void AddFlowInfoCommandArchive::clear_flow_info_to_add() {
  if (_impl_.flow_info_to_add_ != nullptr) _impl_.flow_info_to_add_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void AddFlowInfoCommandArchive::clear_flow_info_archive() {
  if (_impl_.flow_info_archive_ != nullptr) _impl_.flow_info_archive_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void AddFlowInfoCommandArchive::clear_working_undo_object() {
  if (_impl_.working_undo_object_ != nullptr) _impl_.working_undo_object_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
AddFlowInfoCommandArchive::AddFlowInfoCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.AddFlowInfoCommandArchive)
}
AddFlowInfoCommandArchive::AddFlowInfoCommandArchive(const AddFlowInfoCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddFlowInfoCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.flow_info_to_add_){nullptr}
    , decltype(_impl_.flow_info_archive_){nullptr}
    , decltype(_impl_.working_undo_object_){nullptr}
    , decltype(_impl_.undo_user_interface_identifier_to_restore_){}
    , decltype(_impl_.undo_next_user_interface_identifier_to_restore_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_flow_info_to_add()) {
    _this->_impl_.flow_info_to_add_ = new ::TSP::Reference(*from._impl_.flow_info_to_add_);
  }
  if (from._internal_has_flow_info_archive()) {
    _this->_impl_.flow_info_archive_ = new ::TSP::Reference(*from._impl_.flow_info_archive_);
  }
  if (from._internal_has_working_undo_object()) {
    _this->_impl_.working_undo_object_ = new ::TSP::Reference(*from._impl_.working_undo_object_);
  }
  ::memcpy(&_impl_.undo_user_interface_identifier_to_restore_, &from._impl_.undo_user_interface_identifier_to_restore_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.undo_next_user_interface_identifier_to_restore_) -
    reinterpret_cast<char*>(&_impl_.undo_user_interface_identifier_to_restore_)) + sizeof(_impl_.undo_next_user_interface_identifier_to_restore_));
  // @@protoc_insertion_point(copy_constructor:TSWP.AddFlowInfoCommandArchive)
}

inline void AddFlowInfoCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.flow_info_to_add_){nullptr}
    , decltype(_impl_.flow_info_archive_){nullptr}
    , decltype(_impl_.working_undo_object_){nullptr}
    , decltype(_impl_.undo_user_interface_identifier_to_restore_){0u}
    , decltype(_impl_.undo_next_user_interface_identifier_to_restore_){0u}
  };
}

AddFlowInfoCommandArchive::~AddFlowInfoCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.AddFlowInfoCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddFlowInfoCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.flow_info_to_add_;
  if (this != internal_default_instance()) delete _impl_.flow_info_archive_;
  if (this != internal_default_instance()) delete _impl_.working_undo_object_;
}

void AddFlowInfoCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddFlowInfoCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.AddFlowInfoCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.flow_info_to_add_ != nullptr);
      _impl_.flow_info_to_add_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.flow_info_archive_ != nullptr);
      _impl_.flow_info_archive_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.working_undo_object_ != nullptr);
      _impl_.working_undo_object_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_.undo_user_interface_identifier_to_restore_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.undo_next_user_interface_identifier_to_restore_) -
        reinterpret_cast<char*>(&_impl_.undo_user_interface_identifier_to_restore_)) + sizeof(_impl_.undo_next_user_interface_identifier_to_restore_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddFlowInfoCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference flow_info_to_add = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_flow_info_to_add(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference flow_info_archive = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_flow_info_archive(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 undo_user_interface_identifier_to_restore = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_undo_user_interface_identifier_to_restore(&has_bits);
          _impl_.undo_user_interface_identifier_to_restore_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 undo_next_user_interface_identifier_to_restore = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_undo_next_user_interface_identifier_to_restore(&has_bits);
          _impl_.undo_next_user_interface_identifier_to_restore_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference working_undo_object = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_working_undo_object(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AddFlowInfoCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.AddFlowInfoCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference flow_info_to_add = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::flow_info_to_add(this),
        _Internal::flow_info_to_add(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference flow_info_archive = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::flow_info_archive(this),
        _Internal::flow_info_archive(this).GetCachedSize(), target, stream);
  }

  // optional uint32 undo_user_interface_identifier_to_restore = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_undo_user_interface_identifier_to_restore(), target);
  }

  // optional uint32 undo_next_user_interface_identifier_to_restore = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_undo_next_user_interface_identifier_to_restore(), target);
  }

  // optional .TSP.Reference working_undo_object = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::working_undo_object(this),
        _Internal::working_undo_object(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.AddFlowInfoCommandArchive)
  return target;
}

size_t AddFlowInfoCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.AddFlowInfoCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference flow_info_to_add = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.flow_info_to_add_);
    }

    // optional .TSP.Reference flow_info_archive = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.flow_info_archive_);
    }

    // optional .TSP.Reference working_undo_object = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.working_undo_object_);
    }

    // optional uint32 undo_user_interface_identifier_to_restore = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undo_user_interface_identifier_to_restore());
    }

    // optional uint32 undo_next_user_interface_identifier_to_restore = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undo_next_user_interface_identifier_to_restore());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddFlowInfoCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddFlowInfoCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddFlowInfoCommandArchive::GetClassData() const { return &_class_data_; }


void AddFlowInfoCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddFlowInfoCommandArchive*>(&to_msg);
  auto& from = static_cast<const AddFlowInfoCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.AddFlowInfoCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_flow_info_to_add()->::TSP::Reference::MergeFrom(
          from._internal_flow_info_to_add());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_flow_info_archive()->::TSP::Reference::MergeFrom(
          from._internal_flow_info_archive());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_working_undo_object()->::TSP::Reference::MergeFrom(
          from._internal_working_undo_object());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.undo_user_interface_identifier_to_restore_ = from._impl_.undo_user_interface_identifier_to_restore_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.undo_next_user_interface_identifier_to_restore_ = from._impl_.undo_next_user_interface_identifier_to_restore_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddFlowInfoCommandArchive::CopyFrom(const AddFlowInfoCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.AddFlowInfoCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddFlowInfoCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_flow_info_to_add()) {
    if (!_impl_.flow_info_to_add_->IsInitialized()) return false;
  }
  if (_internal_has_flow_info_archive()) {
    if (!_impl_.flow_info_archive_->IsInitialized()) return false;
  }
  if (_internal_has_working_undo_object()) {
    if (!_impl_.working_undo_object_->IsInitialized()) return false;
  }
  return true;
}

void AddFlowInfoCommandArchive::InternalSwap(AddFlowInfoCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddFlowInfoCommandArchive, _impl_.undo_next_user_interface_identifier_to_restore_)
      + sizeof(AddFlowInfoCommandArchive::_impl_.undo_next_user_interface_identifier_to_restore_)
      - PROTOBUF_FIELD_OFFSET(AddFlowInfoCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddFlowInfoCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[37]);
}

// ===================================================================

class RemoveFlowInfoCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoveFlowInfoCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const RemoveFlowInfoCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::UUIDPath& flow_info_uuid_path(const RemoveFlowInfoCommandArchive* msg);
  static void set_has_flow_info_uuid_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& undo_object(const RemoveFlowInfoCommandArchive* msg);
  static void set_has_undo_object(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_undo_user_interface_identifier_to_restore(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_undo_next_user_interface_identifier_to_restore(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::TSK::CommandArchive&
RemoveFlowInfoCommandArchive::_Internal::super(const RemoveFlowInfoCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::UUIDPath&
RemoveFlowInfoCommandArchive::_Internal::flow_info_uuid_path(const RemoveFlowInfoCommandArchive* msg) {
  return *msg->_impl_.flow_info_uuid_path_;
}
const ::TSP::Reference&
RemoveFlowInfoCommandArchive::_Internal::undo_object(const RemoveFlowInfoCommandArchive* msg) {
  return *msg->_impl_.undo_object_;
}
void RemoveFlowInfoCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RemoveFlowInfoCommandArchive::clear_flow_info_uuid_path() {
  if (_impl_.flow_info_uuid_path_ != nullptr) _impl_.flow_info_uuid_path_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RemoveFlowInfoCommandArchive::clear_undo_object() {
  if (_impl_.undo_object_ != nullptr) _impl_.undo_object_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
RemoveFlowInfoCommandArchive::RemoveFlowInfoCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.RemoveFlowInfoCommandArchive)
}
RemoveFlowInfoCommandArchive::RemoveFlowInfoCommandArchive(const RemoveFlowInfoCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemoveFlowInfoCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.flow_info_uuid_path_){nullptr}
    , decltype(_impl_.undo_object_){nullptr}
    , decltype(_impl_.undo_user_interface_identifier_to_restore_){}
    , decltype(_impl_.undo_next_user_interface_identifier_to_restore_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_flow_info_uuid_path()) {
    _this->_impl_.flow_info_uuid_path_ = new ::TSP::UUIDPath(*from._impl_.flow_info_uuid_path_);
  }
  if (from._internal_has_undo_object()) {
    _this->_impl_.undo_object_ = new ::TSP::Reference(*from._impl_.undo_object_);
  }
  ::memcpy(&_impl_.undo_user_interface_identifier_to_restore_, &from._impl_.undo_user_interface_identifier_to_restore_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.undo_next_user_interface_identifier_to_restore_) -
    reinterpret_cast<char*>(&_impl_.undo_user_interface_identifier_to_restore_)) + sizeof(_impl_.undo_next_user_interface_identifier_to_restore_));
  // @@protoc_insertion_point(copy_constructor:TSWP.RemoveFlowInfoCommandArchive)
}

inline void RemoveFlowInfoCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.flow_info_uuid_path_){nullptr}
    , decltype(_impl_.undo_object_){nullptr}
    , decltype(_impl_.undo_user_interface_identifier_to_restore_){0u}
    , decltype(_impl_.undo_next_user_interface_identifier_to_restore_){0u}
  };
}

RemoveFlowInfoCommandArchive::~RemoveFlowInfoCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.RemoveFlowInfoCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoveFlowInfoCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.flow_info_uuid_path_;
  if (this != internal_default_instance()) delete _impl_.undo_object_;
}

void RemoveFlowInfoCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoveFlowInfoCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.RemoveFlowInfoCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.flow_info_uuid_path_ != nullptr);
      _impl_.flow_info_uuid_path_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_object_ != nullptr);
      _impl_.undo_object_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.undo_user_interface_identifier_to_restore_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.undo_next_user_interface_identifier_to_restore_) -
        reinterpret_cast<char*>(&_impl_.undo_user_interface_identifier_to_restore_)) + sizeof(_impl_.undo_next_user_interface_identifier_to_restore_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoveFlowInfoCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.UUIDPath flow_info_uuid_path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_flow_info_uuid_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference undo_object = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_object(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 undo_user_interface_identifier_to_restore = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_undo_user_interface_identifier_to_restore(&has_bits);
          _impl_.undo_user_interface_identifier_to_restore_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 undo_next_user_interface_identifier_to_restore = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_undo_next_user_interface_identifier_to_restore(&has_bits);
          _impl_.undo_next_user_interface_identifier_to_restore_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoveFlowInfoCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.RemoveFlowInfoCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.UUIDPath flow_info_uuid_path = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::flow_info_uuid_path(this),
        _Internal::flow_info_uuid_path(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference undo_object = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::undo_object(this),
        _Internal::undo_object(this).GetCachedSize(), target, stream);
  }

  // optional uint32 undo_user_interface_identifier_to_restore = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_undo_user_interface_identifier_to_restore(), target);
  }

  // optional uint32 undo_next_user_interface_identifier_to_restore = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_undo_next_user_interface_identifier_to_restore(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.RemoveFlowInfoCommandArchive)
  return target;
}

size_t RemoveFlowInfoCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.RemoveFlowInfoCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.UUIDPath flow_info_uuid_path = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.flow_info_uuid_path_);
    }

    // optional .TSP.Reference undo_object = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_object_);
    }

    // optional uint32 undo_user_interface_identifier_to_restore = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undo_user_interface_identifier_to_restore());
    }

    // optional uint32 undo_next_user_interface_identifier_to_restore = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undo_next_user_interface_identifier_to_restore());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoveFlowInfoCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemoveFlowInfoCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoveFlowInfoCommandArchive::GetClassData() const { return &_class_data_; }


void RemoveFlowInfoCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemoveFlowInfoCommandArchive*>(&to_msg);
  auto& from = static_cast<const RemoveFlowInfoCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.RemoveFlowInfoCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_flow_info_uuid_path()->::TSP::UUIDPath::MergeFrom(
          from._internal_flow_info_uuid_path());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_object()->::TSP::Reference::MergeFrom(
          from._internal_undo_object());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.undo_user_interface_identifier_to_restore_ = from._impl_.undo_user_interface_identifier_to_restore_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.undo_next_user_interface_identifier_to_restore_ = from._impl_.undo_next_user_interface_identifier_to_restore_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoveFlowInfoCommandArchive::CopyFrom(const RemoveFlowInfoCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.RemoveFlowInfoCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveFlowInfoCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_flow_info_uuid_path()) {
    if (!_impl_.flow_info_uuid_path_->IsInitialized()) return false;
  }
  if (_internal_has_undo_object()) {
    if (!_impl_.undo_object_->IsInitialized()) return false;
  }
  return true;
}

void RemoveFlowInfoCommandArchive::InternalSwap(RemoveFlowInfoCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoveFlowInfoCommandArchive, _impl_.undo_next_user_interface_identifier_to_restore_)
      + sizeof(RemoveFlowInfoCommandArchive::_impl_.undo_next_user_interface_identifier_to_restore_)
      - PROTOBUF_FIELD_OFFSET(RemoveFlowInfoCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoveFlowInfoCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[38]);
}

// ===================================================================

class TextCommentReplyCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<TextCommentReplyCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const TextCommentReplyCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::UUIDPath& storage_uuid_path(const TextCommentReplyCommandArchive* msg);
  static void set_has_storage_uuid_path(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_annotation_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& forward_comment(const TextCommentReplyCommandArchive* msg);
  static void set_has_forward_comment(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& inverse_comment(const TextCommentReplyCommandArchive* msg);
  static void set_has_inverse_comment(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_forward_variant(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_inverse_variant(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::TSK::CommandArchive&
TextCommentReplyCommandArchive::_Internal::super(const TextCommentReplyCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::UUIDPath&
TextCommentReplyCommandArchive::_Internal::storage_uuid_path(const TextCommentReplyCommandArchive* msg) {
  return *msg->_impl_.storage_uuid_path_;
}
const ::TSP::Reference&
TextCommentReplyCommandArchive::_Internal::forward_comment(const TextCommentReplyCommandArchive* msg) {
  return *msg->_impl_.forward_comment_;
}
const ::TSP::Reference&
TextCommentReplyCommandArchive::_Internal::inverse_comment(const TextCommentReplyCommandArchive* msg) {
  return *msg->_impl_.inverse_comment_;
}
void TextCommentReplyCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TextCommentReplyCommandArchive::clear_storage_uuid_path() {
  if (_impl_.storage_uuid_path_ != nullptr) _impl_.storage_uuid_path_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void TextCommentReplyCommandArchive::clear_forward_comment() {
  if (_impl_.forward_comment_ != nullptr) _impl_.forward_comment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void TextCommentReplyCommandArchive::clear_inverse_comment() {
  if (_impl_.inverse_comment_ != nullptr) _impl_.inverse_comment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
TextCommentReplyCommandArchive::TextCommentReplyCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.TextCommentReplyCommandArchive)
}
TextCommentReplyCommandArchive::TextCommentReplyCommandArchive(const TextCommentReplyCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TextCommentReplyCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.annotation_uuid_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_uuid_path_){nullptr}
    , decltype(_impl_.forward_comment_){nullptr}
    , decltype(_impl_.inverse_comment_){nullptr}
    , decltype(_impl_.forward_variant_){}
    , decltype(_impl_.inverse_variant_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.annotation_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.annotation_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_annotation_uuid()) {
    _this->_impl_.annotation_uuid_.Set(from._internal_annotation_uuid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage_uuid_path()) {
    _this->_impl_.storage_uuid_path_ = new ::TSP::UUIDPath(*from._impl_.storage_uuid_path_);
  }
  if (from._internal_has_forward_comment()) {
    _this->_impl_.forward_comment_ = new ::TSP::Reference(*from._impl_.forward_comment_);
  }
  if (from._internal_has_inverse_comment()) {
    _this->_impl_.inverse_comment_ = new ::TSP::Reference(*from._impl_.inverse_comment_);
  }
  ::memcpy(&_impl_.forward_variant_, &from._impl_.forward_variant_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.inverse_variant_) -
    reinterpret_cast<char*>(&_impl_.forward_variant_)) + sizeof(_impl_.inverse_variant_));
  // @@protoc_insertion_point(copy_constructor:TSWP.TextCommentReplyCommandArchive)
}

inline void TextCommentReplyCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.annotation_uuid_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_uuid_path_){nullptr}
    , decltype(_impl_.forward_comment_){nullptr}
    , decltype(_impl_.inverse_comment_){nullptr}
    , decltype(_impl_.forward_variant_){0}
    , decltype(_impl_.inverse_variant_){0}
  };
  _impl_.annotation_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.annotation_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TextCommentReplyCommandArchive::~TextCommentReplyCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.TextCommentReplyCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TextCommentReplyCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.annotation_uuid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_uuid_path_;
  if (this != internal_default_instance()) delete _impl_.forward_comment_;
  if (this != internal_default_instance()) delete _impl_.inverse_comment_;
}

void TextCommentReplyCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TextCommentReplyCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.TextCommentReplyCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.annotation_uuid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.storage_uuid_path_ != nullptr);
      _impl_.storage_uuid_path_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.forward_comment_ != nullptr);
      _impl_.forward_comment_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.inverse_comment_ != nullptr);
      _impl_.inverse_comment_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&_impl_.forward_variant_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.inverse_variant_) -
        reinterpret_cast<char*>(&_impl_.forward_variant_)) + sizeof(_impl_.inverse_variant_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TextCommentReplyCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.UUIDPath storage_uuid_path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage_uuid_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string annotation_uuid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_annotation_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.TextCommentReplyCommandArchive.annotation_uuid");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference forward_comment = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_forward_comment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference inverse_comment = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_inverse_comment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.CommentCommandVariant forward_variant = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::CommentCommandVariant_IsValid(val))) {
            _internal_set_forward_variant(static_cast<::TSD::CommentCommandVariant>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.CommentCommandVariant inverse_variant = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::CommentCommandVariant_IsValid(val))) {
            _internal_set_inverse_variant(static_cast<::TSD::CommentCommandVariant>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TextCommentReplyCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.TextCommentReplyCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.UUIDPath storage_uuid_path = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage_uuid_path(this),
        _Internal::storage_uuid_path(this).GetCachedSize(), target, stream);
  }

  // optional string annotation_uuid = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_annotation_uuid().data(), static_cast<int>(this->_internal_annotation_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.TextCommentReplyCommandArchive.annotation_uuid");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_annotation_uuid(), target);
  }

  // optional .TSP.Reference forward_comment = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::forward_comment(this),
        _Internal::forward_comment(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference inverse_comment = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::inverse_comment(this),
        _Internal::inverse_comment(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.CommentCommandVariant forward_variant = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_forward_variant(), target);
  }

  // optional .TSD.CommentCommandVariant inverse_variant = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_inverse_variant(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.TextCommentReplyCommandArchive)
  return target;
}

size_t TextCommentReplyCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.TextCommentReplyCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string annotation_uuid = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_annotation_uuid());
    }

    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.UUIDPath storage_uuid_path = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_uuid_path_);
    }

    // optional .TSP.Reference forward_comment = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.forward_comment_);
    }

    // optional .TSP.Reference inverse_comment = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.inverse_comment_);
    }

    // optional .TSD.CommentCommandVariant forward_variant = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_forward_variant());
    }

    // optional .TSD.CommentCommandVariant inverse_variant = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_inverse_variant());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TextCommentReplyCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TextCommentReplyCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TextCommentReplyCommandArchive::GetClassData() const { return &_class_data_; }


void TextCommentReplyCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TextCommentReplyCommandArchive*>(&to_msg);
  auto& from = static_cast<const TextCommentReplyCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.TextCommentReplyCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_annotation_uuid(from._internal_annotation_uuid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_storage_uuid_path()->::TSP::UUIDPath::MergeFrom(
          from._internal_storage_uuid_path());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_forward_comment()->::TSP::Reference::MergeFrom(
          from._internal_forward_comment());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_inverse_comment()->::TSP::Reference::MergeFrom(
          from._internal_inverse_comment());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.forward_variant_ = from._impl_.forward_variant_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.inverse_variant_ = from._impl_.inverse_variant_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TextCommentReplyCommandArchive::CopyFrom(const TextCommentReplyCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.TextCommentReplyCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextCommentReplyCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage_uuid_path()) {
    if (!_impl_.storage_uuid_path_->IsInitialized()) return false;
  }
  if (_internal_has_forward_comment()) {
    if (!_impl_.forward_comment_->IsInitialized()) return false;
  }
  if (_internal_has_inverse_comment()) {
    if (!_impl_.inverse_comment_->IsInitialized()) return false;
  }
  return true;
}

void TextCommentReplyCommandArchive::InternalSwap(TextCommentReplyCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.annotation_uuid_, lhs_arena,
      &other->_impl_.annotation_uuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TextCommentReplyCommandArchive, _impl_.inverse_variant_)
      + sizeof(TextCommentReplyCommandArchive::_impl_.inverse_variant_)
      - PROTOBUF_FIELD_OFFSET(TextCommentReplyCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TextCommentReplyCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[39]);
}

// ===================================================================

class ContainedObjectsCommandArchive_AddBehaviorArgs::_Internal {
 public:
};

void ContainedObjectsCommandArchive_AddBehaviorArgs::clear_args_list() {
  _impl_.args_list_.Clear();
}
ContainedObjectsCommandArchive_AddBehaviorArgs::ContainedObjectsCommandArchive_AddBehaviorArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ContainedObjectsCommandArchive.AddBehaviorArgs)
}
ContainedObjectsCommandArchive_AddBehaviorArgs::ContainedObjectsCommandArchive_AddBehaviorArgs(const ContainedObjectsCommandArchive_AddBehaviorArgs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainedObjectsCommandArchive_AddBehaviorArgs* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.args_list_){from._impl_.args_list_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSWP.ContainedObjectsCommandArchive.AddBehaviorArgs)
}

inline void ContainedObjectsCommandArchive_AddBehaviorArgs::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.args_list_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ContainedObjectsCommandArchive_AddBehaviorArgs::~ContainedObjectsCommandArchive_AddBehaviorArgs() {
  // @@protoc_insertion_point(destructor:TSWP.ContainedObjectsCommandArchive.AddBehaviorArgs)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContainedObjectsCommandArchive_AddBehaviorArgs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_list_.~RepeatedPtrField();
}

void ContainedObjectsCommandArchive_AddBehaviorArgs::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainedObjectsCommandArchive_AddBehaviorArgs::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ContainedObjectsCommandArchive.AddBehaviorArgs)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_list_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainedObjectsCommandArchive_AddBehaviorArgs::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSK.AddIdOperationArgs args_list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainedObjectsCommandArchive_AddBehaviorArgs::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ContainedObjectsCommandArchive.AddBehaviorArgs)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSK.AddIdOperationArgs args_list = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_args_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ContainedObjectsCommandArchive.AddBehaviorArgs)
  return target;
}

size_t ContainedObjectsCommandArchive_AddBehaviorArgs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ContainedObjectsCommandArchive.AddBehaviorArgs)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSK.AddIdOperationArgs args_list = 1;
  total_size += 1UL * this->_internal_args_list_size();
  for (const auto& msg : this->_impl_.args_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainedObjectsCommandArchive_AddBehaviorArgs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainedObjectsCommandArchive_AddBehaviorArgs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainedObjectsCommandArchive_AddBehaviorArgs::GetClassData() const { return &_class_data_; }


void ContainedObjectsCommandArchive_AddBehaviorArgs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainedObjectsCommandArchive_AddBehaviorArgs*>(&to_msg);
  auto& from = static_cast<const ContainedObjectsCommandArchive_AddBehaviorArgs&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ContainedObjectsCommandArchive.AddBehaviorArgs)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_list_.MergeFrom(from._impl_.args_list_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainedObjectsCommandArchive_AddBehaviorArgs::CopyFrom(const ContainedObjectsCommandArchive_AddBehaviorArgs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ContainedObjectsCommandArchive.AddBehaviorArgs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainedObjectsCommandArchive_AddBehaviorArgs::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.args_list_))
    return false;
  return true;
}

void ContainedObjectsCommandArchive_AddBehaviorArgs::InternalSwap(ContainedObjectsCommandArchive_AddBehaviorArgs* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.args_list_.InternalSwap(&other->_impl_.args_list_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainedObjectsCommandArchive_AddBehaviorArgs::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[40]);
}

// ===================================================================

class ContainedObjectsCommandArchive_RemoveBehaviorArgs::_Internal {
 public:
};

void ContainedObjectsCommandArchive_RemoveBehaviorArgs::clear_args_list() {
  _impl_.args_list_.Clear();
}
ContainedObjectsCommandArchive_RemoveBehaviorArgs::ContainedObjectsCommandArchive_RemoveBehaviorArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ContainedObjectsCommandArchive.RemoveBehaviorArgs)
}
ContainedObjectsCommandArchive_RemoveBehaviorArgs::ContainedObjectsCommandArchive_RemoveBehaviorArgs(const ContainedObjectsCommandArchive_RemoveBehaviorArgs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainedObjectsCommandArchive_RemoveBehaviorArgs* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.args_list_){from._impl_.args_list_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSWP.ContainedObjectsCommandArchive.RemoveBehaviorArgs)
}

inline void ContainedObjectsCommandArchive_RemoveBehaviorArgs::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.args_list_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ContainedObjectsCommandArchive_RemoveBehaviorArgs::~ContainedObjectsCommandArchive_RemoveBehaviorArgs() {
  // @@protoc_insertion_point(destructor:TSWP.ContainedObjectsCommandArchive.RemoveBehaviorArgs)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContainedObjectsCommandArchive_RemoveBehaviorArgs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_list_.~RepeatedPtrField();
}

void ContainedObjectsCommandArchive_RemoveBehaviorArgs::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainedObjectsCommandArchive_RemoveBehaviorArgs::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ContainedObjectsCommandArchive.RemoveBehaviorArgs)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_list_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainedObjectsCommandArchive_RemoveBehaviorArgs::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSK.RemoveIdOperationArgs args_list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainedObjectsCommandArchive_RemoveBehaviorArgs::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ContainedObjectsCommandArchive.RemoveBehaviorArgs)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSK.RemoveIdOperationArgs args_list = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_args_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ContainedObjectsCommandArchive.RemoveBehaviorArgs)
  return target;
}

size_t ContainedObjectsCommandArchive_RemoveBehaviorArgs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ContainedObjectsCommandArchive.RemoveBehaviorArgs)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSK.RemoveIdOperationArgs args_list = 1;
  total_size += 1UL * this->_internal_args_list_size();
  for (const auto& msg : this->_impl_.args_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainedObjectsCommandArchive_RemoveBehaviorArgs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainedObjectsCommandArchive_RemoveBehaviorArgs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainedObjectsCommandArchive_RemoveBehaviorArgs::GetClassData() const { return &_class_data_; }


void ContainedObjectsCommandArchive_RemoveBehaviorArgs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainedObjectsCommandArchive_RemoveBehaviorArgs*>(&to_msg);
  auto& from = static_cast<const ContainedObjectsCommandArchive_RemoveBehaviorArgs&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ContainedObjectsCommandArchive.RemoveBehaviorArgs)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_list_.MergeFrom(from._impl_.args_list_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainedObjectsCommandArchive_RemoveBehaviorArgs::CopyFrom(const ContainedObjectsCommandArchive_RemoveBehaviorArgs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ContainedObjectsCommandArchive.RemoveBehaviorArgs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainedObjectsCommandArchive_RemoveBehaviorArgs::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.args_list_))
    return false;
  return true;
}

void ContainedObjectsCommandArchive_RemoveBehaviorArgs::InternalSwap(ContainedObjectsCommandArchive_RemoveBehaviorArgs* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.args_list_.InternalSwap(&other->_impl_.args_list_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainedObjectsCommandArchive_RemoveBehaviorArgs::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[41]);
}

// ===================================================================

class ContainedObjectsCommandArchive_RearrangeBehaviorArgs::_Internal {
 public:
};

void ContainedObjectsCommandArchive_RearrangeBehaviorArgs::clear_args_list() {
  _impl_.args_list_.Clear();
}
ContainedObjectsCommandArchive_RearrangeBehaviorArgs::ContainedObjectsCommandArchive_RearrangeBehaviorArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ContainedObjectsCommandArchive.RearrangeBehaviorArgs)
}
ContainedObjectsCommandArchive_RearrangeBehaviorArgs::ContainedObjectsCommandArchive_RearrangeBehaviorArgs(const ContainedObjectsCommandArchive_RearrangeBehaviorArgs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainedObjectsCommandArchive_RearrangeBehaviorArgs* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.args_list_){from._impl_.args_list_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSWP.ContainedObjectsCommandArchive.RearrangeBehaviorArgs)
}

inline void ContainedObjectsCommandArchive_RearrangeBehaviorArgs::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.args_list_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ContainedObjectsCommandArchive_RearrangeBehaviorArgs::~ContainedObjectsCommandArchive_RearrangeBehaviorArgs() {
  // @@protoc_insertion_point(destructor:TSWP.ContainedObjectsCommandArchive.RearrangeBehaviorArgs)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContainedObjectsCommandArchive_RearrangeBehaviorArgs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.args_list_.~RepeatedPtrField();
}

void ContainedObjectsCommandArchive_RearrangeBehaviorArgs::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainedObjectsCommandArchive_RearrangeBehaviorArgs::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ContainedObjectsCommandArchive.RearrangeBehaviorArgs)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.args_list_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainedObjectsCommandArchive_RearrangeBehaviorArgs::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSK.RearrangeIdOperationArgs args_list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainedObjectsCommandArchive_RearrangeBehaviorArgs::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ContainedObjectsCommandArchive.RearrangeBehaviorArgs)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSK.RearrangeIdOperationArgs args_list = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_args_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_args_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ContainedObjectsCommandArchive.RearrangeBehaviorArgs)
  return target;
}

size_t ContainedObjectsCommandArchive_RearrangeBehaviorArgs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ContainedObjectsCommandArchive.RearrangeBehaviorArgs)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSK.RearrangeIdOperationArgs args_list = 1;
  total_size += 1UL * this->_internal_args_list_size();
  for (const auto& msg : this->_impl_.args_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainedObjectsCommandArchive_RearrangeBehaviorArgs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainedObjectsCommandArchive_RearrangeBehaviorArgs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainedObjectsCommandArchive_RearrangeBehaviorArgs::GetClassData() const { return &_class_data_; }


void ContainedObjectsCommandArchive_RearrangeBehaviorArgs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainedObjectsCommandArchive_RearrangeBehaviorArgs*>(&to_msg);
  auto& from = static_cast<const ContainedObjectsCommandArchive_RearrangeBehaviorArgs&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ContainedObjectsCommandArchive.RearrangeBehaviorArgs)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.args_list_.MergeFrom(from._impl_.args_list_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainedObjectsCommandArchive_RearrangeBehaviorArgs::CopyFrom(const ContainedObjectsCommandArchive_RearrangeBehaviorArgs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ContainedObjectsCommandArchive.RearrangeBehaviorArgs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainedObjectsCommandArchive_RearrangeBehaviorArgs::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.args_list_))
    return false;
  return true;
}

void ContainedObjectsCommandArchive_RearrangeBehaviorArgs::InternalSwap(ContainedObjectsCommandArchive_RearrangeBehaviorArgs* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.args_list_.InternalSwap(&other->_impl_.args_list_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainedObjectsCommandArchive_RearrangeBehaviorArgs::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[42]);
}

// ===================================================================

class ContainedObjectsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ContainedObjectsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ContainedObjectsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& target(const ContainedObjectsCommandArchive* msg);
  static void set_has_target(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& undo_object_for_commit(const ContainedObjectsCommandArchive* msg);
  static void set_has_undo_object_for_commit(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& undo_object_for_make_inverse(const ContainedObjectsCommandArchive* msg);
  static void set_has_undo_object_for_make_inverse(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSWP::ContainedObjectsCommandArchive_AddBehaviorArgs& add_behavior_args(const ContainedObjectsCommandArchive* msg);
  static void set_has_add_behavior_args(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSWP::ContainedObjectsCommandArchive_RemoveBehaviorArgs& remove_behavior_args(const ContainedObjectsCommandArchive* msg);
  static void set_has_remove_behavior_args(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSWP::ContainedObjectsCommandArchive_RearrangeBehaviorArgs& rearrange_behavior_args(const ContainedObjectsCommandArchive* msg);
  static void set_has_rearrange_behavior_args(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_container_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

const ::TSK::CommandArchive&
ContainedObjectsCommandArchive::_Internal::super(const ContainedObjectsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ContainedObjectsCommandArchive::_Internal::target(const ContainedObjectsCommandArchive* msg) {
  return *msg->_impl_.target_;
}
const ::TSP::Reference&
ContainedObjectsCommandArchive::_Internal::undo_object_for_commit(const ContainedObjectsCommandArchive* msg) {
  return *msg->_impl_.undo_object_for_commit_;
}
const ::TSP::Reference&
ContainedObjectsCommandArchive::_Internal::undo_object_for_make_inverse(const ContainedObjectsCommandArchive* msg) {
  return *msg->_impl_.undo_object_for_make_inverse_;
}
const ::TSWP::ContainedObjectsCommandArchive_AddBehaviorArgs&
ContainedObjectsCommandArchive::_Internal::add_behavior_args(const ContainedObjectsCommandArchive* msg) {
  return *msg->_impl_.add_behavior_args_;
}
const ::TSWP::ContainedObjectsCommandArchive_RemoveBehaviorArgs&
ContainedObjectsCommandArchive::_Internal::remove_behavior_args(const ContainedObjectsCommandArchive* msg) {
  return *msg->_impl_.remove_behavior_args_;
}
const ::TSWP::ContainedObjectsCommandArchive_RearrangeBehaviorArgs&
ContainedObjectsCommandArchive::_Internal::rearrange_behavior_args(const ContainedObjectsCommandArchive* msg) {
  return *msg->_impl_.rearrange_behavior_args_;
}
void ContainedObjectsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ContainedObjectsCommandArchive::clear_target() {
  if (_impl_.target_ != nullptr) _impl_.target_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ContainedObjectsCommandArchive::clear_objects() {
  _impl_.objects_.Clear();
}
void ContainedObjectsCommandArchive::clear_undo_object_for_commit() {
  if (_impl_.undo_object_for_commit_ != nullptr) _impl_.undo_object_for_commit_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void ContainedObjectsCommandArchive::clear_undo_object_for_make_inverse() {
  if (_impl_.undo_object_for_make_inverse_ != nullptr) _impl_.undo_object_for_make_inverse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
ContainedObjectsCommandArchive::ContainedObjectsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ContainedObjectsCommandArchive)
}
ContainedObjectsCommandArchive::ContainedObjectsCommandArchive(const ContainedObjectsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainedObjectsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objects_){from._impl_.objects_}
    , decltype(_impl_.container_name_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.target_){nullptr}
    , decltype(_impl_.undo_object_for_commit_){nullptr}
    , decltype(_impl_.undo_object_for_make_inverse_){nullptr}
    , decltype(_impl_.add_behavior_args_){nullptr}
    , decltype(_impl_.remove_behavior_args_){nullptr}
    , decltype(_impl_.rearrange_behavior_args_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.container_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.container_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_container_name()) {
    _this->_impl_.container_name_.Set(from._internal_container_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::TSP::Reference(*from._impl_.target_);
  }
  if (from._internal_has_undo_object_for_commit()) {
    _this->_impl_.undo_object_for_commit_ = new ::TSP::Reference(*from._impl_.undo_object_for_commit_);
  }
  if (from._internal_has_undo_object_for_make_inverse()) {
    _this->_impl_.undo_object_for_make_inverse_ = new ::TSP::Reference(*from._impl_.undo_object_for_make_inverse_);
  }
  if (from._internal_has_add_behavior_args()) {
    _this->_impl_.add_behavior_args_ = new ::TSWP::ContainedObjectsCommandArchive_AddBehaviorArgs(*from._impl_.add_behavior_args_);
  }
  if (from._internal_has_remove_behavior_args()) {
    _this->_impl_.remove_behavior_args_ = new ::TSWP::ContainedObjectsCommandArchive_RemoveBehaviorArgs(*from._impl_.remove_behavior_args_);
  }
  if (from._internal_has_rearrange_behavior_args()) {
    _this->_impl_.rearrange_behavior_args_ = new ::TSWP::ContainedObjectsCommandArchive_RearrangeBehaviorArgs(*from._impl_.rearrange_behavior_args_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.ContainedObjectsCommandArchive)
}

inline void ContainedObjectsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objects_){arena}
    , decltype(_impl_.container_name_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.target_){nullptr}
    , decltype(_impl_.undo_object_for_commit_){nullptr}
    , decltype(_impl_.undo_object_for_make_inverse_){nullptr}
    , decltype(_impl_.add_behavior_args_){nullptr}
    , decltype(_impl_.remove_behavior_args_){nullptr}
    , decltype(_impl_.rearrange_behavior_args_){nullptr}
  };
  _impl_.container_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.container_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContainedObjectsCommandArchive::~ContainedObjectsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ContainedObjectsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContainedObjectsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.objects_.~RepeatedPtrField();
  _impl_.container_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.target_;
  if (this != internal_default_instance()) delete _impl_.undo_object_for_commit_;
  if (this != internal_default_instance()) delete _impl_.undo_object_for_make_inverse_;
  if (this != internal_default_instance()) delete _impl_.add_behavior_args_;
  if (this != internal_default_instance()) delete _impl_.remove_behavior_args_;
  if (this != internal_default_instance()) delete _impl_.rearrange_behavior_args_;
}

void ContainedObjectsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainedObjectsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ContainedObjectsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objects_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.container_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.target_ != nullptr);
      _impl_.target_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.undo_object_for_commit_ != nullptr);
      _impl_.undo_object_for_commit_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.undo_object_for_make_inverse_ != nullptr);
      _impl_.undo_object_for_make_inverse_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.add_behavior_args_ != nullptr);
      _impl_.add_behavior_args_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.remove_behavior_args_ != nullptr);
      _impl_.remove_behavior_args_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.rearrange_behavior_args_ != nullptr);
      _impl_.rearrange_behavior_args_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainedObjectsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference target = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference objects = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference undo_object_for_commit = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_object_for_commit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference undo_object_for_make_inverse = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_object_for_make_inverse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.ContainedObjectsCommandArchive.AddBehaviorArgs add_behavior_args = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_add_behavior_args(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.ContainedObjectsCommandArchive.RemoveBehaviorArgs remove_behavior_args = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_remove_behavior_args(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.ContainedObjectsCommandArchive.RearrangeBehaviorArgs rearrange_behavior_args = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_rearrange_behavior_args(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string container_name = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_container_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.ContainedObjectsCommandArchive.container_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainedObjectsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ContainedObjectsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference target = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference objects = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_objects_size()); i < n; i++) {
    const auto& repfield = this->_internal_objects(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference undo_object_for_commit = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::undo_object_for_commit(this),
        _Internal::undo_object_for_commit(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference undo_object_for_make_inverse = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_object_for_make_inverse(this),
        _Internal::undo_object_for_make_inverse(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.ContainedObjectsCommandArchive.AddBehaviorArgs add_behavior_args = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::add_behavior_args(this),
        _Internal::add_behavior_args(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.ContainedObjectsCommandArchive.RemoveBehaviorArgs remove_behavior_args = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::remove_behavior_args(this),
        _Internal::remove_behavior_args(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.ContainedObjectsCommandArchive.RearrangeBehaviorArgs rearrange_behavior_args = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::rearrange_behavior_args(this),
        _Internal::rearrange_behavior_args(this).GetCachedSize(), target, stream);
  }

  // optional string container_name = 9;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_container_name().data(), static_cast<int>(this->_internal_container_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.ContainedObjectsCommandArchive.container_name");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_container_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ContainedObjectsCommandArchive)
  return target;
}

size_t ContainedObjectsCommandArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSWP.ContainedObjectsCommandArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_target()) {
    // required .TSP.Reference target = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);
  }

  return total_size;
}
size_t ContainedObjectsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ContainedObjectsCommandArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSP.Reference target = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference objects = 3;
  total_size += 1UL * this->_internal_objects_size();
  for (const auto& msg : this->_impl_.objects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string container_name = 9;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_container_name());
  }

  if (cached_has_bits & 0x000000f8u) {
    // optional .TSP.Reference undo_object_for_commit = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_object_for_commit_);
    }

    // optional .TSP.Reference undo_object_for_make_inverse = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_object_for_make_inverse_);
    }

    // optional .TSWP.ContainedObjectsCommandArchive.AddBehaviorArgs add_behavior_args = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.add_behavior_args_);
    }

    // optional .TSWP.ContainedObjectsCommandArchive.RemoveBehaviorArgs remove_behavior_args = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.remove_behavior_args_);
    }

    // optional .TSWP.ContainedObjectsCommandArchive.RearrangeBehaviorArgs rearrange_behavior_args = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rearrange_behavior_args_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainedObjectsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainedObjectsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainedObjectsCommandArchive::GetClassData() const { return &_class_data_; }


void ContainedObjectsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainedObjectsCommandArchive*>(&to_msg);
  auto& from = static_cast<const ContainedObjectsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ContainedObjectsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.objects_.MergeFrom(from._impl_.objects_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_container_name(from._internal_container_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_target()->::TSP::Reference::MergeFrom(
          from._internal_target());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_undo_object_for_commit()->::TSP::Reference::MergeFrom(
          from._internal_undo_object_for_commit());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_undo_object_for_make_inverse()->::TSP::Reference::MergeFrom(
          from._internal_undo_object_for_make_inverse());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_add_behavior_args()->::TSWP::ContainedObjectsCommandArchive_AddBehaviorArgs::MergeFrom(
          from._internal_add_behavior_args());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_remove_behavior_args()->::TSWP::ContainedObjectsCommandArchive_RemoveBehaviorArgs::MergeFrom(
          from._internal_remove_behavior_args());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_rearrange_behavior_args()->::TSWP::ContainedObjectsCommandArchive_RearrangeBehaviorArgs::MergeFrom(
          from._internal_rearrange_behavior_args());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainedObjectsCommandArchive::CopyFrom(const ContainedObjectsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ContainedObjectsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainedObjectsCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.objects_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_target()) {
    if (!_impl_.target_->IsInitialized()) return false;
  }
  if (_internal_has_undo_object_for_commit()) {
    if (!_impl_.undo_object_for_commit_->IsInitialized()) return false;
  }
  if (_internal_has_undo_object_for_make_inverse()) {
    if (!_impl_.undo_object_for_make_inverse_->IsInitialized()) return false;
  }
  if (_internal_has_add_behavior_args()) {
    if (!_impl_.add_behavior_args_->IsInitialized()) return false;
  }
  if (_internal_has_remove_behavior_args()) {
    if (!_impl_.remove_behavior_args_->IsInitialized()) return false;
  }
  if (_internal_has_rearrange_behavior_args()) {
    if (!_impl_.rearrange_behavior_args_->IsInitialized()) return false;
  }
  return true;
}

void ContainedObjectsCommandArchive::InternalSwap(ContainedObjectsCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.objects_.InternalSwap(&other->_impl_.objects_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.container_name_, lhs_arena,
      &other->_impl_.container_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContainedObjectsCommandArchive, _impl_.rearrange_behavior_args_)
      + sizeof(ContainedObjectsCommandArchive::_impl_.rearrange_behavior_args_)
      - PROTOBUF_FIELD_OFFSET(ContainedObjectsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainedObjectsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[43]);
}

// ===================================================================

class EquationInfoGeometryCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<EquationInfoGeometryCommandArchive>()._impl_._has_bits_);
  static const ::TSD::MediaInfoGeometryCommandArchive& super(const EquationInfoGeometryCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSD::MediaInfoGeometryCommandArchive&
EquationInfoGeometryCommandArchive::_Internal::super(const EquationInfoGeometryCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void EquationInfoGeometryCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EquationInfoGeometryCommandArchive::EquationInfoGeometryCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.EquationInfoGeometryCommandArchive)
}
EquationInfoGeometryCommandArchive::EquationInfoGeometryCommandArchive(const EquationInfoGeometryCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EquationInfoGeometryCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::MediaInfoGeometryCommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.EquationInfoGeometryCommandArchive)
}

inline void EquationInfoGeometryCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

EquationInfoGeometryCommandArchive::~EquationInfoGeometryCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.EquationInfoGeometryCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EquationInfoGeometryCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void EquationInfoGeometryCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EquationInfoGeometryCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.EquationInfoGeometryCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EquationInfoGeometryCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.MediaInfoGeometryCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EquationInfoGeometryCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.EquationInfoGeometryCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.MediaInfoGeometryCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.EquationInfoGeometryCommandArchive)
  return target;
}

size_t EquationInfoGeometryCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.EquationInfoGeometryCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSD.MediaInfoGeometryCommandArchive super = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EquationInfoGeometryCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EquationInfoGeometryCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EquationInfoGeometryCommandArchive::GetClassData() const { return &_class_data_; }


void EquationInfoGeometryCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EquationInfoGeometryCommandArchive*>(&to_msg);
  auto& from = static_cast<const EquationInfoGeometryCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.EquationInfoGeometryCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSD::MediaInfoGeometryCommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EquationInfoGeometryCommandArchive::CopyFrom(const EquationInfoGeometryCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.EquationInfoGeometryCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EquationInfoGeometryCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void EquationInfoGeometryCommandArchive::InternalSwap(EquationInfoGeometryCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EquationInfoGeometryCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[44]);
}

// ===================================================================

class CharacterStyleChangePropertyCommand_GArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CharacterStyleChangePropertyCommand_GArchive>()._impl_._has_bits_);
  static const ::TSWP::StorageActionCommandArchive& super(const CharacterStyleChangePropertyCommand_GArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_range_list_undefined(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_change_list_undefined(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_disable_character_style_promotion(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000009) ^ 0x00000009) != 0;
  }
};

const ::TSWP::StorageActionCommandArchive&
CharacterStyleChangePropertyCommand_GArchive::_Internal::super(const CharacterStyleChangePropertyCommand_GArchive* msg) {
  return *msg->_impl_.super_;
}
void CharacterStyleChangePropertyCommand_GArchive::clear_range_list() {
  _impl_.range_list_.Clear();
}
void CharacterStyleChangePropertyCommand_GArchive::clear_change_list() {
  _impl_.change_list_.Clear();
}
CharacterStyleChangePropertyCommand_GArchive::CharacterStyleChangePropertyCommand_GArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.CharacterStyleChangePropertyCommand_GArchive)
}
CharacterStyleChangePropertyCommand_GArchive::CharacterStyleChangePropertyCommand_GArchive(const CharacterStyleChangePropertyCommand_GArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CharacterStyleChangePropertyCommand_GArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.range_list_){from._impl_.range_list_}
    , decltype(_impl_.change_list_){from._impl_.change_list_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.range_list_undefined_){}
    , decltype(_impl_.change_list_undefined_){}
    , decltype(_impl_.disable_character_style_promotion_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::StorageActionCommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.range_list_undefined_, &from._impl_.range_list_undefined_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.disable_character_style_promotion_) -
    reinterpret_cast<char*>(&_impl_.range_list_undefined_)) + sizeof(_impl_.disable_character_style_promotion_));
  // @@protoc_insertion_point(copy_constructor:TSWP.CharacterStyleChangePropertyCommand_GArchive)
}

inline void CharacterStyleChangePropertyCommand_GArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.range_list_){arena}
    , decltype(_impl_.change_list_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.range_list_undefined_){false}
    , decltype(_impl_.change_list_undefined_){false}
    , decltype(_impl_.disable_character_style_promotion_){false}
  };
}

CharacterStyleChangePropertyCommand_GArchive::~CharacterStyleChangePropertyCommand_GArchive() {
  // @@protoc_insertion_point(destructor:TSWP.CharacterStyleChangePropertyCommand_GArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CharacterStyleChangePropertyCommand_GArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.range_list_.~RepeatedPtrField();
  _impl_.change_list_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CharacterStyleChangePropertyCommand_GArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CharacterStyleChangePropertyCommand_GArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.CharacterStyleChangePropertyCommand_GArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.range_list_.Clear();
  _impl_.change_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  ::memset(&_impl_.range_list_undefined_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.disable_character_style_promotion_) -
      reinterpret_cast<char*>(&_impl_.range_list_undefined_)) + sizeof(_impl_.disable_character_style_promotion_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CharacterStyleChangePropertyCommand_GArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSWP.StorageActionCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Range range_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_range_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool range_list_undefined = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_range_list_undefined(&has_bits);
          _impl_.range_list_undefined_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSWPSOS.CharacterStylePropertyChangeSetArchive change_list = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_change_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool change_list_undefined = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_change_list_undefined(&has_bits);
          _impl_.change_list_undefined_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool disable_character_style_promotion = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_disable_character_style_promotion(&has_bits);
          _impl_.disable_character_style_promotion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CharacterStyleChangePropertyCommand_GArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.CharacterStyleChangePropertyCommand_GArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSWP.StorageActionCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Range range_list = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_range_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_range_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool range_list_undefined = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_range_list_undefined(), target);
  }

  // repeated .TSWPSOS.CharacterStylePropertyChangeSetArchive change_list = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_change_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_change_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool change_list_undefined = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_change_list_undefined(), target);
  }

  // required bool disable_character_style_promotion = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_disable_character_style_promotion(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.CharacterStyleChangePropertyCommand_GArchive)
  return target;
}

size_t CharacterStyleChangePropertyCommand_GArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSWP.CharacterStyleChangePropertyCommand_GArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TSWP.StorageActionCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_disable_character_style_promotion()) {
    // required bool disable_character_style_promotion = 6;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CharacterStyleChangePropertyCommand_GArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.CharacterStyleChangePropertyCommand_GArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000009) ^ 0x00000009) == 0) {  // All required fields are present.
    // required .TSWP.StorageActionCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required bool disable_character_style_promotion = 6;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Range range_list = 2;
  total_size += 1UL * this->_internal_range_list_size();
  for (const auto& msg : this->_impl_.range_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSWPSOS.CharacterStylePropertyChangeSetArchive change_list = 4;
  total_size += 1UL * this->_internal_change_list_size();
  for (const auto& msg : this->_impl_.change_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional bool range_list_undefined = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool change_list_undefined = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CharacterStyleChangePropertyCommand_GArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CharacterStyleChangePropertyCommand_GArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CharacterStyleChangePropertyCommand_GArchive::GetClassData() const { return &_class_data_; }


void CharacterStyleChangePropertyCommand_GArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CharacterStyleChangePropertyCommand_GArchive*>(&to_msg);
  auto& from = static_cast<const CharacterStyleChangePropertyCommand_GArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.CharacterStyleChangePropertyCommand_GArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.range_list_.MergeFrom(from._impl_.range_list_);
  _this->_impl_.change_list_.MergeFrom(from._impl_.change_list_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::StorageActionCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.range_list_undefined_ = from._impl_.range_list_undefined_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.change_list_undefined_ = from._impl_.change_list_undefined_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.disable_character_style_promotion_ = from._impl_.disable_character_style_promotion_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CharacterStyleChangePropertyCommand_GArchive::CopyFrom(const CharacterStyleChangePropertyCommand_GArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.CharacterStyleChangePropertyCommand_GArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CharacterStyleChangePropertyCommand_GArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.range_list_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.change_list_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CharacterStyleChangePropertyCommand_GArchive::InternalSwap(CharacterStyleChangePropertyCommand_GArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.range_list_.InternalSwap(&other->_impl_.range_list_);
  _impl_.change_list_.InternalSwap(&other->_impl_.change_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CharacterStyleChangePropertyCommand_GArchive, _impl_.disable_character_style_promotion_)
      + sizeof(CharacterStyleChangePropertyCommand_GArchive::_impl_.disable_character_style_promotion_)
      - PROTOBUF_FIELD_OFFSET(CharacterStyleChangePropertyCommand_GArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CharacterStyleChangePropertyCommand_GArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[45]);
}

// ===================================================================

class ParagraphStyleChangePropertyCommand_GArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ParagraphStyleChangePropertyCommand_GArchive>()._impl_._has_bits_);
  static const ::TSWP::StorageActionCommandArchive& super(const ParagraphStyleChangePropertyCommand_GArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_range_list_undefined(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_change_list_undefined(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSWP::StorageActionCommandArchive&
ParagraphStyleChangePropertyCommand_GArchive::_Internal::super(const ParagraphStyleChangePropertyCommand_GArchive* msg) {
  return *msg->_impl_.super_;
}
void ParagraphStyleChangePropertyCommand_GArchive::clear_range_list() {
  _impl_.range_list_.Clear();
}
void ParagraphStyleChangePropertyCommand_GArchive::clear_change_list() {
  _impl_.change_list_.Clear();
}
ParagraphStyleChangePropertyCommand_GArchive::ParagraphStyleChangePropertyCommand_GArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ParagraphStyleChangePropertyCommand_GArchive)
}
ParagraphStyleChangePropertyCommand_GArchive::ParagraphStyleChangePropertyCommand_GArchive(const ParagraphStyleChangePropertyCommand_GArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ParagraphStyleChangePropertyCommand_GArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.range_list_){from._impl_.range_list_}
    , decltype(_impl_.change_list_){from._impl_.change_list_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.range_list_undefined_){}
    , decltype(_impl_.change_list_undefined_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::StorageActionCommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.range_list_undefined_, &from._impl_.range_list_undefined_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.change_list_undefined_) -
    reinterpret_cast<char*>(&_impl_.range_list_undefined_)) + sizeof(_impl_.change_list_undefined_));
  // @@protoc_insertion_point(copy_constructor:TSWP.ParagraphStyleChangePropertyCommand_GArchive)
}

inline void ParagraphStyleChangePropertyCommand_GArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.range_list_){arena}
    , decltype(_impl_.change_list_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.range_list_undefined_){false}
    , decltype(_impl_.change_list_undefined_){false}
  };
}

ParagraphStyleChangePropertyCommand_GArchive::~ParagraphStyleChangePropertyCommand_GArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ParagraphStyleChangePropertyCommand_GArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ParagraphStyleChangePropertyCommand_GArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.range_list_.~RepeatedPtrField();
  _impl_.change_list_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ParagraphStyleChangePropertyCommand_GArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ParagraphStyleChangePropertyCommand_GArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ParagraphStyleChangePropertyCommand_GArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.range_list_.Clear();
  _impl_.change_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  ::memset(&_impl_.range_list_undefined_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.change_list_undefined_) -
      reinterpret_cast<char*>(&_impl_.range_list_undefined_)) + sizeof(_impl_.change_list_undefined_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ParagraphStyleChangePropertyCommand_GArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSWP.StorageActionCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Range range_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_range_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool range_list_undefined = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_range_list_undefined(&has_bits);
          _impl_.range_list_undefined_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSWPSOS.ParagraphStylePropertyChangeSetArchive change_list = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_change_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool change_list_undefined = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_change_list_undefined(&has_bits);
          _impl_.change_list_undefined_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ParagraphStyleChangePropertyCommand_GArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ParagraphStyleChangePropertyCommand_GArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSWP.StorageActionCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Range range_list = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_range_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_range_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool range_list_undefined = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_range_list_undefined(), target);
  }

  // repeated .TSWPSOS.ParagraphStylePropertyChangeSetArchive change_list = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_change_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_change_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool change_list_undefined = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_change_list_undefined(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ParagraphStyleChangePropertyCommand_GArchive)
  return target;
}

size_t ParagraphStyleChangePropertyCommand_GArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ParagraphStyleChangePropertyCommand_GArchive)
  size_t total_size = 0;

  // required .TSWP.StorageActionCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Range range_list = 2;
  total_size += 1UL * this->_internal_range_list_size();
  for (const auto& msg : this->_impl_.range_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSWPSOS.ParagraphStylePropertyChangeSetArchive change_list = 4;
  total_size += 1UL * this->_internal_change_list_size();
  for (const auto& msg : this->_impl_.change_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional bool range_list_undefined = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool change_list_undefined = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ParagraphStyleChangePropertyCommand_GArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ParagraphStyleChangePropertyCommand_GArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ParagraphStyleChangePropertyCommand_GArchive::GetClassData() const { return &_class_data_; }


void ParagraphStyleChangePropertyCommand_GArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ParagraphStyleChangePropertyCommand_GArchive*>(&to_msg);
  auto& from = static_cast<const ParagraphStyleChangePropertyCommand_GArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ParagraphStyleChangePropertyCommand_GArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.range_list_.MergeFrom(from._impl_.range_list_);
  _this->_impl_.change_list_.MergeFrom(from._impl_.change_list_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::StorageActionCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.range_list_undefined_ = from._impl_.range_list_undefined_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.change_list_undefined_ = from._impl_.change_list_undefined_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ParagraphStyleChangePropertyCommand_GArchive::CopyFrom(const ParagraphStyleChangePropertyCommand_GArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ParagraphStyleChangePropertyCommand_GArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParagraphStyleChangePropertyCommand_GArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.range_list_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.change_list_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ParagraphStyleChangePropertyCommand_GArchive::InternalSwap(ParagraphStyleChangePropertyCommand_GArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.range_list_.InternalSwap(&other->_impl_.range_list_);
  _impl_.change_list_.InternalSwap(&other->_impl_.change_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ParagraphStyleChangePropertyCommand_GArchive, _impl_.change_list_undefined_)
      + sizeof(ParagraphStyleChangePropertyCommand_GArchive::_impl_.change_list_undefined_)
      - PROTOBUF_FIELD_OFFSET(ParagraphStyleChangePropertyCommand_GArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ParagraphStyleChangePropertyCommand_GArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[46]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace TSWP
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::TSWP::DummyCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::DummyCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::DummyCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::TextCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::TextCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::TextCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::StorageActionCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::StorageActionCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::StorageActionCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::SetColumnStyleCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::SetColumnStyleCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::SetColumnStyleCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ReplaceAllUsesOfStyleCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ReplaceAllUsesOfStyleCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ReplaceAllUsesOfStyleCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::InsertColumnsCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::InsertColumnsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::InsertColumnsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::InsertRowsCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::InsertRowsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::InsertRowsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::RemoveColumnsCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::RemoveColumnsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::RemoveColumnsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::RemoveRowsCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::RemoveRowsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::RemoveRowsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::MergeCellsCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::MergeCellsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::MergeCellsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ApplyPlaceholderTextCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ApplyPlaceholderTextCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ApplyPlaceholderTextCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::UpdateDateTimeFieldCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::UpdateDateTimeFieldCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::UpdateDateTimeFieldCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ApplyRubyTextCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ApplyRubyTextCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ApplyRubyTextCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ModifyRubyTextCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ModifyRubyTextCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ModifyRubyTextCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ModifyTOCSettingsBaseCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ModifyTOCSettingsBaseCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ModifyTOCSettingsBaseCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::AnchorAttachmentCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::AnchorAttachmentCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::AnchorAttachmentCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::TextApplyThemeCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::TextApplyThemeCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::TextApplyThemeCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::MoveColumnsCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::MoveColumnsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::MoveColumnsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::MoveRowsCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::MoveRowsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::MoveRowsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ShapeApplyPresetCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ShapeApplyPresetCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ShapeApplyPresetCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::StyleBaseCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::StyleBaseCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::StyleBaseCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::StyleCreateCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::StyleCreateCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::StyleCreateCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::StyleRenameCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::StyleRenameCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::StyleRenameCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::StyleUpdateCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::StyleUpdateCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::StyleUpdateCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::StyleDeleteCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::StyleDeleteCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::StyleDeleteCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::StyleReorderCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::StyleReorderCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::StyleReorderCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::StyleUpdatePropertyMapCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::StyleUpdatePropertyMapCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::StyleUpdatePropertyMapCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ShapeStyleSetValueCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ShapeStyleSetValueCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ShapeStyleSetValueCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::SelectionTransformerArchive*
Arena::CreateMaybeMessage< ::TSWP::SelectionTransformerArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::SelectionTransformerArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::PencilAnnotationSelectionTransformerArchive*
Arena::CreateMaybeMessage< ::TSWP::PencilAnnotationSelectionTransformerArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::PencilAnnotationSelectionTransformerArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ShapeSelectionTransformerArchive*
Arena::CreateMaybeMessage< ::TSWP::ShapeSelectionTransformerArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ShapeSelectionTransformerArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ShapeContentDescription*
Arena::CreateMaybeMessage< ::TSWP::ShapeContentDescription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ShapeContentDescription >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ObjectPropertyArchive*
Arena::CreateMaybeMessage< ::TSWP::ObjectPropertyArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ObjectPropertyArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::SetObjectPropertiesCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::SetObjectPropertiesCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::SetObjectPropertiesCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::UpdateFlowInfoCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::UpdateFlowInfoCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::UpdateFlowInfoCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::AddFlowInfoCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::AddFlowInfoCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::AddFlowInfoCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::RemoveFlowInfoCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::RemoveFlowInfoCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::RemoveFlowInfoCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::TextCommentReplyCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::TextCommentReplyCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::TextCommentReplyCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ContainedObjectsCommandArchive_AddBehaviorArgs*
Arena::CreateMaybeMessage< ::TSWP::ContainedObjectsCommandArchive_AddBehaviorArgs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ContainedObjectsCommandArchive_AddBehaviorArgs >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ContainedObjectsCommandArchive_RemoveBehaviorArgs*
Arena::CreateMaybeMessage< ::TSWP::ContainedObjectsCommandArchive_RemoveBehaviorArgs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ContainedObjectsCommandArchive_RemoveBehaviorArgs >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ContainedObjectsCommandArchive_RearrangeBehaviorArgs*
Arena::CreateMaybeMessage< ::TSWP::ContainedObjectsCommandArchive_RearrangeBehaviorArgs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ContainedObjectsCommandArchive_RearrangeBehaviorArgs >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ContainedObjectsCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ContainedObjectsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ContainedObjectsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::EquationInfoGeometryCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::EquationInfoGeometryCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::EquationInfoGeometryCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::CharacterStyleChangePropertyCommand_GArchive*
Arena::CreateMaybeMessage< ::TSWP::CharacterStyleChangePropertyCommand_GArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::CharacterStyleChangePropertyCommand_GArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ParagraphStyleChangePropertyCommand_GArchive*
Arena::CreateMaybeMessage< ::TSWP::ParagraphStyleChangePropertyCommand_GArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ParagraphStyleChangePropertyCommand_GArchive >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
