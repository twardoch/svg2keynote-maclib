// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSPMessages.proto

#include "TSPMessages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace TSP {
PROTOBUF_CONSTEXPR Reference::Reference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.identifier_)*/uint64_t{0u}
  , /*decltype(_impl_.deprecated_type_)*/0
  , /*decltype(_impl_.deprecated_is_external_)*/false} {}
struct ReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReferenceDefaultTypeInternal() {}
  union {
    Reference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReferenceDefaultTypeInternal _Reference_default_instance_;
PROTOBUF_CONSTEXPR DataReference::DataReference(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.identifier_)*/uint64_t{0u}} {}
struct DataReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataReferenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataReferenceDefaultTypeInternal() {}
  union {
    DataReference _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataReferenceDefaultTypeInternal _DataReference_default_instance_;
PROTOBUF_CONSTEXPR SparseReferenceArray_Entry::SparseReferenceArray_Entry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.reference_)*/nullptr
  , /*decltype(_impl_.index_)*/0u} {}
struct SparseReferenceArray_EntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SparseReferenceArray_EntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SparseReferenceArray_EntryDefaultTypeInternal() {}
  union {
    SparseReferenceArray_Entry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SparseReferenceArray_EntryDefaultTypeInternal _SparseReferenceArray_Entry_default_instance_;
PROTOBUF_CONSTEXPR SparseReferenceArray::SparseReferenceArray(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entries_)*/{}
  , /*decltype(_impl_.count_)*/0u} {}
struct SparseReferenceArrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SparseReferenceArrayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SparseReferenceArrayDefaultTypeInternal() {}
  union {
    SparseReferenceArray _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SparseReferenceArrayDefaultTypeInternal _SparseReferenceArray_default_instance_;
PROTOBUF_CONSTEXPR Point::Point(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct PointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointDefaultTypeInternal() {}
  union {
    Point _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointDefaultTypeInternal _Point_default_instance_;
PROTOBUF_CONSTEXPR Size::Size(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.height_)*/0} {}
struct SizeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SizeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SizeDefaultTypeInternal() {}
  union {
    Size _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SizeDefaultTypeInternal _Size_default_instance_;
PROTOBUF_CONSTEXPR Range::Range(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.location_)*/0u
  , /*decltype(_impl_.length_)*/0u} {}
struct RangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RangeDefaultTypeInternal() {}
  union {
    Range _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RangeDefaultTypeInternal _Range_default_instance_;
PROTOBUF_CONSTEXPR Date::Date(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.seconds_)*/0} {}
struct DateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DateDefaultTypeInternal() {}
  union {
    Date _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DateDefaultTypeInternal _Date_default_instance_;
PROTOBUF_CONSTEXPR IndexSet::IndexSet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ranges_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IndexSetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IndexSetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IndexSetDefaultTypeInternal() {}
  union {
    IndexSet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IndexSetDefaultTypeInternal _IndexSet_default_instance_;
PROTOBUF_CONSTEXPR Color::Color(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.r_)*/0
  , /*decltype(_impl_.g_)*/0
  , /*decltype(_impl_.b_)*/0
  , /*decltype(_impl_.c_)*/0
  , /*decltype(_impl_.m_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.k_)*/0
  , /*decltype(_impl_.w_)*/0
  , /*decltype(_impl_.rgbspace_)*/1
  , /*decltype(_impl_.model_)*/1
  , /*decltype(_impl_.a_)*/1} {}
struct ColorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ColorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ColorDefaultTypeInternal() {}
  union {
    Color _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ColorDefaultTypeInternal _Color_default_instance_;
PROTOBUF_CONSTEXPR Path_Element::Path_Element(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.points_)*/{}
  , /*decltype(_impl_.type_)*/1} {}
struct Path_ElementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Path_ElementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Path_ElementDefaultTypeInternal() {}
  union {
    Path_Element _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Path_ElementDefaultTypeInternal _Path_Element_default_instance_;
PROTOBUF_CONSTEXPR Path::Path(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.elements_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PathDefaultTypeInternal() {}
  union {
    Path _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PathDefaultTypeInternal _Path_default_instance_;
PROTOBUF_CONSTEXPR ReferenceDictionary_Entry::ReferenceDictionary_Entry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/nullptr
  , /*decltype(_impl_.value_)*/nullptr} {}
struct ReferenceDictionary_EntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReferenceDictionary_EntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReferenceDictionary_EntryDefaultTypeInternal() {}
  union {
    ReferenceDictionary_Entry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReferenceDictionary_EntryDefaultTypeInternal _ReferenceDictionary_Entry_default_instance_;
PROTOBUF_CONSTEXPR ReferenceDictionary::ReferenceDictionary(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entries_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReferenceDictionaryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReferenceDictionaryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReferenceDictionaryDefaultTypeInternal() {}
  union {
    ReferenceDictionary _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReferenceDictionaryDefaultTypeInternal _ReferenceDictionary_default_instance_;
PROTOBUF_CONSTEXPR UUID::UUID(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lower_)*/uint64_t{0u}
  , /*decltype(_impl_.upper_)*/uint64_t{0u}} {}
struct UUIDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UUIDDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UUIDDefaultTypeInternal() {}
  union {
    UUID _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UUIDDefaultTypeInternal _UUID_default_instance_;
PROTOBUF_CONSTEXPR CFUUIDArchive::CFUUIDArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.uuid_bytes_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uuid_w0_)*/0u
  , /*decltype(_impl_.uuid_w1_)*/0u
  , /*decltype(_impl_.uuid_w2_)*/0u
  , /*decltype(_impl_.uuid_w3_)*/0u} {}
struct CFUUIDArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CFUUIDArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CFUUIDArchiveDefaultTypeInternal() {}
  union {
    CFUUIDArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CFUUIDArchiveDefaultTypeInternal _CFUUIDArchive_default_instance_;
PROTOBUF_CONSTEXPR UUIDSetArchive::UUIDSetArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.uids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UUIDSetArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UUIDSetArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UUIDSetArchiveDefaultTypeInternal() {}
  union {
    UUIDSetArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UUIDSetArchiveDefaultTypeInternal _UUIDSetArchive_default_instance_;
PROTOBUF_CONSTEXPR UUIDMapArchive::UUIDMapArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_)*/{}
  , /*decltype(_impl_.target_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UUIDMapArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UUIDMapArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UUIDMapArchiveDefaultTypeInternal() {}
  union {
    UUIDMapArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UUIDMapArchiveDefaultTypeInternal _UUIDMapArchive_default_instance_;
PROTOBUF_CONSTEXPR UUIDMultiMapArchive::UUIDMultiMapArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_)*/{}
  , /*decltype(_impl_.target_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UUIDMultiMapArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UUIDMultiMapArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UUIDMultiMapArchiveDefaultTypeInternal() {}
  union {
    UUIDMultiMapArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UUIDMultiMapArchiveDefaultTypeInternal _UUIDMultiMapArchive_default_instance_;
PROTOBUF_CONSTEXPR UUIDCoordArchive::UUIDCoordArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.row_uid_)*/nullptr
  , /*decltype(_impl_.column_uid_)*/nullptr} {}
struct UUIDCoordArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UUIDCoordArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UUIDCoordArchiveDefaultTypeInternal() {}
  union {
    UUIDCoordArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UUIDCoordArchiveDefaultTypeInternal _UUIDCoordArchive_default_instance_;
PROTOBUF_CONSTEXPR UUIDRectArchive::UUIDRectArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.column_uids_)*/{}
  , /*decltype(_impl_.row_uids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UUIDRectArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UUIDRectArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UUIDRectArchiveDefaultTypeInternal() {}
  union {
    UUIDRectArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UUIDRectArchiveDefaultTypeInternal _UUIDRectArchive_default_instance_;
PROTOBUF_CONSTEXPR SparseUUIDArray_Entry::SparseUUIDArray_Entry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.uuid_)*/nullptr
  , /*decltype(_impl_.index_)*/0u} {}
struct SparseUUIDArray_EntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SparseUUIDArray_EntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SparseUUIDArray_EntryDefaultTypeInternal() {}
  union {
    SparseUUIDArray_Entry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SparseUUIDArray_EntryDefaultTypeInternal _SparseUUIDArray_Entry_default_instance_;
PROTOBUF_CONSTEXPR SparseUUIDArray::SparseUUIDArray(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entries_)*/{}
  , /*decltype(_impl_.count_)*/0u} {}
struct SparseUUIDArrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SparseUUIDArrayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SparseUUIDArrayDefaultTypeInternal() {}
  union {
    SparseUUIDArray _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SparseUUIDArrayDefaultTypeInternal _SparseUUIDArray_default_instance_;
PROTOBUF_CONSTEXPR UUIDPath::UUIDPath(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.uuids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UUIDPathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UUIDPathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UUIDPathDefaultTypeInternal() {}
  union {
    UUIDPath _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UUIDPathDefaultTypeInternal _UUIDPath_default_instance_;
PROTOBUF_CONSTEXPR SparseUUIDPathArray_Entry::SparseUUIDPathArray_Entry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.uuid_path_)*/nullptr
  , /*decltype(_impl_.index_)*/0u} {}
struct SparseUUIDPathArray_EntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SparseUUIDPathArray_EntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SparseUUIDPathArray_EntryDefaultTypeInternal() {}
  union {
    SparseUUIDPathArray_Entry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SparseUUIDPathArray_EntryDefaultTypeInternal _SparseUUIDPathArray_Entry_default_instance_;
PROTOBUF_CONSTEXPR SparseUUIDPathArray::SparseUUIDPathArray(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entries_)*/{}
  , /*decltype(_impl_.count_)*/0u} {}
struct SparseUUIDPathArrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SparseUUIDPathArrayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SparseUUIDPathArrayDefaultTypeInternal() {}
  union {
    SparseUUIDPathArray _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SparseUUIDPathArrayDefaultTypeInternal _SparseUUIDPathArray_default_instance_;
PROTOBUF_CONSTEXPR PasteboardObject::PasteboardObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drawables_)*/{}
  , /*decltype(_impl_.styles_)*/{}
  , /*decltype(_impl_.presets_)*/{}
  , /*decltype(_impl_.top_level_objects_)*/{}
  , /*decltype(_impl_.stylesheet_)*/nullptr
  , /*decltype(_impl_.wp_storage_)*/nullptr
  , /*decltype(_impl_.app_native_object_)*/nullptr
  , /*decltype(_impl_.guide_storage_)*/nullptr
  , /*decltype(_impl_.native_content_description_)*/nullptr
  , /*decltype(_impl_.is_text_primary_)*/false
  , /*decltype(_impl_.is_smart_)*/false} {}
struct PasteboardObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PasteboardObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PasteboardObjectDefaultTypeInternal() {}
  union {
    PasteboardObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasteboardObjectDefaultTypeInternal _PasteboardObject_default_instance_;
PROTOBUF_CONSTEXPR ObjectCollection::ObjectCollection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.objects_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ObjectCollectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ObjectCollectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ObjectCollectionDefaultTypeInternal() {}
  union {
    ObjectCollection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ObjectCollectionDefaultTypeInternal _ObjectCollection_default_instance_;
PROTOBUF_CONSTEXPR ObjectContainer::ObjectContainer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.objects_)*/{}
  , /*decltype(_impl_.identifier_)*/0u} {}
struct ObjectContainerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ObjectContainerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ObjectContainerDefaultTypeInternal() {}
  union {
    ObjectContainer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ObjectContainerDefaultTypeInternal _ObjectContainer_default_instance_;
PROTOBUF_CONSTEXPR DataAttributes::DataAttributes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DataAttributesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataAttributesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataAttributesDefaultTypeInternal() {}
  union {
    DataAttributes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataAttributesDefaultTypeInternal _DataAttributes_default_instance_;
PROTOBUF_CONSTEXPR LargeArraySegment::LargeArraySegment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.package_locator_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.should_delay_archiving_)*/false
  , /*decltype(_impl_.delayed_archiving_priority_)*/0u} {}
struct LargeArraySegmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LargeArraySegmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LargeArraySegmentDefaultTypeInternal() {}
  union {
    LargeArraySegment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LargeArraySegmentDefaultTypeInternal _LargeArraySegment_default_instance_;
PROTOBUF_CONSTEXPR LargeNumberArraySegment::LargeNumberArraySegment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.elements_)*/{}
  , /*decltype(_impl_.large_array_segment_)*/nullptr} {}
struct LargeNumberArraySegmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LargeNumberArraySegmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LargeNumberArraySegmentDefaultTypeInternal() {}
  union {
    LargeNumberArraySegment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LargeNumberArraySegmentDefaultTypeInternal _LargeNumberArraySegment_default_instance_;
PROTOBUF_CONSTEXPR LargeStringArraySegment_OptionalElement::LargeStringArraySegment_OptionalElement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.element_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LargeStringArraySegment_OptionalElementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LargeStringArraySegment_OptionalElementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LargeStringArraySegment_OptionalElementDefaultTypeInternal() {}
  union {
    LargeStringArraySegment_OptionalElement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LargeStringArraySegment_OptionalElementDefaultTypeInternal _LargeStringArraySegment_OptionalElement_default_instance_;
PROTOBUF_CONSTEXPR LargeStringArraySegment::LargeStringArraySegment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.elements_)*/{}
  , /*decltype(_impl_.large_array_segment_)*/nullptr} {}
struct LargeStringArraySegmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LargeStringArraySegmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LargeStringArraySegmentDefaultTypeInternal() {}
  union {
    LargeStringArraySegment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LargeStringArraySegmentDefaultTypeInternal _LargeStringArraySegment_default_instance_;
PROTOBUF_CONSTEXPR LargeUUIDArraySegment::LargeUUIDArraySegment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.elements_)*/{}
  , /*decltype(_impl_.large_array_segment_)*/nullptr} {}
struct LargeUUIDArraySegmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LargeUUIDArraySegmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LargeUUIDArraySegmentDefaultTypeInternal() {}
  union {
    LargeUUIDArraySegment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LargeUUIDArraySegmentDefaultTypeInternal _LargeUUIDArraySegment_default_instance_;
PROTOBUF_CONSTEXPR LargeLazyObjectArraySegment::LargeLazyObjectArraySegment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.elements_)*/{}
  , /*decltype(_impl_.large_array_segment_)*/nullptr} {}
struct LargeLazyObjectArraySegmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LargeLazyObjectArraySegmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LargeLazyObjectArraySegmentDefaultTypeInternal() {}
  union {
    LargeLazyObjectArraySegment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LargeLazyObjectArraySegmentDefaultTypeInternal _LargeLazyObjectArraySegment_default_instance_;
PROTOBUF_CONSTEXPR LargeObjectArraySegment::LargeObjectArraySegment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.elements_)*/{}
  , /*decltype(_impl_.large_array_segment_)*/nullptr} {}
struct LargeObjectArraySegmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LargeObjectArraySegmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LargeObjectArraySegmentDefaultTypeInternal() {}
  union {
    LargeObjectArraySegment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LargeObjectArraySegmentDefaultTypeInternal _LargeObjectArraySegment_default_instance_;
PROTOBUF_CONSTEXPR LargeArray::LargeArray(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ranges_)*/{}
  , /*decltype(_impl_.segments_)*/{}
  , /*decltype(_impl_.max_segment_element_count_)*/uint64_t{0u}
  , /*decltype(_impl_.max_segment_size_)*/uint64_t{0u}
  , /*decltype(_impl_.delayed_archiving_priority_)*/0u
  , /*decltype(_impl_.should_delay_archiving_)*/false
  , /*decltype(_impl_.store_outside_object_archive_)*/false
  , /*decltype(_impl_.estimated_byte_size_)*/uint64_t{0u}
  , /*decltype(_impl_.max_segment_cost_)*/uint64_t{0u}} {}
struct LargeArrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LargeArrayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LargeArrayDefaultTypeInternal() {}
  union {
    LargeArray _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LargeArrayDefaultTypeInternal _LargeArray_default_instance_;
PROTOBUF_CONSTEXPR LargeNumberArray::LargeNumberArray(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.large_array_)*/nullptr} {}
struct LargeNumberArrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LargeNumberArrayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LargeNumberArrayDefaultTypeInternal() {}
  union {
    LargeNumberArray _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LargeNumberArrayDefaultTypeInternal _LargeNumberArray_default_instance_;
PROTOBUF_CONSTEXPR LargeStringArray::LargeStringArray(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.large_array_)*/nullptr} {}
struct LargeStringArrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LargeStringArrayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LargeStringArrayDefaultTypeInternal() {}
  union {
    LargeStringArray _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LargeStringArrayDefaultTypeInternal _LargeStringArray_default_instance_;
PROTOBUF_CONSTEXPR LargeLazyObjectArray::LargeLazyObjectArray(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.large_array_)*/nullptr} {}
struct LargeLazyObjectArrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LargeLazyObjectArrayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LargeLazyObjectArrayDefaultTypeInternal() {}
  union {
    LargeLazyObjectArray _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LargeLazyObjectArrayDefaultTypeInternal _LargeLazyObjectArray_default_instance_;
PROTOBUF_CONSTEXPR LargeObjectArray::LargeObjectArray(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.large_array_)*/nullptr} {}
struct LargeObjectArrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LargeObjectArrayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LargeObjectArrayDefaultTypeInternal() {}
  union {
    LargeObjectArray _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LargeObjectArrayDefaultTypeInternal _LargeObjectArray_default_instance_;
PROTOBUF_CONSTEXPR LargeUUIDArray::LargeUUIDArray(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.large_array_)*/nullptr} {}
struct LargeUUIDArrayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LargeUUIDArrayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LargeUUIDArrayDefaultTypeInternal() {}
  union {
    LargeUUIDArray _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LargeUUIDArrayDefaultTypeInternal _LargeUUIDArray_default_instance_;
}  // namespace TSP
static ::_pb::Metadata file_level_metadata_TSPMessages_2eproto[43];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_TSPMessages_2eproto[4];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_TSPMessages_2eproto = nullptr;

const uint32_t TableStruct_TSPMessages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::TSP::Reference, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::Reference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::Reference, _impl_.identifier_),
  PROTOBUF_FIELD_OFFSET(::TSP::Reference, _impl_.deprecated_type_),
  PROTOBUF_FIELD_OFFSET(::TSP::Reference, _impl_.deprecated_is_external_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSP::DataReference, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::DataReference, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::DataReference, _impl_.identifier_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSP::SparseReferenceArray_Entry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::SparseReferenceArray_Entry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::SparseReferenceArray_Entry, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::TSP::SparseReferenceArray_Entry, _impl_.reference_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::TSP::SparseReferenceArray, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::SparseReferenceArray, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::SparseReferenceArray, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::TSP::SparseReferenceArray, _impl_.entries_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TSP::Point, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::Point, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::Point, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::TSP::Point, _impl_.y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSP::Size, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::Size, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::Size, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::TSP::Size, _impl_.height_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSP::Range, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::Range, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::Range, _impl_.location_),
  PROTOBUF_FIELD_OFFSET(::TSP::Range, _impl_.length_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSP::Date, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::Date, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::Date, _impl_.seconds_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSP::IndexSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::IndexSet, _impl_.ranges_),
  PROTOBUF_FIELD_OFFSET(::TSP::Color, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::Color, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::Color, _impl_.model_),
  PROTOBUF_FIELD_OFFSET(::TSP::Color, _impl_.r_),
  PROTOBUF_FIELD_OFFSET(::TSP::Color, _impl_.g_),
  PROTOBUF_FIELD_OFFSET(::TSP::Color, _impl_.b_),
  PROTOBUF_FIELD_OFFSET(::TSP::Color, _impl_.rgbspace_),
  PROTOBUF_FIELD_OFFSET(::TSP::Color, _impl_.a_),
  PROTOBUF_FIELD_OFFSET(::TSP::Color, _impl_.c_),
  PROTOBUF_FIELD_OFFSET(::TSP::Color, _impl_.m_),
  PROTOBUF_FIELD_OFFSET(::TSP::Color, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::TSP::Color, _impl_.k_),
  PROTOBUF_FIELD_OFFSET(::TSP::Color, _impl_.w_),
  9,
  0,
  1,
  2,
  8,
  10,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::TSP::Path_Element, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::Path_Element, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::Path_Element, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSP::Path_Element, _impl_.points_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSP::Path, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::Path, _impl_.elements_),
  PROTOBUF_FIELD_OFFSET(::TSP::ReferenceDictionary_Entry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::ReferenceDictionary_Entry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::ReferenceDictionary_Entry, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::TSP::ReferenceDictionary_Entry, _impl_.value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSP::ReferenceDictionary, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::ReferenceDictionary, _impl_.entries_),
  PROTOBUF_FIELD_OFFSET(::TSP::UUID, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::UUID, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::UUID, _impl_.lower_),
  PROTOBUF_FIELD_OFFSET(::TSP::UUID, _impl_.upper_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSP::CFUUIDArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::CFUUIDArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::CFUUIDArchive, _impl_.uuid_bytes_),
  PROTOBUF_FIELD_OFFSET(::TSP::CFUUIDArchive, _impl_.uuid_w0_),
  PROTOBUF_FIELD_OFFSET(::TSP::CFUUIDArchive, _impl_.uuid_w1_),
  PROTOBUF_FIELD_OFFSET(::TSP::CFUUIDArchive, _impl_.uuid_w2_),
  PROTOBUF_FIELD_OFFSET(::TSP::CFUUIDArchive, _impl_.uuid_w3_),
  0,
  1,
  2,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDSetArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDSetArchive, _impl_.uids_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDMapArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDMapArchive, _impl_.source_),
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDMapArchive, _impl_.target_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDMultiMapArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDMultiMapArchive, _impl_.source_),
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDMultiMapArchive, _impl_.target_),
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDCoordArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDCoordArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDCoordArchive, _impl_.row_uid_),
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDCoordArchive, _impl_.column_uid_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDRectArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDRectArchive, _impl_.column_uids_),
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDRectArchive, _impl_.row_uids_),
  PROTOBUF_FIELD_OFFSET(::TSP::SparseUUIDArray_Entry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::SparseUUIDArray_Entry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::SparseUUIDArray_Entry, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::TSP::SparseUUIDArray_Entry, _impl_.uuid_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::TSP::SparseUUIDArray, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::SparseUUIDArray, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::SparseUUIDArray, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::TSP::SparseUUIDArray, _impl_.entries_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDPath, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::UUIDPath, _impl_.uuids_),
  PROTOBUF_FIELD_OFFSET(::TSP::SparseUUIDPathArray_Entry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::SparseUUIDPathArray_Entry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::SparseUUIDPathArray_Entry, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::TSP::SparseUUIDPathArray_Entry, _impl_.uuid_path_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::TSP::SparseUUIDPathArray, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::SparseUUIDPathArray, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::SparseUUIDPathArray, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::TSP::SparseUUIDPathArray, _impl_.entries_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TSP::PasteboardObject, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::PasteboardObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::PasteboardObject, _impl_.stylesheet_),
  PROTOBUF_FIELD_OFFSET(::TSP::PasteboardObject, _impl_.drawables_),
  PROTOBUF_FIELD_OFFSET(::TSP::PasteboardObject, _impl_.styles_),
  PROTOBUF_FIELD_OFFSET(::TSP::PasteboardObject, _impl_.wp_storage_),
  PROTOBUF_FIELD_OFFSET(::TSP::PasteboardObject, _impl_.guide_storage_),
  PROTOBUF_FIELD_OFFSET(::TSP::PasteboardObject, _impl_.app_native_object_),
  PROTOBUF_FIELD_OFFSET(::TSP::PasteboardObject, _impl_.is_text_primary_),
  PROTOBUF_FIELD_OFFSET(::TSP::PasteboardObject, _impl_.is_smart_),
  PROTOBUF_FIELD_OFFSET(::TSP::PasteboardObject, _impl_.presets_),
  PROTOBUF_FIELD_OFFSET(::TSP::PasteboardObject, _impl_.top_level_objects_),
  PROTOBUF_FIELD_OFFSET(::TSP::PasteboardObject, _impl_.native_content_description_),
  0,
  ~0u,
  ~0u,
  1,
  3,
  2,
  5,
  6,
  ~0u,
  ~0u,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSP::ObjectCollection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::ObjectCollection, _impl_.objects_),
  PROTOBUF_FIELD_OFFSET(::TSP::ObjectContainer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::ObjectContainer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::ObjectContainer, _impl_.identifier_),
  PROTOBUF_FIELD_OFFSET(::TSP::ObjectContainer, _impl_.objects_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSP::DataAttributes, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::TSP::DataAttributes, _impl_._extensions_),
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::LargeArraySegment, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeArraySegment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::LargeArraySegment, _impl_.should_delay_archiving_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeArraySegment, _impl_.delayed_archiving_priority_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeArraySegment, _impl_.package_locator_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::TSP::LargeNumberArraySegment, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeNumberArraySegment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::LargeNumberArraySegment, _impl_.large_array_segment_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeNumberArraySegment, _impl_.elements_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TSP::LargeStringArraySegment_OptionalElement, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeStringArraySegment_OptionalElement, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::LargeStringArraySegment_OptionalElement, _impl_.element_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSP::LargeStringArraySegment, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeStringArraySegment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::LargeStringArraySegment, _impl_.large_array_segment_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeStringArraySegment, _impl_.elements_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TSP::LargeUUIDArraySegment, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeUUIDArraySegment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::LargeUUIDArraySegment, _impl_.large_array_segment_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeUUIDArraySegment, _impl_.elements_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TSP::LargeLazyObjectArraySegment, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeLazyObjectArraySegment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::LargeLazyObjectArraySegment, _impl_.large_array_segment_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeLazyObjectArraySegment, _impl_.elements_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TSP::LargeObjectArraySegment, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeObjectArraySegment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::LargeObjectArraySegment, _impl_.large_array_segment_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeObjectArraySegment, _impl_.elements_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TSP::LargeArray, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeArray, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::LargeArray, _impl_.ranges_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeArray, _impl_.segments_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeArray, _impl_.max_segment_element_count_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeArray, _impl_.max_segment_size_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeArray, _impl_.should_delay_archiving_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeArray, _impl_.delayed_archiving_priority_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeArray, _impl_.store_outside_object_archive_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeArray, _impl_.estimated_byte_size_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeArray, _impl_.max_segment_cost_),
  ~0u,
  ~0u,
  0,
  1,
  3,
  2,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::TSP::LargeNumberArray, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeNumberArray, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::LargeNumberArray, _impl_.large_array_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSP::LargeStringArray, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeStringArray, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::LargeStringArray, _impl_.large_array_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSP::LargeLazyObjectArray, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeLazyObjectArray, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::LargeLazyObjectArray, _impl_.large_array_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSP::LargeObjectArray, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeObjectArray, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::LargeObjectArray, _impl_.large_array_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSP::LargeUUIDArray, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSP::LargeUUIDArray, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSP::LargeUUIDArray, _impl_.large_array_),
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, -1, sizeof(::TSP::Reference)},
  { 12, 19, -1, sizeof(::TSP::DataReference)},
  { 20, 28, -1, sizeof(::TSP::SparseReferenceArray_Entry)},
  { 30, 38, -1, sizeof(::TSP::SparseReferenceArray)},
  { 40, 48, -1, sizeof(::TSP::Point)},
  { 50, 58, -1, sizeof(::TSP::Size)},
  { 60, 68, -1, sizeof(::TSP::Range)},
  { 70, 77, -1, sizeof(::TSP::Date)},
  { 78, -1, -1, sizeof(::TSP::IndexSet)},
  { 85, 102, -1, sizeof(::TSP::Color)},
  { 113, 121, -1, sizeof(::TSP::Path_Element)},
  { 123, -1, -1, sizeof(::TSP::Path)},
  { 130, 138, -1, sizeof(::TSP::ReferenceDictionary_Entry)},
  { 140, -1, -1, sizeof(::TSP::ReferenceDictionary)},
  { 147, 155, -1, sizeof(::TSP::UUID)},
  { 157, 168, -1, sizeof(::TSP::CFUUIDArchive)},
  { 173, -1, -1, sizeof(::TSP::UUIDSetArchive)},
  { 180, -1, -1, sizeof(::TSP::UUIDMapArchive)},
  { 188, -1, -1, sizeof(::TSP::UUIDMultiMapArchive)},
  { 196, 204, -1, sizeof(::TSP::UUIDCoordArchive)},
  { 206, -1, -1, sizeof(::TSP::UUIDRectArchive)},
  { 214, 222, -1, sizeof(::TSP::SparseUUIDArray_Entry)},
  { 224, 232, -1, sizeof(::TSP::SparseUUIDArray)},
  { 234, -1, -1, sizeof(::TSP::UUIDPath)},
  { 241, 249, -1, sizeof(::TSP::SparseUUIDPathArray_Entry)},
  { 251, 259, -1, sizeof(::TSP::SparseUUIDPathArray)},
  { 261, 278, -1, sizeof(::TSP::PasteboardObject)},
  { 289, -1, -1, sizeof(::TSP::ObjectCollection)},
  { 296, 304, -1, sizeof(::TSP::ObjectContainer)},
  { 306, -1, -1, sizeof(::TSP::DataAttributes)},
  { 312, 321, -1, sizeof(::TSP::LargeArraySegment)},
  { 324, 332, -1, sizeof(::TSP::LargeNumberArraySegment)},
  { 334, 341, -1, sizeof(::TSP::LargeStringArraySegment_OptionalElement)},
  { 342, 350, -1, sizeof(::TSP::LargeStringArraySegment)},
  { 352, 360, -1, sizeof(::TSP::LargeUUIDArraySegment)},
  { 362, 370, -1, sizeof(::TSP::LargeLazyObjectArraySegment)},
  { 372, 380, -1, sizeof(::TSP::LargeObjectArraySegment)},
  { 382, 397, -1, sizeof(::TSP::LargeArray)},
  { 406, 413, -1, sizeof(::TSP::LargeNumberArray)},
  { 414, 421, -1, sizeof(::TSP::LargeStringArray)},
  { 422, 429, -1, sizeof(::TSP::LargeLazyObjectArray)},
  { 430, 437, -1, sizeof(::TSP::LargeObjectArray)},
  { 438, 445, -1, sizeof(::TSP::LargeUUIDArray)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::TSP::_Reference_default_instance_._instance,
  &::TSP::_DataReference_default_instance_._instance,
  &::TSP::_SparseReferenceArray_Entry_default_instance_._instance,
  &::TSP::_SparseReferenceArray_default_instance_._instance,
  &::TSP::_Point_default_instance_._instance,
  &::TSP::_Size_default_instance_._instance,
  &::TSP::_Range_default_instance_._instance,
  &::TSP::_Date_default_instance_._instance,
  &::TSP::_IndexSet_default_instance_._instance,
  &::TSP::_Color_default_instance_._instance,
  &::TSP::_Path_Element_default_instance_._instance,
  &::TSP::_Path_default_instance_._instance,
  &::TSP::_ReferenceDictionary_Entry_default_instance_._instance,
  &::TSP::_ReferenceDictionary_default_instance_._instance,
  &::TSP::_UUID_default_instance_._instance,
  &::TSP::_CFUUIDArchive_default_instance_._instance,
  &::TSP::_UUIDSetArchive_default_instance_._instance,
  &::TSP::_UUIDMapArchive_default_instance_._instance,
  &::TSP::_UUIDMultiMapArchive_default_instance_._instance,
  &::TSP::_UUIDCoordArchive_default_instance_._instance,
  &::TSP::_UUIDRectArchive_default_instance_._instance,
  &::TSP::_SparseUUIDArray_Entry_default_instance_._instance,
  &::TSP::_SparseUUIDArray_default_instance_._instance,
  &::TSP::_UUIDPath_default_instance_._instance,
  &::TSP::_SparseUUIDPathArray_Entry_default_instance_._instance,
  &::TSP::_SparseUUIDPathArray_default_instance_._instance,
  &::TSP::_PasteboardObject_default_instance_._instance,
  &::TSP::_ObjectCollection_default_instance_._instance,
  &::TSP::_ObjectContainer_default_instance_._instance,
  &::TSP::_DataAttributes_default_instance_._instance,
  &::TSP::_LargeArraySegment_default_instance_._instance,
  &::TSP::_LargeNumberArraySegment_default_instance_._instance,
  &::TSP::_LargeStringArraySegment_OptionalElement_default_instance_._instance,
  &::TSP::_LargeStringArraySegment_default_instance_._instance,
  &::TSP::_LargeUUIDArraySegment_default_instance_._instance,
  &::TSP::_LargeLazyObjectArraySegment_default_instance_._instance,
  &::TSP::_LargeObjectArraySegment_default_instance_._instance,
  &::TSP::_LargeArray_default_instance_._instance,
  &::TSP::_LargeNumberArray_default_instance_._instance,
  &::TSP::_LargeStringArray_default_instance_._instance,
  &::TSP::_LargeLazyObjectArray_default_instance_._instance,
  &::TSP::_LargeObjectArray_default_instance_._instance,
  &::TSP::_LargeUUIDArray_default_instance_._instance,
};

const char descriptor_table_protodef_TSPMessages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021TSPMessages.proto\022\003TSP\"X\n\tReference\022\022\n"
  "\nidentifier\030\001 \002(\004\022\027\n\017deprecated_type\030\002 \001"
  "(\005\022\036\n\026deprecated_is_external\030\003 \001(\010\"#\n\rDa"
  "taReference\022\022\n\nidentifier\030\001 \002(\004\"\222\001\n\024Spar"
  "seReferenceArray\022\r\n\005count\030\001 \002(\r\0220\n\007entri"
  "es\030\002 \003(\0132\037.TSP.SparseReferenceArray.Entr"
  "y\0329\n\005Entry\022\r\n\005index\030\001 \002(\r\022!\n\treference\030\002"
  " \002(\0132\016.TSP.Reference\"\035\n\005Point\022\t\n\001x\030\001 \002(\002"
  "\022\t\n\001y\030\002 \002(\002\"%\n\004Size\022\r\n\005width\030\001 \002(\002\022\016\n\006he"
  "ight\030\002 \002(\002\")\n\005Range\022\020\n\010location\030\001 \002(\r\022\016\n"
  "\006length\030\002 \002(\r\"\027\n\004Date\022\017\n\007seconds\030\001 \002(\001\"&"
  "\n\010IndexSet\022\032\n\006ranges\030\001 \003(\0132\n.TSP.Range\"\216"
  "\002\n\005Color\022$\n\005model\030\001 \002(\0162\025.TSP.Color.Colo"
  "rModel\022\t\n\001r\030\003 \001(\002\022\t\n\001g\030\004 \001(\002\022\t\n\001b\030\005 \001(\002\022"
  "*\n\010rgbspace\030\014 \001(\0162\030.TSP.Color.RGBColorSp"
  "ace\022\014\n\001a\030\006 \001(\002:\0011\022\t\n\001c\030\007 \001(\002\022\t\n\001m\030\010 \001(\002\022"
  "\t\n\001y\030\t \001(\002\022\t\n\001k\030\n \001(\002\022\t\n\001w\030\013 \001(\002\"*\n\nColo"
  "rModel\022\007\n\003rgb\020\001\022\010\n\004cmyk\020\002\022\t\n\005white\020\003\"!\n\r"
  "RGBColorSpace\022\010\n\004srgb\020\001\022\006\n\002p3\020\002\"\316\001\n\004Path"
  "\022#\n\010elements\030\001 \003(\0132\021.TSP.Path.Element\032J\n"
  "\007Element\022#\n\004type\030\001 \002(\0162\025.TSP.Path.Elemen"
  "tType\022\032\n\006points\030\002 \003(\0132\n.TSP.Point\"U\n\013Ele"
  "mentType\022\n\n\006moveTo\020\001\022\n\n\006lineTo\020\002\022\017\n\013quad"
  "CurveTo\020\003\022\013\n\007curveTo\020\004\022\020\n\014closeSubpath\020\005"
  "\"\213\001\n\023ReferenceDictionary\022/\n\007entries\030\001 \003("
  "\0132\036.TSP.ReferenceDictionary.Entry\032C\n\005Ent"
  "ry\022\033\n\003key\030\001 \002(\0132\016.TSP.Reference\022\035\n\005value"
  "\030\002 \002(\0132\016.TSP.Reference\"$\n\004UUID\022\r\n\005lower\030"
  "\001 \002(\004\022\r\n\005upper\030\002 \002(\004\"g\n\rCFUUIDArchive\022\022\n"
  "\nuuid_bytes\030\001 \001(\014\022\017\n\007uuid_w0\030\002 \001(\r\022\017\n\007uu"
  "id_w1\030\003 \001(\r\022\017\n\007uuid_w2\030\004 \001(\r\022\017\n\007uuid_w3\030"
  "\005 \001(\r\")\n\016UUIDSetArchive\022\027\n\004uids\030\001 \003(\0132\t."
  "TSP.UUID\"F\n\016UUIDMapArchive\022\031\n\006source\030\001 \003"
  "(\0132\t.TSP.UUID\022\031\n\006target\030\002 \003(\0132\t.TSP.UUID"
  "\"K\n\023UUIDMultiMapArchive\022\031\n\006source\030\001 \003(\0132"
  "\t.TSP.UUID\022\031\n\006target\030\002 \003(\0132\t.TSP.UUID\"M\n"
  "\020UUIDCoordArchive\022\032\n\007row_uid\030\001 \002(\0132\t.TSP"
  ".UUID\022\035\n\ncolumn_uid\030\002 \002(\0132\t.TSP.UUID\"N\n\017"
  "UUIDRectArchive\022\036\n\013column_uids\030\001 \003(\0132\t.T"
  "SP.UUID\022\033\n\010row_uids\030\002 \003(\0132\t.TSP.UUID\"~\n\017"
  "SparseUUIDArray\022\r\n\005count\030\001 \002(\r\022+\n\007entrie"
  "s\030\002 \003(\0132\032.TSP.SparseUUIDArray.Entry\032/\n\005E"
  "ntry\022\r\n\005index\030\001 \002(\r\022\027\n\004uuid\030\002 \002(\0132\t.TSP."
  "UUID\"$\n\010UUIDPath\022\030\n\005uuids\030\001 \003(\0132\t.TSP.UU"
  "ID\"\217\001\n\023SparseUUIDPathArray\022\r\n\005count\030\001 \002("
  "\r\022/\n\007entries\030\002 \003(\0132\036.TSP.SparseUUIDPathA"
  "rray.Entry\0328\n\005Entry\022\r\n\005index\030\001 \002(\r\022 \n\tuu"
  "id_path\030\002 \002(\0132\r.TSP.UUIDPath\"\250\003\n\020Pastebo"
  "ardObject\022\"\n\nstylesheet\030\001 \001(\0132\016.TSP.Refe"
  "rence\022!\n\tdrawables\030\002 \003(\0132\016.TSP.Reference"
  "\022\036\n\006styles\030\003 \003(\0132\016.TSP.Reference\022\"\n\nwp_s"
  "torage\030\005 \001(\0132\016.TSP.Reference\022%\n\rguide_st"
  "orage\030\t \001(\0132\016.TSP.Reference\022)\n\021app_nativ"
  "e_object\030\006 \001(\0132\016.TSP.Reference\022\036\n\017is_tex"
  "t_primary\030\007 \001(\010:\005false\022\027\n\010is_smart\030\010 \001(\010"
  ":\005false\022\037\n\007presets\030\n \003(\0132\016.TSP.Reference"
  "\022)\n\021top_level_objects\030\013 \003(\0132\016.TSP.Refere"
  "nce\0222\n\032native_content_description\030\014 \001(\0132"
  "\016.TSP.Reference\"3\n\020ObjectCollection\022\037\n\007o"
  "bjects\030\001 \003(\0132\016.TSP.Reference\"F\n\017ObjectCo"
  "ntainer\022\022\n\nidentifier\030\001 \001(\r\022\037\n\007objects\030\002"
  " \003(\0132\016.TSP.Reference\"\032\n\016DataAttributes*\010"
  "\010d\020\200\200\200\200\002\"p\n\021LargeArraySegment\022\036\n\026should_"
  "delay_archiving\030\001 \001(\010\022\"\n\032delayed_archivi"
  "ng_priority\030\002 \001(\r\022\027\n\017package_locator\030\003 \001"
  "(\t\"`\n\027LargeNumberArraySegment\0223\n\023large_a"
  "rray_segment\030\001 \001(\0132\026.TSP.LargeArraySegme"
  "nt\022\020\n\010elements\030\002 \003(\001\"\262\001\n\027LargeStringArra"
  "ySegment\0223\n\023large_array_segment\030\001 \001(\0132\026."
  "TSP.LargeArraySegment\022>\n\010elements\030\002 \003(\0132"
  ",.TSP.LargeStringArraySegment.OptionalEl"
  "ement\032\"\n\017OptionalElement\022\017\n\007element\030\001 \001("
  "\t\"i\n\025LargeUUIDArraySegment\0223\n\023large_arra"
  "y_segment\030\001 \001(\0132\026.TSP.LargeArraySegment\022"
  "\033\n\010elements\030\002 \003(\0132\t.TSP.UUID\"t\n\033LargeLaz"
  "yObjectArraySegment\0223\n\023large_array_segme"
  "nt\030\001 \001(\0132\026.TSP.LargeArraySegment\022 \n\010elem"
  "ents\030\002 \003(\0132\016.TSP.Reference\"p\n\027LargeObjec"
  "tArraySegment\0223\n\023large_array_segment\030\001 \001"
  "(\0132\026.TSP.LargeArraySegment\022 \n\010elements\030\002"
  " \003(\0132\016.TSP.Reference\"\250\002\n\nLargeArray\022\032\n\006r"
  "anges\030\001 \003(\0132\n.TSP.Range\022 \n\010segments\030\002 \003("
  "\0132\016.TSP.Reference\022!\n\031max_segment_element"
  "_count\030\003 \001(\004\022\030\n\020max_segment_size\030\004 \001(\004\022\036"
  "\n\026should_delay_archiving\030\005 \001(\010\022\"\n\032delaye"
  "d_archiving_priority\030\006 \001(\r\022$\n\034store_outs"
  "ide_object_archive\030\007 \001(\010\022\033\n\023estimated_by"
  "te_size\030\010 \001(\004\022\030\n\020max_segment_cost\030\t \001(\004\""
  "8\n\020LargeNumberArray\022$\n\013large_array\030\001 \001(\013"
  "2\017.TSP.LargeArray\"8\n\020LargeStringArray\022$\n"
  "\013large_array\030\001 \001(\0132\017.TSP.LargeArray\"<\n\024L"
  "argeLazyObjectArray\022$\n\013large_array\030\001 \001(\013"
  "2\017.TSP.LargeArray\"8\n\020LargeObjectArray\022$\n"
  "\013large_array\030\001 \001(\0132\017.TSP.LargeArray\"6\n\016L"
  "argeUUIDArray\022$\n\013large_array\030\001 \001(\0132\017.TSP"
  ".LargeArray*\354\001\n\020DataUploadStatus\022\034\n\030Data"
  "UploadStatus_Pending\020\000\022\035\n\031DataUploadStat"
  "us_Reserved\020\001\022$\n DataUploadStatus_Unable"
  "ToReserve\020\002\022\036\n\032DataUploadStatus_Corrupte"
  "d\020\003\0227\n3DataUploadStatus_DocumentMayExcee"
  "dDocumentSizeLimit\020\004\022\034\n\030DataUploadStatus"
  "_Expired\020\005"
  ;
static ::_pbi::once_flag descriptor_table_TSPMessages_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_TSPMessages_2eproto = {
    false, false, 4050, descriptor_table_protodef_TSPMessages_2eproto,
    "TSPMessages.proto",
    &descriptor_table_TSPMessages_2eproto_once, nullptr, 0, 43,
    schemas, file_default_instances, TableStruct_TSPMessages_2eproto::offsets,
    file_level_metadata_TSPMessages_2eproto, file_level_enum_descriptors_TSPMessages_2eproto,
    file_level_service_descriptors_TSPMessages_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_TSPMessages_2eproto_getter() {
  return &descriptor_table_TSPMessages_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_TSPMessages_2eproto(&descriptor_table_TSPMessages_2eproto);
namespace TSP {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Color_ColorModel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSPMessages_2eproto);
  return file_level_enum_descriptors_TSPMessages_2eproto[0];
}
bool Color_ColorModel_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Color_ColorModel Color::rgb;
constexpr Color_ColorModel Color::cmyk;
constexpr Color_ColorModel Color::white;
constexpr Color_ColorModel Color::ColorModel_MIN;
constexpr Color_ColorModel Color::ColorModel_MAX;
constexpr int Color::ColorModel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Color_RGBColorSpace_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSPMessages_2eproto);
  return file_level_enum_descriptors_TSPMessages_2eproto[1];
}
bool Color_RGBColorSpace_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Color_RGBColorSpace Color::srgb;
constexpr Color_RGBColorSpace Color::p3;
constexpr Color_RGBColorSpace Color::RGBColorSpace_MIN;
constexpr Color_RGBColorSpace Color::RGBColorSpace_MAX;
constexpr int Color::RGBColorSpace_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Path_ElementType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSPMessages_2eproto);
  return file_level_enum_descriptors_TSPMessages_2eproto[2];
}
bool Path_ElementType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Path_ElementType Path::moveTo;
constexpr Path_ElementType Path::lineTo;
constexpr Path_ElementType Path::quadCurveTo;
constexpr Path_ElementType Path::curveTo;
constexpr Path_ElementType Path::closeSubpath;
constexpr Path_ElementType Path::ElementType_MIN;
constexpr Path_ElementType Path::ElementType_MAX;
constexpr int Path::ElementType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataUploadStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSPMessages_2eproto);
  return file_level_enum_descriptors_TSPMessages_2eproto[3];
}
bool DataUploadStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Reference::_Internal {
 public:
  using HasBits = decltype(std::declval<Reference>()._impl_._has_bits_);
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_deprecated_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_deprecated_is_external(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Reference::Reference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.Reference)
}
Reference::Reference(const Reference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Reference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.identifier_){}
    , decltype(_impl_.deprecated_type_){}
    , decltype(_impl_.deprecated_is_external_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.identifier_, &from._impl_.identifier_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.deprecated_is_external_) -
    reinterpret_cast<char*>(&_impl_.identifier_)) + sizeof(_impl_.deprecated_is_external_));
  // @@protoc_insertion_point(copy_constructor:TSP.Reference)
}

inline void Reference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.identifier_){uint64_t{0u}}
    , decltype(_impl_.deprecated_type_){0}
    , decltype(_impl_.deprecated_is_external_){false}
  };
}

Reference::~Reference() {
  // @@protoc_insertion_point(destructor:TSP.Reference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Reference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Reference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Reference::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.Reference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.identifier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.deprecated_is_external_) -
        reinterpret_cast<char*>(&_impl_.identifier_)) + sizeof(_impl_.deprecated_is_external_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Reference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_identifier(&has_bits);
          _impl_.identifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 deprecated_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_deprecated_type(&has_bits);
          _impl_.deprecated_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool deprecated_is_external = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_deprecated_is_external(&has_bits);
          _impl_.deprecated_is_external_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Reference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.Reference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_identifier(), target);
  }

  // optional int32 deprecated_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_deprecated_type(), target);
  }

  // optional bool deprecated_is_external = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_deprecated_is_external(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.Reference)
  return target;
}

size_t Reference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.Reference)
  size_t total_size = 0;

  // required uint64 identifier = 1;
  if (_internal_has_identifier()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_identifier());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional int32 deprecated_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_deprecated_type());
    }

    // optional bool deprecated_is_external = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Reference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Reference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Reference::GetClassData() const { return &_class_data_; }


void Reference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Reference*>(&to_msg);
  auto& from = static_cast<const Reference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.Reference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.identifier_ = from._impl_.identifier_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.deprecated_type_ = from._impl_.deprecated_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.deprecated_is_external_ = from._impl_.deprecated_is_external_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Reference::CopyFrom(const Reference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.Reference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reference::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Reference::InternalSwap(Reference* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Reference, _impl_.deprecated_is_external_)
      + sizeof(Reference::_impl_.deprecated_is_external_)
      - PROTOBUF_FIELD_OFFSET(Reference, _impl_.identifier_)>(
          reinterpret_cast<char*>(&_impl_.identifier_),
          reinterpret_cast<char*>(&other->_impl_.identifier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Reference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[0]);
}

// ===================================================================

class DataReference::_Internal {
 public:
  using HasBits = decltype(std::declval<DataReference>()._impl_._has_bits_);
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

DataReference::DataReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.DataReference)
}
DataReference::DataReference(const DataReference& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DataReference* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.identifier_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.identifier_ = from._impl_.identifier_;
  // @@protoc_insertion_point(copy_constructor:TSP.DataReference)
}

inline void DataReference::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.identifier_){uint64_t{0u}}
  };
}

DataReference::~DataReference() {
  // @@protoc_insertion_point(destructor:TSP.DataReference)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataReference::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DataReference::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataReference::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.DataReference)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.identifier_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DataReference::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_identifier(&has_bits);
          _impl_.identifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataReference::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.DataReference)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.DataReference)
  return target;
}

size_t DataReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.DataReference)
  size_t total_size = 0;

  // required uint64 identifier = 1;
  if (_internal_has_identifier()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_identifier());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DataReference::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DataReference::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DataReference::GetClassData() const { return &_class_data_; }


void DataReference::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DataReference*>(&to_msg);
  auto& from = static_cast<const DataReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.DataReference)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_identifier()) {
    _this->_internal_set_identifier(from._internal_identifier());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DataReference::CopyFrom(const DataReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.DataReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataReference::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void DataReference::InternalSwap(DataReference* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.identifier_, other->_impl_.identifier_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DataReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[1]);
}

// ===================================================================

class SparseReferenceArray_Entry::_Internal {
 public:
  using HasBits = decltype(std::declval<SparseReferenceArray_Entry>()._impl_._has_bits_);
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& reference(const SparseReferenceArray_Entry* msg);
  static void set_has_reference(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSP::Reference&
SparseReferenceArray_Entry::_Internal::reference(const SparseReferenceArray_Entry* msg) {
  return *msg->_impl_.reference_;
}
SparseReferenceArray_Entry::SparseReferenceArray_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.SparseReferenceArray.Entry)
}
SparseReferenceArray_Entry::SparseReferenceArray_Entry(const SparseReferenceArray_Entry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SparseReferenceArray_Entry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reference_){nullptr}
    , decltype(_impl_.index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_reference()) {
    _this->_impl_.reference_ = new ::TSP::Reference(*from._impl_.reference_);
  }
  _this->_impl_.index_ = from._impl_.index_;
  // @@protoc_insertion_point(copy_constructor:TSP.SparseReferenceArray.Entry)
}

inline void SparseReferenceArray_Entry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reference_){nullptr}
    , decltype(_impl_.index_){0u}
  };
}

SparseReferenceArray_Entry::~SparseReferenceArray_Entry() {
  // @@protoc_insertion_point(destructor:TSP.SparseReferenceArray.Entry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SparseReferenceArray_Entry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.reference_;
}

void SparseReferenceArray_Entry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SparseReferenceArray_Entry::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.SparseReferenceArray.Entry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.reference_ != nullptr);
    _impl_.reference_->Clear();
  }
  _impl_.index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SparseReferenceArray_Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference reference = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SparseReferenceArray_Entry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.SparseReferenceArray.Entry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 index = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_index(), target);
  }

  // required .TSP.Reference reference = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::reference(this),
        _Internal::reference(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.SparseReferenceArray.Entry)
  return target;
}

size_t SparseReferenceArray_Entry::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSP.SparseReferenceArray.Entry)
  size_t total_size = 0;

  if (_internal_has_reference()) {
    // required .TSP.Reference reference = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.reference_);
  }

  if (_internal_has_index()) {
    // required uint32 index = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
  }

  return total_size;
}
size_t SparseReferenceArray_Entry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.SparseReferenceArray.Entry)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TSP.Reference reference = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.reference_);

    // required uint32 index = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SparseReferenceArray_Entry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SparseReferenceArray_Entry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SparseReferenceArray_Entry::GetClassData() const { return &_class_data_; }


void SparseReferenceArray_Entry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SparseReferenceArray_Entry*>(&to_msg);
  auto& from = static_cast<const SparseReferenceArray_Entry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.SparseReferenceArray.Entry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_reference()->::TSP::Reference::MergeFrom(
          from._internal_reference());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SparseReferenceArray_Entry::CopyFrom(const SparseReferenceArray_Entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.SparseReferenceArray.Entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparseReferenceArray_Entry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_reference()) {
    if (!_impl_.reference_->IsInitialized()) return false;
  }
  return true;
}

void SparseReferenceArray_Entry::InternalSwap(SparseReferenceArray_Entry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SparseReferenceArray_Entry, _impl_.index_)
      + sizeof(SparseReferenceArray_Entry::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(SparseReferenceArray_Entry, _impl_.reference_)>(
          reinterpret_cast<char*>(&_impl_.reference_),
          reinterpret_cast<char*>(&other->_impl_.reference_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SparseReferenceArray_Entry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[2]);
}

// ===================================================================

class SparseReferenceArray::_Internal {
 public:
  using HasBits = decltype(std::declval<SparseReferenceArray>()._impl_._has_bits_);
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SparseReferenceArray::SparseReferenceArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.SparseReferenceArray)
}
SparseReferenceArray::SparseReferenceArray(const SparseReferenceArray& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SparseReferenceArray* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entries_){from._impl_.entries_}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.count_ = from._impl_.count_;
  // @@protoc_insertion_point(copy_constructor:TSP.SparseReferenceArray)
}

inline void SparseReferenceArray::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entries_){arena}
    , decltype(_impl_.count_){0u}
  };
}

SparseReferenceArray::~SparseReferenceArray() {
  // @@protoc_insertion_point(destructor:TSP.SparseReferenceArray)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SparseReferenceArray::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entries_.~RepeatedPtrField();
}

void SparseReferenceArray::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SparseReferenceArray::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.SparseReferenceArray)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  _impl_.count_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SparseReferenceArray::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.SparseReferenceArray.Entry entries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SparseReferenceArray::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.SparseReferenceArray)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_count(), target);
  }

  // repeated .TSP.SparseReferenceArray.Entry entries = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.SparseReferenceArray)
  return target;
}

size_t SparseReferenceArray::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.SparseReferenceArray)
  size_t total_size = 0;

  // required uint32 count = 1;
  if (_internal_has_count()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.SparseReferenceArray.Entry entries = 2;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->_impl_.entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SparseReferenceArray::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SparseReferenceArray::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SparseReferenceArray::GetClassData() const { return &_class_data_; }


void SparseReferenceArray::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SparseReferenceArray*>(&to_msg);
  auto& from = static_cast<const SparseReferenceArray&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.SparseReferenceArray)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
  if (from._internal_has_count()) {
    _this->_internal_set_count(from._internal_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SparseReferenceArray::CopyFrom(const SparseReferenceArray& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.SparseReferenceArray)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparseReferenceArray::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.entries_))
    return false;
  return true;
}

void SparseReferenceArray::InternalSwap(SparseReferenceArray* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
  swap(_impl_.count_, other->_impl_.count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SparseReferenceArray::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[3]);
}

// ===================================================================

class Point::_Internal {
 public:
  using HasBits = decltype(std::declval<Point>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

Point::Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.Point)
}
Point::Point(const Point& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Point* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:TSP.Point)
}

inline void Point::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
}

Point::~Point() {
  // @@protoc_insertion_point(destructor:TSP.Point)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Point::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Point::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Point::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.Point)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Point::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Point::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.Point)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required float x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // required float y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.Point)
  return target;
}

size_t Point::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSP.Point)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (_internal_has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t Point::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.Point)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Point::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Point::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Point::GetClassData() const { return &_class_data_; }


void Point::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Point*>(&to_msg);
  auto& from = static_cast<const Point&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.Point)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Point::CopyFrom(const Point& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Point::InternalSwap(Point* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Point, _impl_.y_)
      + sizeof(Point::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(Point, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Point::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[4]);
}

// ===================================================================

class Size::_Internal {
 public:
  using HasBits = decltype(std::declval<Size>()._impl_._has_bits_);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

Size::Size(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.Size)
}
Size::Size(const Size& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Size* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.height_));
  // @@protoc_insertion_point(copy_constructor:TSP.Size)
}

inline void Size::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.width_){0}
    , decltype(_impl_.height_){0}
  };
}

Size::~Size() {
  // @@protoc_insertion_point(destructor:TSP.Size)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Size::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Size::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Size::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.Size)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.height_) -
        reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.height_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Size::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required float width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Size::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.Size)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required float width = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_width(), target);
  }

  // required float height = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.Size)
  return target;
}

size_t Size::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSP.Size)
  size_t total_size = 0;

  if (_internal_has_width()) {
    // required float width = 1;
    total_size += 1 + 4;
  }

  if (_internal_has_height()) {
    // required float height = 2;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t Size::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.Size)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required float width = 1;
    total_size += 1 + 4;

    // required float height = 2;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Size::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Size::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Size::GetClassData() const { return &_class_data_; }


void Size::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Size*>(&to_msg);
  auto& from = static_cast<const Size&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.Size)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Size::CopyFrom(const Size& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.Size)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Size::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Size::InternalSwap(Size* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Size, _impl_.height_)
      + sizeof(Size::_impl_.height_)
      - PROTOBUF_FIELD_OFFSET(Size, _impl_.width_)>(
          reinterpret_cast<char*>(&_impl_.width_),
          reinterpret_cast<char*>(&other->_impl_.width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Size::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[5]);
}

// ===================================================================

class Range::_Internal {
 public:
  using HasBits = decltype(std::declval<Range>()._impl_._has_bits_);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

Range::Range(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.Range)
}
Range::Range(const Range& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Range* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.location_){}
    , decltype(_impl_.length_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.location_, &from._impl_.location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.length_) -
    reinterpret_cast<char*>(&_impl_.location_)) + sizeof(_impl_.length_));
  // @@protoc_insertion_point(copy_constructor:TSP.Range)
}

inline void Range::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.location_){0u}
    , decltype(_impl_.length_){0u}
  };
}

Range::~Range() {
  // @@protoc_insertion_point(destructor:TSP.Range)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Range::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Range::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Range::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.Range)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.length_) -
        reinterpret_cast<char*>(&_impl_.location_)) + sizeof(_impl_.length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Range::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 location = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_location(&has_bits);
          _impl_.location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 length = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_length(&has_bits);
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Range::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.Range)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 location = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_location(), target);
  }

  // required uint32 length = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.Range)
  return target;
}

size_t Range::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSP.Range)
  size_t total_size = 0;

  if (_internal_has_location()) {
    // required uint32 location = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_location());
  }

  if (_internal_has_length()) {
    // required uint32 length = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_length());
  }

  return total_size;
}
size_t Range::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.Range)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 location = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_location());

    // required uint32 length = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_length());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Range::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Range::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Range::GetClassData() const { return &_class_data_; }


void Range::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Range*>(&to_msg);
  auto& from = static_cast<const Range&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.Range)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.location_ = from._impl_.location_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.length_ = from._impl_.length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Range::CopyFrom(const Range& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.Range)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Range::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Range::InternalSwap(Range* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Range, _impl_.length_)
      + sizeof(Range::_impl_.length_)
      - PROTOBUF_FIELD_OFFSET(Range, _impl_.location_)>(
          reinterpret_cast<char*>(&_impl_.location_),
          reinterpret_cast<char*>(&other->_impl_.location_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Range::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[6]);
}

// ===================================================================

class Date::_Internal {
 public:
  using HasBits = decltype(std::declval<Date>()._impl_._has_bits_);
  static void set_has_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Date::Date(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.Date)
}
Date::Date(const Date& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Date* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seconds_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.seconds_ = from._impl_.seconds_;
  // @@protoc_insertion_point(copy_constructor:TSP.Date)
}

inline void Date::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.seconds_){0}
  };
}

Date::~Date() {
  // @@protoc_insertion_point(destructor:TSP.Date)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Date::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Date::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Date::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.Date)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.seconds_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Date::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_seconds(&has_bits);
          _impl_.seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Date::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.Date)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_seconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.Date)
  return target;
}

size_t Date::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.Date)
  size_t total_size = 0;

  // required double seconds = 1;
  if (_internal_has_seconds()) {
    total_size += 1 + 8;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Date::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Date::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Date::GetClassData() const { return &_class_data_; }


void Date::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Date*>(&to_msg);
  auto& from = static_cast<const Date&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.Date)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_seconds()) {
    _this->_internal_set_seconds(from._internal_seconds());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Date::CopyFrom(const Date& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.Date)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Date::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Date::InternalSwap(Date* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.seconds_, other->_impl_.seconds_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Date::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[7]);
}

// ===================================================================

class IndexSet::_Internal {
 public:
};

IndexSet::IndexSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.IndexSet)
}
IndexSet::IndexSet(const IndexSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IndexSet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ranges_){from._impl_.ranges_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSP.IndexSet)
}

inline void IndexSet::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ranges_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

IndexSet::~IndexSet() {
  // @@protoc_insertion_point(destructor:TSP.IndexSet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IndexSet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ranges_.~RepeatedPtrField();
}

void IndexSet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IndexSet::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.IndexSet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ranges_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IndexSet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSP.Range ranges = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ranges(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IndexSet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.IndexSet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSP.Range ranges = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ranges_size()); i < n; i++) {
    const auto& repfield = this->_internal_ranges(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.IndexSet)
  return target;
}

size_t IndexSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.IndexSet)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Range ranges = 1;
  total_size += 1UL * this->_internal_ranges_size();
  for (const auto& msg : this->_impl_.ranges_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IndexSet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IndexSet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IndexSet::GetClassData() const { return &_class_data_; }


void IndexSet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IndexSet*>(&to_msg);
  auto& from = static_cast<const IndexSet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.IndexSet)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ranges_.MergeFrom(from._impl_.ranges_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IndexSet::CopyFrom(const IndexSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.IndexSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IndexSet::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.ranges_))
    return false;
  return true;
}

void IndexSet::InternalSwap(IndexSet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ranges_.InternalSwap(&other->_impl_.ranges_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IndexSet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[8]);
}

// ===================================================================

class Color::_Internal {
 public:
  using HasBits = decltype(std::declval<Color>()._impl_._has_bits_);
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_r(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_g(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_b(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rgbspace(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_a(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_c(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_m(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_k(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_w(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000200) ^ 0x00000200) != 0;
  }
};

Color::Color(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.Color)
}
Color::Color(const Color& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Color* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.r_){}
    , decltype(_impl_.g_){}
    , decltype(_impl_.b_){}
    , decltype(_impl_.c_){}
    , decltype(_impl_.m_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.k_){}
    , decltype(_impl_.w_){}
    , decltype(_impl_.rgbspace_){}
    , decltype(_impl_.model_){}
    , decltype(_impl_.a_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.r_, &from._impl_.r_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.a_) -
    reinterpret_cast<char*>(&_impl_.r_)) + sizeof(_impl_.a_));
  // @@protoc_insertion_point(copy_constructor:TSP.Color)
}

inline void Color::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.r_){0}
    , decltype(_impl_.g_){0}
    , decltype(_impl_.b_){0}
    , decltype(_impl_.c_){0}
    , decltype(_impl_.m_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.k_){0}
    , decltype(_impl_.w_){0}
    , decltype(_impl_.rgbspace_){1}
    , decltype(_impl_.model_){1}
    , decltype(_impl_.a_){1}
  };
}

Color::~Color() {
  // @@protoc_insertion_point(destructor:TSP.Color)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Color::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Color::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Color::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.Color)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.r_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.w_) -
        reinterpret_cast<char*>(&_impl_.r_)) + sizeof(_impl_.w_));
  }
  if (cached_has_bits & 0x00000700u) {
    _impl_.rgbspace_ = 1;
    _impl_.model_ = 1;
    _impl_.a_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Color::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.Color.ColorModel model = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSP::Color_ColorModel_IsValid(val))) {
            _internal_set_model(static_cast<::TSP::Color_ColorModel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float r = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_r(&has_bits);
          _impl_.r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float g = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_g(&has_bits);
          _impl_.g_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float b = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_b(&has_bits);
          _impl_.b_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float a = 6 [default = 1];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_a(&has_bits);
          _impl_.a_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float c = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_c(&has_bits);
          _impl_.c_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_m(&has_bits);
          _impl_.m_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float k = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_k(&has_bits);
          _impl_.k_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float w = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_w(&has_bits);
          _impl_.w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Color.RGBColorSpace rgbspace = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSP::Color_RGBColorSpace_IsValid(val))) {
            _internal_set_rgbspace(static_cast<::TSP::Color_RGBColorSpace>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Color::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.Color)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.Color.ColorModel model = 1;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_model(), target);
  }

  // optional float r = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_r(), target);
  }

  // optional float g = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_g(), target);
  }

  // optional float b = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_b(), target);
  }

  // optional float a = 6 [default = 1];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_a(), target);
  }

  // optional float c = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_c(), target);
  }

  // optional float m = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_m(), target);
  }

  // optional float y = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_y(), target);
  }

  // optional float k = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_k(), target);
  }

  // optional float w = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_w(), target);
  }

  // optional .TSP.Color.RGBColorSpace rgbspace = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      12, this->_internal_rgbspace(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.Color)
  return target;
}

size_t Color::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.Color)
  size_t total_size = 0;

  // required .TSP.Color.ColorModel model = 1;
  if (_internal_has_model()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_model());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float r = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float g = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float b = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float c = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float m = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float y = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float k = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float w = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  // optional .TSP.Color.RGBColorSpace rgbspace = 12;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_rgbspace());
  }

  // optional float a = 6 [default = 1];
  if (cached_has_bits & 0x00000400u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Color::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Color::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Color::GetClassData() const { return &_class_data_; }


void Color::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Color*>(&to_msg);
  auto& from = static_cast<const Color&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.Color)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.r_ = from._impl_.r_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.g_ = from._impl_.g_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.b_ = from._impl_.b_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.c_ = from._impl_.c_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.m_ = from._impl_.m_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.k_ = from._impl_.k_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.w_ = from._impl_.w_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.rgbspace_ = from._impl_.rgbspace_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.model_ = from._impl_.model_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.a_ = from._impl_.a_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Color::CopyFrom(const Color& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.Color)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Color::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Color::InternalSwap(Color* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Color, _impl_.w_)
      + sizeof(Color::_impl_.w_)
      - PROTOBUF_FIELD_OFFSET(Color, _impl_.r_)>(
          reinterpret_cast<char*>(&_impl_.r_),
          reinterpret_cast<char*>(&other->_impl_.r_));
  swap(_impl_.rgbspace_, other->_impl_.rgbspace_);
  swap(_impl_.model_, other->_impl_.model_);
  swap(_impl_.a_, other->_impl_.a_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Color::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[9]);
}

// ===================================================================

class Path_Element::_Internal {
 public:
  using HasBits = decltype(std::declval<Path_Element>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Path_Element::Path_Element(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.Path.Element)
}
Path_Element::Path_Element(const Path_Element& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Path_Element* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.points_){from._impl_.points_}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:TSP.Path.Element)
}

inline void Path_Element::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.points_){arena}
    , decltype(_impl_.type_){1}
  };
}

Path_Element::~Path_Element() {
  // @@protoc_insertion_point(destructor:TSP.Path.Element)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Path_Element::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.points_.~RepeatedPtrField();
}

void Path_Element::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Path_Element::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.Path.Element)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.points_.Clear();
  _impl_.type_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Path_Element::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.Path.ElementType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSP::Path_ElementType_IsValid(val))) {
            _internal_set_type(static_cast<::TSP::Path_ElementType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Point points = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Path_Element::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.Path.Element)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.Path.ElementType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // repeated .TSP.Point points = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.Path.Element)
  return target;
}

size_t Path_Element::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.Path.Element)
  size_t total_size = 0;

  // required .TSP.Path.ElementType type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Point points = 2;
  total_size += 1UL * this->_internal_points_size();
  for (const auto& msg : this->_impl_.points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Path_Element::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Path_Element::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Path_Element::GetClassData() const { return &_class_data_; }


void Path_Element::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Path_Element*>(&to_msg);
  auto& from = static_cast<const Path_Element&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.Path.Element)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.points_.MergeFrom(from._impl_.points_);
  if (from._internal_has_type()) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Path_Element::CopyFrom(const Path_Element& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.Path.Element)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Path_Element::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.points_))
    return false;
  return true;
}

void Path_Element::InternalSwap(Path_Element* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Path_Element::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[10]);
}

// ===================================================================

class Path::_Internal {
 public:
};

Path::Path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.Path)
}
Path::Path(const Path& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Path* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.elements_){from._impl_.elements_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSP.Path)
}

inline void Path::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.elements_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Path::~Path() {
  // @@protoc_insertion_point(destructor:TSP.Path)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Path::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.elements_.~RepeatedPtrField();
}

void Path::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Path::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.Path)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.elements_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Path::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSP.Path.Element elements = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_elements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Path::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.Path)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSP.Path.Element elements = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_elements_size()); i < n; i++) {
    const auto& repfield = this->_internal_elements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.Path)
  return target;
}

size_t Path::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.Path)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Path.Element elements = 1;
  total_size += 1UL * this->_internal_elements_size();
  for (const auto& msg : this->_impl_.elements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Path::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Path::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Path::GetClassData() const { return &_class_data_; }


void Path::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Path*>(&to_msg);
  auto& from = static_cast<const Path&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.Path)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.elements_.MergeFrom(from._impl_.elements_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Path::CopyFrom(const Path& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.Path)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Path::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.elements_))
    return false;
  return true;
}

void Path::InternalSwap(Path* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.elements_.InternalSwap(&other->_impl_.elements_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Path::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[11]);
}

// ===================================================================

class ReferenceDictionary_Entry::_Internal {
 public:
  using HasBits = decltype(std::declval<ReferenceDictionary_Entry>()._impl_._has_bits_);
  static const ::TSP::Reference& key(const ReferenceDictionary_Entry* msg);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& value(const ReferenceDictionary_Entry* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSP::Reference&
ReferenceDictionary_Entry::_Internal::key(const ReferenceDictionary_Entry* msg) {
  return *msg->_impl_.key_;
}
const ::TSP::Reference&
ReferenceDictionary_Entry::_Internal::value(const ReferenceDictionary_Entry* msg) {
  return *msg->_impl_.value_;
}
ReferenceDictionary_Entry::ReferenceDictionary_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.ReferenceDictionary.Entry)
}
ReferenceDictionary_Entry::ReferenceDictionary_Entry(const ReferenceDictionary_Entry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReferenceDictionary_Entry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){nullptr}
    , decltype(_impl_.value_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_key()) {
    _this->_impl_.key_ = new ::TSP::Reference(*from._impl_.key_);
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::TSP::Reference(*from._impl_.value_);
  }
  // @@protoc_insertion_point(copy_constructor:TSP.ReferenceDictionary.Entry)
}

inline void ReferenceDictionary_Entry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){nullptr}
    , decltype(_impl_.value_){nullptr}
  };
}

ReferenceDictionary_Entry::~ReferenceDictionary_Entry() {
  // @@protoc_insertion_point(destructor:TSP.ReferenceDictionary.Entry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReferenceDictionary_Entry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.key_;
  if (this != internal_default_instance()) delete _impl_.value_;
}

void ReferenceDictionary_Entry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReferenceDictionary_Entry::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.ReferenceDictionary.Entry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.key_ != nullptr);
      _impl_.key_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.value_ != nullptr);
      _impl_.value_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReferenceDictionary_Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.Reference key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReferenceDictionary_Entry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.ReferenceDictionary.Entry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.Reference key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::key(this),
        _Internal::key(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.ReferenceDictionary.Entry)
  return target;
}

size_t ReferenceDictionary_Entry::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSP.ReferenceDictionary.Entry)
  size_t total_size = 0;

  if (_internal_has_key()) {
    // required .TSP.Reference key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.key_);
  }

  if (_internal_has_value()) {
    // required .TSP.Reference value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return total_size;
}
size_t ReferenceDictionary_Entry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.ReferenceDictionary.Entry)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TSP.Reference key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.key_);

    // required .TSP.Reference value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReferenceDictionary_Entry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReferenceDictionary_Entry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReferenceDictionary_Entry::GetClassData() const { return &_class_data_; }


void ReferenceDictionary_Entry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReferenceDictionary_Entry*>(&to_msg);
  auto& from = static_cast<const ReferenceDictionary_Entry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.ReferenceDictionary.Entry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_key()->::TSP::Reference::MergeFrom(
          from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_value()->::TSP::Reference::MergeFrom(
          from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReferenceDictionary_Entry::CopyFrom(const ReferenceDictionary_Entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.ReferenceDictionary.Entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReferenceDictionary_Entry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_key()) {
    if (!_impl_.key_->IsInitialized()) return false;
  }
  if (_internal_has_value()) {
    if (!_impl_.value_->IsInitialized()) return false;
  }
  return true;
}

void ReferenceDictionary_Entry::InternalSwap(ReferenceDictionary_Entry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReferenceDictionary_Entry, _impl_.value_)
      + sizeof(ReferenceDictionary_Entry::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(ReferenceDictionary_Entry, _impl_.key_)>(
          reinterpret_cast<char*>(&_impl_.key_),
          reinterpret_cast<char*>(&other->_impl_.key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReferenceDictionary_Entry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[12]);
}

// ===================================================================

class ReferenceDictionary::_Internal {
 public:
};

ReferenceDictionary::ReferenceDictionary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.ReferenceDictionary)
}
ReferenceDictionary::ReferenceDictionary(const ReferenceDictionary& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReferenceDictionary* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){from._impl_.entries_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSP.ReferenceDictionary)
}

inline void ReferenceDictionary::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ReferenceDictionary::~ReferenceDictionary() {
  // @@protoc_insertion_point(destructor:TSP.ReferenceDictionary)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReferenceDictionary::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entries_.~RepeatedPtrField();
}

void ReferenceDictionary::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReferenceDictionary::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.ReferenceDictionary)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReferenceDictionary::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSP.ReferenceDictionary.Entry entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReferenceDictionary::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.ReferenceDictionary)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSP.ReferenceDictionary.Entry entries = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.ReferenceDictionary)
  return target;
}

size_t ReferenceDictionary::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.ReferenceDictionary)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.ReferenceDictionary.Entry entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->_impl_.entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReferenceDictionary::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReferenceDictionary::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReferenceDictionary::GetClassData() const { return &_class_data_; }


void ReferenceDictionary::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReferenceDictionary*>(&to_msg);
  auto& from = static_cast<const ReferenceDictionary&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.ReferenceDictionary)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReferenceDictionary::CopyFrom(const ReferenceDictionary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.ReferenceDictionary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReferenceDictionary::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.entries_))
    return false;
  return true;
}

void ReferenceDictionary::InternalSwap(ReferenceDictionary* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReferenceDictionary::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[13]);
}

// ===================================================================

class UUID::_Internal {
 public:
  using HasBits = decltype(std::declval<UUID>()._impl_._has_bits_);
  static void set_has_lower(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_upper(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

UUID::UUID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.UUID)
}
UUID::UUID(const UUID& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UUID* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lower_){}
    , decltype(_impl_.upper_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.lower_, &from._impl_.lower_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.upper_) -
    reinterpret_cast<char*>(&_impl_.lower_)) + sizeof(_impl_.upper_));
  // @@protoc_insertion_point(copy_constructor:TSP.UUID)
}

inline void UUID::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lower_){uint64_t{0u}}
    , decltype(_impl_.upper_){uint64_t{0u}}
  };
}

UUID::~UUID() {
  // @@protoc_insertion_point(destructor:TSP.UUID)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UUID::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UUID::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UUID::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.UUID)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.lower_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.upper_) -
        reinterpret_cast<char*>(&_impl_.lower_)) + sizeof(_impl_.upper_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UUID::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 lower = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_lower(&has_bits);
          _impl_.lower_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 upper = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_upper(&has_bits);
          _impl_.upper_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UUID::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.UUID)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 lower = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_lower(), target);
  }

  // required uint64 upper = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_upper(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.UUID)
  return target;
}

size_t UUID::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSP.UUID)
  size_t total_size = 0;

  if (_internal_has_lower()) {
    // required uint64 lower = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_lower());
  }

  if (_internal_has_upper()) {
    // required uint64 upper = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_upper());
  }

  return total_size;
}
size_t UUID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.UUID)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 lower = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_lower());

    // required uint64 upper = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_upper());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UUID::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UUID::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UUID::GetClassData() const { return &_class_data_; }


void UUID::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UUID*>(&to_msg);
  auto& from = static_cast<const UUID&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.UUID)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.lower_ = from._impl_.lower_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.upper_ = from._impl_.upper_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UUID::CopyFrom(const UUID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.UUID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UUID::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void UUID::InternalSwap(UUID* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UUID, _impl_.upper_)
      + sizeof(UUID::_impl_.upper_)
      - PROTOBUF_FIELD_OFFSET(UUID, _impl_.lower_)>(
          reinterpret_cast<char*>(&_impl_.lower_),
          reinterpret_cast<char*>(&other->_impl_.lower_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UUID::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[14]);
}

// ===================================================================

class CFUUIDArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CFUUIDArchive>()._impl_._has_bits_);
  static void set_has_uuid_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_uuid_w0(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_uuid_w1(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_uuid_w2(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_uuid_w3(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CFUUIDArchive::CFUUIDArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.CFUUIDArchive)
}
CFUUIDArchive::CFUUIDArchive(const CFUUIDArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CFUUIDArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uuid_bytes_){}
    , decltype(_impl_.uuid_w0_){}
    , decltype(_impl_.uuid_w1_){}
    , decltype(_impl_.uuid_w2_){}
    , decltype(_impl_.uuid_w3_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.uuid_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uuid_bytes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_uuid_bytes()) {
    _this->_impl_.uuid_bytes_.Set(from._internal_uuid_bytes(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.uuid_w0_, &from._impl_.uuid_w0_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.uuid_w3_) -
    reinterpret_cast<char*>(&_impl_.uuid_w0_)) + sizeof(_impl_.uuid_w3_));
  // @@protoc_insertion_point(copy_constructor:TSP.CFUUIDArchive)
}

inline void CFUUIDArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uuid_bytes_){}
    , decltype(_impl_.uuid_w0_){0u}
    , decltype(_impl_.uuid_w1_){0u}
    , decltype(_impl_.uuid_w2_){0u}
    , decltype(_impl_.uuid_w3_){0u}
  };
  _impl_.uuid_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uuid_bytes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CFUUIDArchive::~CFUUIDArchive() {
  // @@protoc_insertion_point(destructor:TSP.CFUUIDArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CFUUIDArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.uuid_bytes_.Destroy();
}

void CFUUIDArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CFUUIDArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.CFUUIDArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.uuid_bytes_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.uuid_w0_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.uuid_w3_) -
        reinterpret_cast<char*>(&_impl_.uuid_w0_)) + sizeof(_impl_.uuid_w3_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CFUUIDArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes uuid_bytes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_uuid_bytes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 uuid_w0 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_uuid_w0(&has_bits);
          _impl_.uuid_w0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 uuid_w1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_uuid_w1(&has_bits);
          _impl_.uuid_w1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 uuid_w2 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_uuid_w2(&has_bits);
          _impl_.uuid_w2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 uuid_w3 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_uuid_w3(&has_bits);
          _impl_.uuid_w3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CFUUIDArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.CFUUIDArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes uuid_bytes = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_uuid_bytes(), target);
  }

  // optional uint32 uuid_w0 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_uuid_w0(), target);
  }

  // optional uint32 uuid_w1 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_uuid_w1(), target);
  }

  // optional uint32 uuid_w2 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_uuid_w2(), target);
  }

  // optional uint32 uuid_w3 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_uuid_w3(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.CFUUIDArchive)
  return target;
}

size_t CFUUIDArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.CFUUIDArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes uuid_bytes = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_uuid_bytes());
    }

    // optional uint32 uuid_w0 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uuid_w0());
    }

    // optional uint32 uuid_w1 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uuid_w1());
    }

    // optional uint32 uuid_w2 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uuid_w2());
    }

    // optional uint32 uuid_w3 = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uuid_w3());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CFUUIDArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CFUUIDArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CFUUIDArchive::GetClassData() const { return &_class_data_; }


void CFUUIDArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CFUUIDArchive*>(&to_msg);
  auto& from = static_cast<const CFUUIDArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.CFUUIDArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_uuid_bytes(from._internal_uuid_bytes());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.uuid_w0_ = from._impl_.uuid_w0_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.uuid_w1_ = from._impl_.uuid_w1_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.uuid_w2_ = from._impl_.uuid_w2_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.uuid_w3_ = from._impl_.uuid_w3_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CFUUIDArchive::CopyFrom(const CFUUIDArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.CFUUIDArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CFUUIDArchive::IsInitialized() const {
  return true;
}

void CFUUIDArchive::InternalSwap(CFUUIDArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uuid_bytes_, lhs_arena,
      &other->_impl_.uuid_bytes_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CFUUIDArchive, _impl_.uuid_w3_)
      + sizeof(CFUUIDArchive::_impl_.uuid_w3_)
      - PROTOBUF_FIELD_OFFSET(CFUUIDArchive, _impl_.uuid_w0_)>(
          reinterpret_cast<char*>(&_impl_.uuid_w0_),
          reinterpret_cast<char*>(&other->_impl_.uuid_w0_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CFUUIDArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[15]);
}

// ===================================================================

class UUIDSetArchive::_Internal {
 public:
};

UUIDSetArchive::UUIDSetArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.UUIDSetArchive)
}
UUIDSetArchive::UUIDSetArchive(const UUIDSetArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UUIDSetArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.uids_){from._impl_.uids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSP.UUIDSetArchive)
}

inline void UUIDSetArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.uids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UUIDSetArchive::~UUIDSetArchive() {
  // @@protoc_insertion_point(destructor:TSP.UUIDSetArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UUIDSetArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.uids_.~RepeatedPtrField();
}

void UUIDSetArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UUIDSetArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.UUIDSetArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.uids_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UUIDSetArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSP.UUID uids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_uids(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UUIDSetArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.UUIDSetArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSP.UUID uids = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_uids_size()); i < n; i++) {
    const auto& repfield = this->_internal_uids(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.UUIDSetArchive)
  return target;
}

size_t UUIDSetArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.UUIDSetArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.UUID uids = 1;
  total_size += 1UL * this->_internal_uids_size();
  for (const auto& msg : this->_impl_.uids_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UUIDSetArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UUIDSetArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UUIDSetArchive::GetClassData() const { return &_class_data_; }


void UUIDSetArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UUIDSetArchive*>(&to_msg);
  auto& from = static_cast<const UUIDSetArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.UUIDSetArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.uids_.MergeFrom(from._impl_.uids_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UUIDSetArchive::CopyFrom(const UUIDSetArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.UUIDSetArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UUIDSetArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.uids_))
    return false;
  return true;
}

void UUIDSetArchive::InternalSwap(UUIDSetArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.uids_.InternalSwap(&other->_impl_.uids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UUIDSetArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[16]);
}

// ===================================================================

class UUIDMapArchive::_Internal {
 public:
};

UUIDMapArchive::UUIDMapArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.UUIDMapArchive)
}
UUIDMapArchive::UUIDMapArchive(const UUIDMapArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UUIDMapArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_){from._impl_.source_}
    , decltype(_impl_.target_){from._impl_.target_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSP.UUIDMapArchive)
}

inline void UUIDMapArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.source_){arena}
    , decltype(_impl_.target_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UUIDMapArchive::~UUIDMapArchive() {
  // @@protoc_insertion_point(destructor:TSP.UUIDMapArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UUIDMapArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.source_.~RepeatedPtrField();
  _impl_.target_.~RepeatedPtrField();
}

void UUIDMapArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UUIDMapArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.UUIDMapArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.source_.Clear();
  _impl_.target_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UUIDMapArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSP.UUID source = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_source(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.UUID target = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_target(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UUIDMapArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.UUIDMapArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSP.UUID source = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_source_size()); i < n; i++) {
    const auto& repfield = this->_internal_source(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.UUID target = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_target_size()); i < n; i++) {
    const auto& repfield = this->_internal_target(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.UUIDMapArchive)
  return target;
}

size_t UUIDMapArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.UUIDMapArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.UUID source = 1;
  total_size += 1UL * this->_internal_source_size();
  for (const auto& msg : this->_impl_.source_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.UUID target = 2;
  total_size += 1UL * this->_internal_target_size();
  for (const auto& msg : this->_impl_.target_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UUIDMapArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UUIDMapArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UUIDMapArchive::GetClassData() const { return &_class_data_; }


void UUIDMapArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UUIDMapArchive*>(&to_msg);
  auto& from = static_cast<const UUIDMapArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.UUIDMapArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.source_.MergeFrom(from._impl_.source_);
  _this->_impl_.target_.MergeFrom(from._impl_.target_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UUIDMapArchive::CopyFrom(const UUIDMapArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.UUIDMapArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UUIDMapArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.source_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.target_))
    return false;
  return true;
}

void UUIDMapArchive::InternalSwap(UUIDMapArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.source_.InternalSwap(&other->_impl_.source_);
  _impl_.target_.InternalSwap(&other->_impl_.target_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UUIDMapArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[17]);
}

// ===================================================================

class UUIDMultiMapArchive::_Internal {
 public:
};

UUIDMultiMapArchive::UUIDMultiMapArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.UUIDMultiMapArchive)
}
UUIDMultiMapArchive::UUIDMultiMapArchive(const UUIDMultiMapArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UUIDMultiMapArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_){from._impl_.source_}
    , decltype(_impl_.target_){from._impl_.target_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSP.UUIDMultiMapArchive)
}

inline void UUIDMultiMapArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.source_){arena}
    , decltype(_impl_.target_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UUIDMultiMapArchive::~UUIDMultiMapArchive() {
  // @@protoc_insertion_point(destructor:TSP.UUIDMultiMapArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UUIDMultiMapArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.source_.~RepeatedPtrField();
  _impl_.target_.~RepeatedPtrField();
}

void UUIDMultiMapArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UUIDMultiMapArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.UUIDMultiMapArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.source_.Clear();
  _impl_.target_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UUIDMultiMapArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSP.UUID source = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_source(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.UUID target = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_target(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UUIDMultiMapArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.UUIDMultiMapArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSP.UUID source = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_source_size()); i < n; i++) {
    const auto& repfield = this->_internal_source(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.UUID target = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_target_size()); i < n; i++) {
    const auto& repfield = this->_internal_target(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.UUIDMultiMapArchive)
  return target;
}

size_t UUIDMultiMapArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.UUIDMultiMapArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.UUID source = 1;
  total_size += 1UL * this->_internal_source_size();
  for (const auto& msg : this->_impl_.source_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.UUID target = 2;
  total_size += 1UL * this->_internal_target_size();
  for (const auto& msg : this->_impl_.target_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UUIDMultiMapArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UUIDMultiMapArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UUIDMultiMapArchive::GetClassData() const { return &_class_data_; }


void UUIDMultiMapArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UUIDMultiMapArchive*>(&to_msg);
  auto& from = static_cast<const UUIDMultiMapArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.UUIDMultiMapArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.source_.MergeFrom(from._impl_.source_);
  _this->_impl_.target_.MergeFrom(from._impl_.target_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UUIDMultiMapArchive::CopyFrom(const UUIDMultiMapArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.UUIDMultiMapArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UUIDMultiMapArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.source_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.target_))
    return false;
  return true;
}

void UUIDMultiMapArchive::InternalSwap(UUIDMultiMapArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.source_.InternalSwap(&other->_impl_.source_);
  _impl_.target_.InternalSwap(&other->_impl_.target_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UUIDMultiMapArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[18]);
}

// ===================================================================

class UUIDCoordArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<UUIDCoordArchive>()._impl_._has_bits_);
  static const ::TSP::UUID& row_uid(const UUIDCoordArchive* msg);
  static void set_has_row_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::UUID& column_uid(const UUIDCoordArchive* msg);
  static void set_has_column_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSP::UUID&
UUIDCoordArchive::_Internal::row_uid(const UUIDCoordArchive* msg) {
  return *msg->_impl_.row_uid_;
}
const ::TSP::UUID&
UUIDCoordArchive::_Internal::column_uid(const UUIDCoordArchive* msg) {
  return *msg->_impl_.column_uid_;
}
UUIDCoordArchive::UUIDCoordArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.UUIDCoordArchive)
}
UUIDCoordArchive::UUIDCoordArchive(const UUIDCoordArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UUIDCoordArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.row_uid_){nullptr}
    , decltype(_impl_.column_uid_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_row_uid()) {
    _this->_impl_.row_uid_ = new ::TSP::UUID(*from._impl_.row_uid_);
  }
  if (from._internal_has_column_uid()) {
    _this->_impl_.column_uid_ = new ::TSP::UUID(*from._impl_.column_uid_);
  }
  // @@protoc_insertion_point(copy_constructor:TSP.UUIDCoordArchive)
}

inline void UUIDCoordArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.row_uid_){nullptr}
    , decltype(_impl_.column_uid_){nullptr}
  };
}

UUIDCoordArchive::~UUIDCoordArchive() {
  // @@protoc_insertion_point(destructor:TSP.UUIDCoordArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UUIDCoordArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.row_uid_;
  if (this != internal_default_instance()) delete _impl_.column_uid_;
}

void UUIDCoordArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UUIDCoordArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.UUIDCoordArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.row_uid_ != nullptr);
      _impl_.row_uid_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.column_uid_ != nullptr);
      _impl_.column_uid_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UUIDCoordArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.UUID row_uid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_row_uid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.UUID column_uid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_column_uid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UUIDCoordArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.UUIDCoordArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.UUID row_uid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::row_uid(this),
        _Internal::row_uid(this).GetCachedSize(), target, stream);
  }

  // required .TSP.UUID column_uid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::column_uid(this),
        _Internal::column_uid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.UUIDCoordArchive)
  return target;
}

size_t UUIDCoordArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSP.UUIDCoordArchive)
  size_t total_size = 0;

  if (_internal_has_row_uid()) {
    // required .TSP.UUID row_uid = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.row_uid_);
  }

  if (_internal_has_column_uid()) {
    // required .TSP.UUID column_uid = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.column_uid_);
  }

  return total_size;
}
size_t UUIDCoordArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.UUIDCoordArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TSP.UUID row_uid = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.row_uid_);

    // required .TSP.UUID column_uid = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.column_uid_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UUIDCoordArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UUIDCoordArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UUIDCoordArchive::GetClassData() const { return &_class_data_; }


void UUIDCoordArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UUIDCoordArchive*>(&to_msg);
  auto& from = static_cast<const UUIDCoordArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.UUIDCoordArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_row_uid()->::TSP::UUID::MergeFrom(
          from._internal_row_uid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_column_uid()->::TSP::UUID::MergeFrom(
          from._internal_column_uid());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UUIDCoordArchive::CopyFrom(const UUIDCoordArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.UUIDCoordArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UUIDCoordArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_row_uid()) {
    if (!_impl_.row_uid_->IsInitialized()) return false;
  }
  if (_internal_has_column_uid()) {
    if (!_impl_.column_uid_->IsInitialized()) return false;
  }
  return true;
}

void UUIDCoordArchive::InternalSwap(UUIDCoordArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UUIDCoordArchive, _impl_.column_uid_)
      + sizeof(UUIDCoordArchive::_impl_.column_uid_)
      - PROTOBUF_FIELD_OFFSET(UUIDCoordArchive, _impl_.row_uid_)>(
          reinterpret_cast<char*>(&_impl_.row_uid_),
          reinterpret_cast<char*>(&other->_impl_.row_uid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UUIDCoordArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[19]);
}

// ===================================================================

class UUIDRectArchive::_Internal {
 public:
};

UUIDRectArchive::UUIDRectArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.UUIDRectArchive)
}
UUIDRectArchive::UUIDRectArchive(const UUIDRectArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UUIDRectArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.column_uids_){from._impl_.column_uids_}
    , decltype(_impl_.row_uids_){from._impl_.row_uids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSP.UUIDRectArchive)
}

inline void UUIDRectArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.column_uids_){arena}
    , decltype(_impl_.row_uids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UUIDRectArchive::~UUIDRectArchive() {
  // @@protoc_insertion_point(destructor:TSP.UUIDRectArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UUIDRectArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.column_uids_.~RepeatedPtrField();
  _impl_.row_uids_.~RepeatedPtrField();
}

void UUIDRectArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UUIDRectArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.UUIDRectArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.column_uids_.Clear();
  _impl_.row_uids_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UUIDRectArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSP.UUID column_uids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_column_uids(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.UUID row_uids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_row_uids(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UUIDRectArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.UUIDRectArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSP.UUID column_uids = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_column_uids_size()); i < n; i++) {
    const auto& repfield = this->_internal_column_uids(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.UUID row_uids = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_row_uids_size()); i < n; i++) {
    const auto& repfield = this->_internal_row_uids(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.UUIDRectArchive)
  return target;
}

size_t UUIDRectArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.UUIDRectArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.UUID column_uids = 1;
  total_size += 1UL * this->_internal_column_uids_size();
  for (const auto& msg : this->_impl_.column_uids_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.UUID row_uids = 2;
  total_size += 1UL * this->_internal_row_uids_size();
  for (const auto& msg : this->_impl_.row_uids_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UUIDRectArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UUIDRectArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UUIDRectArchive::GetClassData() const { return &_class_data_; }


void UUIDRectArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UUIDRectArchive*>(&to_msg);
  auto& from = static_cast<const UUIDRectArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.UUIDRectArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.column_uids_.MergeFrom(from._impl_.column_uids_);
  _this->_impl_.row_uids_.MergeFrom(from._impl_.row_uids_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UUIDRectArchive::CopyFrom(const UUIDRectArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.UUIDRectArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UUIDRectArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.column_uids_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.row_uids_))
    return false;
  return true;
}

void UUIDRectArchive::InternalSwap(UUIDRectArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.column_uids_.InternalSwap(&other->_impl_.column_uids_);
  _impl_.row_uids_.InternalSwap(&other->_impl_.row_uids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UUIDRectArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[20]);
}

// ===================================================================

class SparseUUIDArray_Entry::_Internal {
 public:
  using HasBits = decltype(std::declval<SparseUUIDArray_Entry>()._impl_._has_bits_);
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::UUID& uuid(const SparseUUIDArray_Entry* msg);
  static void set_has_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSP::UUID&
SparseUUIDArray_Entry::_Internal::uuid(const SparseUUIDArray_Entry* msg) {
  return *msg->_impl_.uuid_;
}
SparseUUIDArray_Entry::SparseUUIDArray_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.SparseUUIDArray.Entry)
}
SparseUUIDArray_Entry::SparseUUIDArray_Entry(const SparseUUIDArray_Entry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SparseUUIDArray_Entry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uuid_){nullptr}
    , decltype(_impl_.index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_uuid()) {
    _this->_impl_.uuid_ = new ::TSP::UUID(*from._impl_.uuid_);
  }
  _this->_impl_.index_ = from._impl_.index_;
  // @@protoc_insertion_point(copy_constructor:TSP.SparseUUIDArray.Entry)
}

inline void SparseUUIDArray_Entry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uuid_){nullptr}
    , decltype(_impl_.index_){0u}
  };
}

SparseUUIDArray_Entry::~SparseUUIDArray_Entry() {
  // @@protoc_insertion_point(destructor:TSP.SparseUUIDArray.Entry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SparseUUIDArray_Entry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.uuid_;
}

void SparseUUIDArray_Entry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SparseUUIDArray_Entry::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.SparseUUIDArray.Entry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.uuid_ != nullptr);
    _impl_.uuid_->Clear();
  }
  _impl_.index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SparseUUIDArray_Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.UUID uuid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_uuid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SparseUUIDArray_Entry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.SparseUUIDArray.Entry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 index = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_index(), target);
  }

  // required .TSP.UUID uuid = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::uuid(this),
        _Internal::uuid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.SparseUUIDArray.Entry)
  return target;
}

size_t SparseUUIDArray_Entry::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSP.SparseUUIDArray.Entry)
  size_t total_size = 0;

  if (_internal_has_uuid()) {
    // required .TSP.UUID uuid = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.uuid_);
  }

  if (_internal_has_index()) {
    // required uint32 index = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
  }

  return total_size;
}
size_t SparseUUIDArray_Entry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.SparseUUIDArray.Entry)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TSP.UUID uuid = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.uuid_);

    // required uint32 index = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SparseUUIDArray_Entry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SparseUUIDArray_Entry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SparseUUIDArray_Entry::GetClassData() const { return &_class_data_; }


void SparseUUIDArray_Entry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SparseUUIDArray_Entry*>(&to_msg);
  auto& from = static_cast<const SparseUUIDArray_Entry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.SparseUUIDArray.Entry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_uuid()->::TSP::UUID::MergeFrom(
          from._internal_uuid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SparseUUIDArray_Entry::CopyFrom(const SparseUUIDArray_Entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.SparseUUIDArray.Entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparseUUIDArray_Entry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_uuid()) {
    if (!_impl_.uuid_->IsInitialized()) return false;
  }
  return true;
}

void SparseUUIDArray_Entry::InternalSwap(SparseUUIDArray_Entry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SparseUUIDArray_Entry, _impl_.index_)
      + sizeof(SparseUUIDArray_Entry::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(SparseUUIDArray_Entry, _impl_.uuid_)>(
          reinterpret_cast<char*>(&_impl_.uuid_),
          reinterpret_cast<char*>(&other->_impl_.uuid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SparseUUIDArray_Entry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[21]);
}

// ===================================================================

class SparseUUIDArray::_Internal {
 public:
  using HasBits = decltype(std::declval<SparseUUIDArray>()._impl_._has_bits_);
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SparseUUIDArray::SparseUUIDArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.SparseUUIDArray)
}
SparseUUIDArray::SparseUUIDArray(const SparseUUIDArray& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SparseUUIDArray* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entries_){from._impl_.entries_}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.count_ = from._impl_.count_;
  // @@protoc_insertion_point(copy_constructor:TSP.SparseUUIDArray)
}

inline void SparseUUIDArray::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entries_){arena}
    , decltype(_impl_.count_){0u}
  };
}

SparseUUIDArray::~SparseUUIDArray() {
  // @@protoc_insertion_point(destructor:TSP.SparseUUIDArray)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SparseUUIDArray::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entries_.~RepeatedPtrField();
}

void SparseUUIDArray::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SparseUUIDArray::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.SparseUUIDArray)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  _impl_.count_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SparseUUIDArray::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.SparseUUIDArray.Entry entries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SparseUUIDArray::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.SparseUUIDArray)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_count(), target);
  }

  // repeated .TSP.SparseUUIDArray.Entry entries = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.SparseUUIDArray)
  return target;
}

size_t SparseUUIDArray::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.SparseUUIDArray)
  size_t total_size = 0;

  // required uint32 count = 1;
  if (_internal_has_count()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.SparseUUIDArray.Entry entries = 2;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->_impl_.entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SparseUUIDArray::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SparseUUIDArray::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SparseUUIDArray::GetClassData() const { return &_class_data_; }


void SparseUUIDArray::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SparseUUIDArray*>(&to_msg);
  auto& from = static_cast<const SparseUUIDArray&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.SparseUUIDArray)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
  if (from._internal_has_count()) {
    _this->_internal_set_count(from._internal_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SparseUUIDArray::CopyFrom(const SparseUUIDArray& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.SparseUUIDArray)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparseUUIDArray::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.entries_))
    return false;
  return true;
}

void SparseUUIDArray::InternalSwap(SparseUUIDArray* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
  swap(_impl_.count_, other->_impl_.count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SparseUUIDArray::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[22]);
}

// ===================================================================

class UUIDPath::_Internal {
 public:
};

UUIDPath::UUIDPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.UUIDPath)
}
UUIDPath::UUIDPath(const UUIDPath& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UUIDPath* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.uuids_){from._impl_.uuids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSP.UUIDPath)
}

inline void UUIDPath::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.uuids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UUIDPath::~UUIDPath() {
  // @@protoc_insertion_point(destructor:TSP.UUIDPath)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UUIDPath::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.uuids_.~RepeatedPtrField();
}

void UUIDPath::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UUIDPath::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.UUIDPath)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.uuids_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UUIDPath::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSP.UUID uuids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_uuids(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UUIDPath::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.UUIDPath)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSP.UUID uuids = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_uuids_size()); i < n; i++) {
    const auto& repfield = this->_internal_uuids(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.UUIDPath)
  return target;
}

size_t UUIDPath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.UUIDPath)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.UUID uuids = 1;
  total_size += 1UL * this->_internal_uuids_size();
  for (const auto& msg : this->_impl_.uuids_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UUIDPath::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UUIDPath::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UUIDPath::GetClassData() const { return &_class_data_; }


void UUIDPath::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UUIDPath*>(&to_msg);
  auto& from = static_cast<const UUIDPath&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.UUIDPath)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.uuids_.MergeFrom(from._impl_.uuids_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UUIDPath::CopyFrom(const UUIDPath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.UUIDPath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UUIDPath::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.uuids_))
    return false;
  return true;
}

void UUIDPath::InternalSwap(UUIDPath* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.uuids_.InternalSwap(&other->_impl_.uuids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UUIDPath::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[23]);
}

// ===================================================================

class SparseUUIDPathArray_Entry::_Internal {
 public:
  using HasBits = decltype(std::declval<SparseUUIDPathArray_Entry>()._impl_._has_bits_);
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::UUIDPath& uuid_path(const SparseUUIDPathArray_Entry* msg);
  static void set_has_uuid_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSP::UUIDPath&
SparseUUIDPathArray_Entry::_Internal::uuid_path(const SparseUUIDPathArray_Entry* msg) {
  return *msg->_impl_.uuid_path_;
}
SparseUUIDPathArray_Entry::SparseUUIDPathArray_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.SparseUUIDPathArray.Entry)
}
SparseUUIDPathArray_Entry::SparseUUIDPathArray_Entry(const SparseUUIDPathArray_Entry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SparseUUIDPathArray_Entry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uuid_path_){nullptr}
    , decltype(_impl_.index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_uuid_path()) {
    _this->_impl_.uuid_path_ = new ::TSP::UUIDPath(*from._impl_.uuid_path_);
  }
  _this->_impl_.index_ = from._impl_.index_;
  // @@protoc_insertion_point(copy_constructor:TSP.SparseUUIDPathArray.Entry)
}

inline void SparseUUIDPathArray_Entry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uuid_path_){nullptr}
    , decltype(_impl_.index_){0u}
  };
}

SparseUUIDPathArray_Entry::~SparseUUIDPathArray_Entry() {
  // @@protoc_insertion_point(destructor:TSP.SparseUUIDPathArray.Entry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SparseUUIDPathArray_Entry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.uuid_path_;
}

void SparseUUIDPathArray_Entry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SparseUUIDPathArray_Entry::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.SparseUUIDPathArray.Entry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.uuid_path_ != nullptr);
    _impl_.uuid_path_->Clear();
  }
  _impl_.index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SparseUUIDPathArray_Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.UUIDPath uuid_path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_uuid_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SparseUUIDPathArray_Entry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.SparseUUIDPathArray.Entry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 index = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_index(), target);
  }

  // required .TSP.UUIDPath uuid_path = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::uuid_path(this),
        _Internal::uuid_path(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.SparseUUIDPathArray.Entry)
  return target;
}

size_t SparseUUIDPathArray_Entry::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSP.SparseUUIDPathArray.Entry)
  size_t total_size = 0;

  if (_internal_has_uuid_path()) {
    // required .TSP.UUIDPath uuid_path = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.uuid_path_);
  }

  if (_internal_has_index()) {
    // required uint32 index = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
  }

  return total_size;
}
size_t SparseUUIDPathArray_Entry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.SparseUUIDPathArray.Entry)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TSP.UUIDPath uuid_path = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.uuid_path_);

    // required uint32 index = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SparseUUIDPathArray_Entry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SparseUUIDPathArray_Entry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SparseUUIDPathArray_Entry::GetClassData() const { return &_class_data_; }


void SparseUUIDPathArray_Entry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SparseUUIDPathArray_Entry*>(&to_msg);
  auto& from = static_cast<const SparseUUIDPathArray_Entry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.SparseUUIDPathArray.Entry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_uuid_path()->::TSP::UUIDPath::MergeFrom(
          from._internal_uuid_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SparseUUIDPathArray_Entry::CopyFrom(const SparseUUIDPathArray_Entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.SparseUUIDPathArray.Entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparseUUIDPathArray_Entry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_uuid_path()) {
    if (!_impl_.uuid_path_->IsInitialized()) return false;
  }
  return true;
}

void SparseUUIDPathArray_Entry::InternalSwap(SparseUUIDPathArray_Entry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SparseUUIDPathArray_Entry, _impl_.index_)
      + sizeof(SparseUUIDPathArray_Entry::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(SparseUUIDPathArray_Entry, _impl_.uuid_path_)>(
          reinterpret_cast<char*>(&_impl_.uuid_path_),
          reinterpret_cast<char*>(&other->_impl_.uuid_path_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SparseUUIDPathArray_Entry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[24]);
}

// ===================================================================

class SparseUUIDPathArray::_Internal {
 public:
  using HasBits = decltype(std::declval<SparseUUIDPathArray>()._impl_._has_bits_);
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SparseUUIDPathArray::SparseUUIDPathArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.SparseUUIDPathArray)
}
SparseUUIDPathArray::SparseUUIDPathArray(const SparseUUIDPathArray& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SparseUUIDPathArray* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entries_){from._impl_.entries_}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.count_ = from._impl_.count_;
  // @@protoc_insertion_point(copy_constructor:TSP.SparseUUIDPathArray)
}

inline void SparseUUIDPathArray::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entries_){arena}
    , decltype(_impl_.count_){0u}
  };
}

SparseUUIDPathArray::~SparseUUIDPathArray() {
  // @@protoc_insertion_point(destructor:TSP.SparseUUIDPathArray)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SparseUUIDPathArray::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entries_.~RepeatedPtrField();
}

void SparseUUIDPathArray::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SparseUUIDPathArray::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.SparseUUIDPathArray)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  _impl_.count_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SparseUUIDPathArray::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.SparseUUIDPathArray.Entry entries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SparseUUIDPathArray::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.SparseUUIDPathArray)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_count(), target);
  }

  // repeated .TSP.SparseUUIDPathArray.Entry entries = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.SparseUUIDPathArray)
  return target;
}

size_t SparseUUIDPathArray::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.SparseUUIDPathArray)
  size_t total_size = 0;

  // required uint32 count = 1;
  if (_internal_has_count()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.SparseUUIDPathArray.Entry entries = 2;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->_impl_.entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SparseUUIDPathArray::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SparseUUIDPathArray::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SparseUUIDPathArray::GetClassData() const { return &_class_data_; }


void SparseUUIDPathArray::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SparseUUIDPathArray*>(&to_msg);
  auto& from = static_cast<const SparseUUIDPathArray&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.SparseUUIDPathArray)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
  if (from._internal_has_count()) {
    _this->_internal_set_count(from._internal_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SparseUUIDPathArray::CopyFrom(const SparseUUIDPathArray& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.SparseUUIDPathArray)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparseUUIDPathArray::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.entries_))
    return false;
  return true;
}

void SparseUUIDPathArray::InternalSwap(SparseUUIDPathArray* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
  swap(_impl_.count_, other->_impl_.count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SparseUUIDPathArray::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[25]);
}

// ===================================================================

class PasteboardObject::_Internal {
 public:
  using HasBits = decltype(std::declval<PasteboardObject>()._impl_._has_bits_);
  static const ::TSP::Reference& stylesheet(const PasteboardObject* msg);
  static void set_has_stylesheet(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& wp_storage(const PasteboardObject* msg);
  static void set_has_wp_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& guide_storage(const PasteboardObject* msg);
  static void set_has_guide_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& app_native_object(const PasteboardObject* msg);
  static void set_has_app_native_object(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_text_primary(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_smart(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSP::Reference& native_content_description(const PasteboardObject* msg);
  static void set_has_native_content_description(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::TSP::Reference&
PasteboardObject::_Internal::stylesheet(const PasteboardObject* msg) {
  return *msg->_impl_.stylesheet_;
}
const ::TSP::Reference&
PasteboardObject::_Internal::wp_storage(const PasteboardObject* msg) {
  return *msg->_impl_.wp_storage_;
}
const ::TSP::Reference&
PasteboardObject::_Internal::guide_storage(const PasteboardObject* msg) {
  return *msg->_impl_.guide_storage_;
}
const ::TSP::Reference&
PasteboardObject::_Internal::app_native_object(const PasteboardObject* msg) {
  return *msg->_impl_.app_native_object_;
}
const ::TSP::Reference&
PasteboardObject::_Internal::native_content_description(const PasteboardObject* msg) {
  return *msg->_impl_.native_content_description_;
}
PasteboardObject::PasteboardObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.PasteboardObject)
}
PasteboardObject::PasteboardObject(const PasteboardObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PasteboardObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawables_){from._impl_.drawables_}
    , decltype(_impl_.styles_){from._impl_.styles_}
    , decltype(_impl_.presets_){from._impl_.presets_}
    , decltype(_impl_.top_level_objects_){from._impl_.top_level_objects_}
    , decltype(_impl_.stylesheet_){nullptr}
    , decltype(_impl_.wp_storage_){nullptr}
    , decltype(_impl_.app_native_object_){nullptr}
    , decltype(_impl_.guide_storage_){nullptr}
    , decltype(_impl_.native_content_description_){nullptr}
    , decltype(_impl_.is_text_primary_){}
    , decltype(_impl_.is_smart_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stylesheet()) {
    _this->_impl_.stylesheet_ = new ::TSP::Reference(*from._impl_.stylesheet_);
  }
  if (from._internal_has_wp_storage()) {
    _this->_impl_.wp_storage_ = new ::TSP::Reference(*from._impl_.wp_storage_);
  }
  if (from._internal_has_app_native_object()) {
    _this->_impl_.app_native_object_ = new ::TSP::Reference(*from._impl_.app_native_object_);
  }
  if (from._internal_has_guide_storage()) {
    _this->_impl_.guide_storage_ = new ::TSP::Reference(*from._impl_.guide_storage_);
  }
  if (from._internal_has_native_content_description()) {
    _this->_impl_.native_content_description_ = new ::TSP::Reference(*from._impl_.native_content_description_);
  }
  ::memcpy(&_impl_.is_text_primary_, &from._impl_.is_text_primary_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_smart_) -
    reinterpret_cast<char*>(&_impl_.is_text_primary_)) + sizeof(_impl_.is_smart_));
  // @@protoc_insertion_point(copy_constructor:TSP.PasteboardObject)
}

inline void PasteboardObject::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawables_){arena}
    , decltype(_impl_.styles_){arena}
    , decltype(_impl_.presets_){arena}
    , decltype(_impl_.top_level_objects_){arena}
    , decltype(_impl_.stylesheet_){nullptr}
    , decltype(_impl_.wp_storage_){nullptr}
    , decltype(_impl_.app_native_object_){nullptr}
    , decltype(_impl_.guide_storage_){nullptr}
    , decltype(_impl_.native_content_description_){nullptr}
    , decltype(_impl_.is_text_primary_){false}
    , decltype(_impl_.is_smart_){false}
  };
}

PasteboardObject::~PasteboardObject() {
  // @@protoc_insertion_point(destructor:TSP.PasteboardObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PasteboardObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.drawables_.~RepeatedPtrField();
  _impl_.styles_.~RepeatedPtrField();
  _impl_.presets_.~RepeatedPtrField();
  _impl_.top_level_objects_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.stylesheet_;
  if (this != internal_default_instance()) delete _impl_.wp_storage_;
  if (this != internal_default_instance()) delete _impl_.app_native_object_;
  if (this != internal_default_instance()) delete _impl_.guide_storage_;
  if (this != internal_default_instance()) delete _impl_.native_content_description_;
}

void PasteboardObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PasteboardObject::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.PasteboardObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.drawables_.Clear();
  _impl_.styles_.Clear();
  _impl_.presets_.Clear();
  _impl_.top_level_objects_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.stylesheet_ != nullptr);
      _impl_.stylesheet_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.wp_storage_ != nullptr);
      _impl_.wp_storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.app_native_object_ != nullptr);
      _impl_.app_native_object_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.guide_storage_ != nullptr);
      _impl_.guide_storage_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.native_content_description_ != nullptr);
      _impl_.native_content_description_->Clear();
    }
  }
  ::memset(&_impl_.is_text_primary_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_smart_) -
      reinterpret_cast<char*>(&_impl_.is_text_primary_)) + sizeof(_impl_.is_smart_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PasteboardObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference stylesheet = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stylesheet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference drawables = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_drawables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference styles = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_styles(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference wp_storage = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_wp_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference app_native_object = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_app_native_object(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_text_primary = 7 [default = false];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_is_text_primary(&has_bits);
          _impl_.is_text_primary_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_smart = 8 [default = false];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_is_smart(&has_bits);
          _impl_.is_smart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference guide_storage = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_guide_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference presets = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference top_level_objects = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_top_level_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference native_content_description = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_native_content_description(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PasteboardObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.PasteboardObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference stylesheet = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stylesheet(this),
        _Internal::stylesheet(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference drawables = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_drawables_size()); i < n; i++) {
    const auto& repfield = this->_internal_drawables(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference styles = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_styles_size()); i < n; i++) {
    const auto& repfield = this->_internal_styles(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference wp_storage = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::wp_storage(this),
        _Internal::wp_storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference app_native_object = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::app_native_object(this),
        _Internal::app_native_object(this).GetCachedSize(), target, stream);
  }

  // optional bool is_text_primary = 7 [default = false];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_is_text_primary(), target);
  }

  // optional bool is_smart = 8 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_is_smart(), target);
  }

  // optional .TSP.Reference guide_storage = 9;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::guide_storage(this),
        _Internal::guide_storage(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference presets = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference top_level_objects = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_top_level_objects_size()); i < n; i++) {
    const auto& repfield = this->_internal_top_level_objects(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference native_content_description = 12;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::native_content_description(this),
        _Internal::native_content_description(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.PasteboardObject)
  return target;
}

size_t PasteboardObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.PasteboardObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference drawables = 2;
  total_size += 1UL * this->_internal_drawables_size();
  for (const auto& msg : this->_impl_.drawables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference styles = 3;
  total_size += 1UL * this->_internal_styles_size();
  for (const auto& msg : this->_impl_.styles_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference presets = 10;
  total_size += 1UL * this->_internal_presets_size();
  for (const auto& msg : this->_impl_.presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference top_level_objects = 11;
  total_size += 1UL * this->_internal_top_level_objects_size();
  for (const auto& msg : this->_impl_.top_level_objects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .TSP.Reference stylesheet = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stylesheet_);
    }

    // optional .TSP.Reference wp_storage = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.wp_storage_);
    }

    // optional .TSP.Reference app_native_object = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.app_native_object_);
    }

    // optional .TSP.Reference guide_storage = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.guide_storage_);
    }

    // optional .TSP.Reference native_content_description = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.native_content_description_);
    }

    // optional bool is_text_primary = 7 [default = false];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool is_smart = 8 [default = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PasteboardObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PasteboardObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PasteboardObject::GetClassData() const { return &_class_data_; }


void PasteboardObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PasteboardObject*>(&to_msg);
  auto& from = static_cast<const PasteboardObject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.PasteboardObject)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.drawables_.MergeFrom(from._impl_.drawables_);
  _this->_impl_.styles_.MergeFrom(from._impl_.styles_);
  _this->_impl_.presets_.MergeFrom(from._impl_.presets_);
  _this->_impl_.top_level_objects_.MergeFrom(from._impl_.top_level_objects_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_stylesheet()->::TSP::Reference::MergeFrom(
          from._internal_stylesheet());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_wp_storage()->::TSP::Reference::MergeFrom(
          from._internal_wp_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_app_native_object()->::TSP::Reference::MergeFrom(
          from._internal_app_native_object());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_guide_storage()->::TSP::Reference::MergeFrom(
          from._internal_guide_storage());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_native_content_description()->::TSP::Reference::MergeFrom(
          from._internal_native_content_description());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.is_text_primary_ = from._impl_.is_text_primary_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.is_smart_ = from._impl_.is_smart_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PasteboardObject::CopyFrom(const PasteboardObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.PasteboardObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PasteboardObject::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.drawables_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.styles_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.presets_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.top_level_objects_))
    return false;
  if (_internal_has_stylesheet()) {
    if (!_impl_.stylesheet_->IsInitialized()) return false;
  }
  if (_internal_has_wp_storage()) {
    if (!_impl_.wp_storage_->IsInitialized()) return false;
  }
  if (_internal_has_app_native_object()) {
    if (!_impl_.app_native_object_->IsInitialized()) return false;
  }
  if (_internal_has_guide_storage()) {
    if (!_impl_.guide_storage_->IsInitialized()) return false;
  }
  if (_internal_has_native_content_description()) {
    if (!_impl_.native_content_description_->IsInitialized()) return false;
  }
  return true;
}

void PasteboardObject::InternalSwap(PasteboardObject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.drawables_.InternalSwap(&other->_impl_.drawables_);
  _impl_.styles_.InternalSwap(&other->_impl_.styles_);
  _impl_.presets_.InternalSwap(&other->_impl_.presets_);
  _impl_.top_level_objects_.InternalSwap(&other->_impl_.top_level_objects_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PasteboardObject, _impl_.is_smart_)
      + sizeof(PasteboardObject::_impl_.is_smart_)
      - PROTOBUF_FIELD_OFFSET(PasteboardObject, _impl_.stylesheet_)>(
          reinterpret_cast<char*>(&_impl_.stylesheet_),
          reinterpret_cast<char*>(&other->_impl_.stylesheet_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PasteboardObject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[26]);
}

// ===================================================================

class ObjectCollection::_Internal {
 public:
};

ObjectCollection::ObjectCollection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.ObjectCollection)
}
ObjectCollection::ObjectCollection(const ObjectCollection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ObjectCollection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.objects_){from._impl_.objects_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSP.ObjectCollection)
}

inline void ObjectCollection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.objects_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ObjectCollection::~ObjectCollection() {
  // @@protoc_insertion_point(destructor:TSP.ObjectCollection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ObjectCollection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.objects_.~RepeatedPtrField();
}

void ObjectCollection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ObjectCollection::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.ObjectCollection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objects_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectCollection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSP.Reference objects = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectCollection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.ObjectCollection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSP.Reference objects = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_objects_size()); i < n; i++) {
    const auto& repfield = this->_internal_objects(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.ObjectCollection)
  return target;
}

size_t ObjectCollection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.ObjectCollection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference objects = 1;
  total_size += 1UL * this->_internal_objects_size();
  for (const auto& msg : this->_impl_.objects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectCollection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ObjectCollection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectCollection::GetClassData() const { return &_class_data_; }


void ObjectCollection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ObjectCollection*>(&to_msg);
  auto& from = static_cast<const ObjectCollection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.ObjectCollection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.objects_.MergeFrom(from._impl_.objects_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectCollection::CopyFrom(const ObjectCollection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.ObjectCollection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectCollection::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.objects_))
    return false;
  return true;
}

void ObjectCollection::InternalSwap(ObjectCollection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.objects_.InternalSwap(&other->_impl_.objects_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectCollection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[27]);
}

// ===================================================================

class ObjectContainer::_Internal {
 public:
  using HasBits = decltype(std::declval<ObjectContainer>()._impl_._has_bits_);
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ObjectContainer::ObjectContainer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.ObjectContainer)
}
ObjectContainer::ObjectContainer(const ObjectContainer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ObjectContainer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objects_){from._impl_.objects_}
    , decltype(_impl_.identifier_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.identifier_ = from._impl_.identifier_;
  // @@protoc_insertion_point(copy_constructor:TSP.ObjectContainer)
}

inline void ObjectContainer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objects_){arena}
    , decltype(_impl_.identifier_){0u}
  };
}

ObjectContainer::~ObjectContainer() {
  // @@protoc_insertion_point(destructor:TSP.ObjectContainer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ObjectContainer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.objects_.~RepeatedPtrField();
}

void ObjectContainer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ObjectContainer::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.ObjectContainer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objects_.Clear();
  _impl_.identifier_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectContainer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_identifier(&has_bits);
          _impl_.identifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference objects = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectContainer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.ObjectContainer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_identifier(), target);
  }

  // repeated .TSP.Reference objects = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_objects_size()); i < n; i++) {
    const auto& repfield = this->_internal_objects(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.ObjectContainer)
  return target;
}

size_t ObjectContainer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.ObjectContainer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference objects = 2;
  total_size += 1UL * this->_internal_objects_size();
  for (const auto& msg : this->_impl_.objects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 identifier = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_identifier());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectContainer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ObjectContainer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectContainer::GetClassData() const { return &_class_data_; }


void ObjectContainer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ObjectContainer*>(&to_msg);
  auto& from = static_cast<const ObjectContainer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.ObjectContainer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.objects_.MergeFrom(from._impl_.objects_);
  if (from._internal_has_identifier()) {
    _this->_internal_set_identifier(from._internal_identifier());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectContainer::CopyFrom(const ObjectContainer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.ObjectContainer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectContainer::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.objects_))
    return false;
  return true;
}

void ObjectContainer::InternalSwap(ObjectContainer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.objects_.InternalSwap(&other->_impl_.objects_);
  swap(_impl_.identifier_, other->_impl_.identifier_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectContainer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[28]);
}

// ===================================================================

class DataAttributes::_Internal {
 public:
};

DataAttributes::DataAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.DataAttributes)
}
DataAttributes::DataAttributes(const DataAttributes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DataAttributes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  // @@protoc_insertion_point(copy_constructor:TSP.DataAttributes)
}

inline void DataAttributes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DataAttributes::~DataAttributes() {
  // @@protoc_insertion_point(destructor:TSP.DataAttributes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataAttributes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
}

void DataAttributes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataAttributes::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.DataAttributes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DataAttributes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((800u <= tag)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataAttributes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.DataAttributes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // Extension range [100, 536870912)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 100, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.DataAttributes)
  return target;
}

size_t DataAttributes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.DataAttributes)
  size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DataAttributes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DataAttributes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DataAttributes::GetClassData() const { return &_class_data_; }


void DataAttributes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DataAttributes*>(&to_msg);
  auto& from = static_cast<const DataAttributes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.DataAttributes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DataAttributes::CopyFrom(const DataAttributes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.DataAttributes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataAttributes::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void DataAttributes::InternalSwap(DataAttributes* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DataAttributes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[29]);
}

// ===================================================================

class LargeArraySegment::_Internal {
 public:
  using HasBits = decltype(std::declval<LargeArraySegment>()._impl_._has_bits_);
  static void set_has_should_delay_archiving(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_delayed_archiving_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_package_locator(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LargeArraySegment::LargeArraySegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.LargeArraySegment)
}
LargeArraySegment::LargeArraySegment(const LargeArraySegment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LargeArraySegment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.package_locator_){}
    , decltype(_impl_.should_delay_archiving_){}
    , decltype(_impl_.delayed_archiving_priority_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.package_locator_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.package_locator_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_package_locator()) {
    _this->_impl_.package_locator_.Set(from._internal_package_locator(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.should_delay_archiving_, &from._impl_.should_delay_archiving_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.delayed_archiving_priority_) -
    reinterpret_cast<char*>(&_impl_.should_delay_archiving_)) + sizeof(_impl_.delayed_archiving_priority_));
  // @@protoc_insertion_point(copy_constructor:TSP.LargeArraySegment)
}

inline void LargeArraySegment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.package_locator_){}
    , decltype(_impl_.should_delay_archiving_){false}
    , decltype(_impl_.delayed_archiving_priority_){0u}
  };
  _impl_.package_locator_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.package_locator_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LargeArraySegment::~LargeArraySegment() {
  // @@protoc_insertion_point(destructor:TSP.LargeArraySegment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LargeArraySegment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.package_locator_.Destroy();
}

void LargeArraySegment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LargeArraySegment::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.LargeArraySegment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.package_locator_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.should_delay_archiving_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.delayed_archiving_priority_) -
        reinterpret_cast<char*>(&_impl_.should_delay_archiving_)) + sizeof(_impl_.delayed_archiving_priority_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LargeArraySegment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool should_delay_archiving = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_should_delay_archiving(&has_bits);
          _impl_.should_delay_archiving_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 delayed_archiving_priority = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_delayed_archiving_priority(&has_bits);
          _impl_.delayed_archiving_priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string package_locator = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_package_locator();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSP.LargeArraySegment.package_locator");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LargeArraySegment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.LargeArraySegment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool should_delay_archiving = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_should_delay_archiving(), target);
  }

  // optional uint32 delayed_archiving_priority = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_delayed_archiving_priority(), target);
  }

  // optional string package_locator = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_package_locator().data(), static_cast<int>(this->_internal_package_locator().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSP.LargeArraySegment.package_locator");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_package_locator(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.LargeArraySegment)
  return target;
}

size_t LargeArraySegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.LargeArraySegment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string package_locator = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_package_locator());
    }

    // optional bool should_delay_archiving = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional uint32 delayed_archiving_priority = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_delayed_archiving_priority());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LargeArraySegment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LargeArraySegment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LargeArraySegment::GetClassData() const { return &_class_data_; }


void LargeArraySegment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LargeArraySegment*>(&to_msg);
  auto& from = static_cast<const LargeArraySegment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.LargeArraySegment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_package_locator(from._internal_package_locator());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.should_delay_archiving_ = from._impl_.should_delay_archiving_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.delayed_archiving_priority_ = from._impl_.delayed_archiving_priority_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LargeArraySegment::CopyFrom(const LargeArraySegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.LargeArraySegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LargeArraySegment::IsInitialized() const {
  return true;
}

void LargeArraySegment::InternalSwap(LargeArraySegment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.package_locator_, lhs_arena,
      &other->_impl_.package_locator_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LargeArraySegment, _impl_.delayed_archiving_priority_)
      + sizeof(LargeArraySegment::_impl_.delayed_archiving_priority_)
      - PROTOBUF_FIELD_OFFSET(LargeArraySegment, _impl_.should_delay_archiving_)>(
          reinterpret_cast<char*>(&_impl_.should_delay_archiving_),
          reinterpret_cast<char*>(&other->_impl_.should_delay_archiving_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LargeArraySegment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[30]);
}

// ===================================================================

class LargeNumberArraySegment::_Internal {
 public:
  using HasBits = decltype(std::declval<LargeNumberArraySegment>()._impl_._has_bits_);
  static const ::TSP::LargeArraySegment& large_array_segment(const LargeNumberArraySegment* msg);
  static void set_has_large_array_segment(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::LargeArraySegment&
LargeNumberArraySegment::_Internal::large_array_segment(const LargeNumberArraySegment* msg) {
  return *msg->_impl_.large_array_segment_;
}
LargeNumberArraySegment::LargeNumberArraySegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.LargeNumberArraySegment)
}
LargeNumberArraySegment::LargeNumberArraySegment(const LargeNumberArraySegment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LargeNumberArraySegment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.elements_){from._impl_.elements_}
    , decltype(_impl_.large_array_segment_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_large_array_segment()) {
    _this->_impl_.large_array_segment_ = new ::TSP::LargeArraySegment(*from._impl_.large_array_segment_);
  }
  // @@protoc_insertion_point(copy_constructor:TSP.LargeNumberArraySegment)
}

inline void LargeNumberArraySegment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.elements_){arena}
    , decltype(_impl_.large_array_segment_){nullptr}
  };
}

LargeNumberArraySegment::~LargeNumberArraySegment() {
  // @@protoc_insertion_point(destructor:TSP.LargeNumberArraySegment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LargeNumberArraySegment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.elements_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.large_array_segment_;
}

void LargeNumberArraySegment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LargeNumberArraySegment::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.LargeNumberArraySegment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.elements_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.large_array_segment_ != nullptr);
    _impl_.large_array_segment_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LargeNumberArraySegment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.LargeArraySegment large_array_segment = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_large_array_segment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double elements = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_elements(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<17>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_elements(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LargeNumberArraySegment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.LargeNumberArraySegment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.LargeArraySegment large_array_segment = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::large_array_segment(this),
        _Internal::large_array_segment(this).GetCachedSize(), target, stream);
  }

  // repeated double elements = 2;
  for (int i = 0, n = this->_internal_elements_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_elements(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.LargeNumberArraySegment)
  return target;
}

size_t LargeNumberArraySegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.LargeNumberArraySegment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double elements = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_elements_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_elements_size());
    total_size += data_size;
  }

  // optional .TSP.LargeArraySegment large_array_segment = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.large_array_segment_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LargeNumberArraySegment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LargeNumberArraySegment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LargeNumberArraySegment::GetClassData() const { return &_class_data_; }


void LargeNumberArraySegment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LargeNumberArraySegment*>(&to_msg);
  auto& from = static_cast<const LargeNumberArraySegment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.LargeNumberArraySegment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.elements_.MergeFrom(from._impl_.elements_);
  if (from._internal_has_large_array_segment()) {
    _this->_internal_mutable_large_array_segment()->::TSP::LargeArraySegment::MergeFrom(
        from._internal_large_array_segment());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LargeNumberArraySegment::CopyFrom(const LargeNumberArraySegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.LargeNumberArraySegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LargeNumberArraySegment::IsInitialized() const {
  return true;
}

void LargeNumberArraySegment::InternalSwap(LargeNumberArraySegment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.elements_.InternalSwap(&other->_impl_.elements_);
  swap(_impl_.large_array_segment_, other->_impl_.large_array_segment_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LargeNumberArraySegment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[31]);
}

// ===================================================================

class LargeStringArraySegment_OptionalElement::_Internal {
 public:
  using HasBits = decltype(std::declval<LargeStringArraySegment_OptionalElement>()._impl_._has_bits_);
  static void set_has_element(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LargeStringArraySegment_OptionalElement::LargeStringArraySegment_OptionalElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.LargeStringArraySegment.OptionalElement)
}
LargeStringArraySegment_OptionalElement::LargeStringArraySegment_OptionalElement(const LargeStringArraySegment_OptionalElement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LargeStringArraySegment_OptionalElement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.element_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.element_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.element_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_element()) {
    _this->_impl_.element_.Set(from._internal_element(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:TSP.LargeStringArraySegment.OptionalElement)
}

inline void LargeStringArraySegment_OptionalElement::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.element_){}
  };
  _impl_.element_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.element_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LargeStringArraySegment_OptionalElement::~LargeStringArraySegment_OptionalElement() {
  // @@protoc_insertion_point(destructor:TSP.LargeStringArraySegment.OptionalElement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LargeStringArraySegment_OptionalElement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.element_.Destroy();
}

void LargeStringArraySegment_OptionalElement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LargeStringArraySegment_OptionalElement::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.LargeStringArraySegment.OptionalElement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.element_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LargeStringArraySegment_OptionalElement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string element = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_element();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSP.LargeStringArraySegment.OptionalElement.element");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LargeStringArraySegment_OptionalElement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.LargeStringArraySegment.OptionalElement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string element = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_element().data(), static_cast<int>(this->_internal_element().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSP.LargeStringArraySegment.OptionalElement.element");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_element(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.LargeStringArraySegment.OptionalElement)
  return target;
}

size_t LargeStringArraySegment_OptionalElement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.LargeStringArraySegment.OptionalElement)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string element = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_element());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LargeStringArraySegment_OptionalElement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LargeStringArraySegment_OptionalElement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LargeStringArraySegment_OptionalElement::GetClassData() const { return &_class_data_; }


void LargeStringArraySegment_OptionalElement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LargeStringArraySegment_OptionalElement*>(&to_msg);
  auto& from = static_cast<const LargeStringArraySegment_OptionalElement&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.LargeStringArraySegment.OptionalElement)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_element()) {
    _this->_internal_set_element(from._internal_element());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LargeStringArraySegment_OptionalElement::CopyFrom(const LargeStringArraySegment_OptionalElement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.LargeStringArraySegment.OptionalElement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LargeStringArraySegment_OptionalElement::IsInitialized() const {
  return true;
}

void LargeStringArraySegment_OptionalElement::InternalSwap(LargeStringArraySegment_OptionalElement* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.element_, lhs_arena,
      &other->_impl_.element_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LargeStringArraySegment_OptionalElement::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[32]);
}

// ===================================================================

class LargeStringArraySegment::_Internal {
 public:
  using HasBits = decltype(std::declval<LargeStringArraySegment>()._impl_._has_bits_);
  static const ::TSP::LargeArraySegment& large_array_segment(const LargeStringArraySegment* msg);
  static void set_has_large_array_segment(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::LargeArraySegment&
LargeStringArraySegment::_Internal::large_array_segment(const LargeStringArraySegment* msg) {
  return *msg->_impl_.large_array_segment_;
}
LargeStringArraySegment::LargeStringArraySegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.LargeStringArraySegment)
}
LargeStringArraySegment::LargeStringArraySegment(const LargeStringArraySegment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LargeStringArraySegment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.elements_){from._impl_.elements_}
    , decltype(_impl_.large_array_segment_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_large_array_segment()) {
    _this->_impl_.large_array_segment_ = new ::TSP::LargeArraySegment(*from._impl_.large_array_segment_);
  }
  // @@protoc_insertion_point(copy_constructor:TSP.LargeStringArraySegment)
}

inline void LargeStringArraySegment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.elements_){arena}
    , decltype(_impl_.large_array_segment_){nullptr}
  };
}

LargeStringArraySegment::~LargeStringArraySegment() {
  // @@protoc_insertion_point(destructor:TSP.LargeStringArraySegment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LargeStringArraySegment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.elements_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.large_array_segment_;
}

void LargeStringArraySegment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LargeStringArraySegment::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.LargeStringArraySegment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.elements_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.large_array_segment_ != nullptr);
    _impl_.large_array_segment_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LargeStringArraySegment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.LargeArraySegment large_array_segment = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_large_array_segment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.LargeStringArraySegment.OptionalElement elements = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_elements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LargeStringArraySegment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.LargeStringArraySegment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.LargeArraySegment large_array_segment = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::large_array_segment(this),
        _Internal::large_array_segment(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.LargeStringArraySegment.OptionalElement elements = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_elements_size()); i < n; i++) {
    const auto& repfield = this->_internal_elements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.LargeStringArraySegment)
  return target;
}

size_t LargeStringArraySegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.LargeStringArraySegment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.LargeStringArraySegment.OptionalElement elements = 2;
  total_size += 1UL * this->_internal_elements_size();
  for (const auto& msg : this->_impl_.elements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TSP.LargeArraySegment large_array_segment = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.large_array_segment_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LargeStringArraySegment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LargeStringArraySegment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LargeStringArraySegment::GetClassData() const { return &_class_data_; }


void LargeStringArraySegment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LargeStringArraySegment*>(&to_msg);
  auto& from = static_cast<const LargeStringArraySegment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.LargeStringArraySegment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.elements_.MergeFrom(from._impl_.elements_);
  if (from._internal_has_large_array_segment()) {
    _this->_internal_mutable_large_array_segment()->::TSP::LargeArraySegment::MergeFrom(
        from._internal_large_array_segment());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LargeStringArraySegment::CopyFrom(const LargeStringArraySegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.LargeStringArraySegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LargeStringArraySegment::IsInitialized() const {
  return true;
}

void LargeStringArraySegment::InternalSwap(LargeStringArraySegment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.elements_.InternalSwap(&other->_impl_.elements_);
  swap(_impl_.large_array_segment_, other->_impl_.large_array_segment_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LargeStringArraySegment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[33]);
}

// ===================================================================

class LargeUUIDArraySegment::_Internal {
 public:
  using HasBits = decltype(std::declval<LargeUUIDArraySegment>()._impl_._has_bits_);
  static const ::TSP::LargeArraySegment& large_array_segment(const LargeUUIDArraySegment* msg);
  static void set_has_large_array_segment(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::LargeArraySegment&
LargeUUIDArraySegment::_Internal::large_array_segment(const LargeUUIDArraySegment* msg) {
  return *msg->_impl_.large_array_segment_;
}
LargeUUIDArraySegment::LargeUUIDArraySegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.LargeUUIDArraySegment)
}
LargeUUIDArraySegment::LargeUUIDArraySegment(const LargeUUIDArraySegment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LargeUUIDArraySegment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.elements_){from._impl_.elements_}
    , decltype(_impl_.large_array_segment_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_large_array_segment()) {
    _this->_impl_.large_array_segment_ = new ::TSP::LargeArraySegment(*from._impl_.large_array_segment_);
  }
  // @@protoc_insertion_point(copy_constructor:TSP.LargeUUIDArraySegment)
}

inline void LargeUUIDArraySegment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.elements_){arena}
    , decltype(_impl_.large_array_segment_){nullptr}
  };
}

LargeUUIDArraySegment::~LargeUUIDArraySegment() {
  // @@protoc_insertion_point(destructor:TSP.LargeUUIDArraySegment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LargeUUIDArraySegment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.elements_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.large_array_segment_;
}

void LargeUUIDArraySegment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LargeUUIDArraySegment::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.LargeUUIDArraySegment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.elements_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.large_array_segment_ != nullptr);
    _impl_.large_array_segment_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LargeUUIDArraySegment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.LargeArraySegment large_array_segment = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_large_array_segment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.UUID elements = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_elements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LargeUUIDArraySegment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.LargeUUIDArraySegment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.LargeArraySegment large_array_segment = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::large_array_segment(this),
        _Internal::large_array_segment(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.UUID elements = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_elements_size()); i < n; i++) {
    const auto& repfield = this->_internal_elements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.LargeUUIDArraySegment)
  return target;
}

size_t LargeUUIDArraySegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.LargeUUIDArraySegment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.UUID elements = 2;
  total_size += 1UL * this->_internal_elements_size();
  for (const auto& msg : this->_impl_.elements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TSP.LargeArraySegment large_array_segment = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.large_array_segment_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LargeUUIDArraySegment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LargeUUIDArraySegment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LargeUUIDArraySegment::GetClassData() const { return &_class_data_; }


void LargeUUIDArraySegment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LargeUUIDArraySegment*>(&to_msg);
  auto& from = static_cast<const LargeUUIDArraySegment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.LargeUUIDArraySegment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.elements_.MergeFrom(from._impl_.elements_);
  if (from._internal_has_large_array_segment()) {
    _this->_internal_mutable_large_array_segment()->::TSP::LargeArraySegment::MergeFrom(
        from._internal_large_array_segment());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LargeUUIDArraySegment::CopyFrom(const LargeUUIDArraySegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.LargeUUIDArraySegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LargeUUIDArraySegment::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.elements_))
    return false;
  return true;
}

void LargeUUIDArraySegment::InternalSwap(LargeUUIDArraySegment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.elements_.InternalSwap(&other->_impl_.elements_);
  swap(_impl_.large_array_segment_, other->_impl_.large_array_segment_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LargeUUIDArraySegment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[34]);
}

// ===================================================================

class LargeLazyObjectArraySegment::_Internal {
 public:
  using HasBits = decltype(std::declval<LargeLazyObjectArraySegment>()._impl_._has_bits_);
  static const ::TSP::LargeArraySegment& large_array_segment(const LargeLazyObjectArraySegment* msg);
  static void set_has_large_array_segment(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::LargeArraySegment&
LargeLazyObjectArraySegment::_Internal::large_array_segment(const LargeLazyObjectArraySegment* msg) {
  return *msg->_impl_.large_array_segment_;
}
LargeLazyObjectArraySegment::LargeLazyObjectArraySegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.LargeLazyObjectArraySegment)
}
LargeLazyObjectArraySegment::LargeLazyObjectArraySegment(const LargeLazyObjectArraySegment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LargeLazyObjectArraySegment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.elements_){from._impl_.elements_}
    , decltype(_impl_.large_array_segment_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_large_array_segment()) {
    _this->_impl_.large_array_segment_ = new ::TSP::LargeArraySegment(*from._impl_.large_array_segment_);
  }
  // @@protoc_insertion_point(copy_constructor:TSP.LargeLazyObjectArraySegment)
}

inline void LargeLazyObjectArraySegment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.elements_){arena}
    , decltype(_impl_.large_array_segment_){nullptr}
  };
}

LargeLazyObjectArraySegment::~LargeLazyObjectArraySegment() {
  // @@protoc_insertion_point(destructor:TSP.LargeLazyObjectArraySegment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LargeLazyObjectArraySegment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.elements_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.large_array_segment_;
}

void LargeLazyObjectArraySegment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LargeLazyObjectArraySegment::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.LargeLazyObjectArraySegment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.elements_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.large_array_segment_ != nullptr);
    _impl_.large_array_segment_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LargeLazyObjectArraySegment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.LargeArraySegment large_array_segment = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_large_array_segment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference elements = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_elements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LargeLazyObjectArraySegment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.LargeLazyObjectArraySegment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.LargeArraySegment large_array_segment = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::large_array_segment(this),
        _Internal::large_array_segment(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference elements = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_elements_size()); i < n; i++) {
    const auto& repfield = this->_internal_elements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.LargeLazyObjectArraySegment)
  return target;
}

size_t LargeLazyObjectArraySegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.LargeLazyObjectArraySegment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference elements = 2;
  total_size += 1UL * this->_internal_elements_size();
  for (const auto& msg : this->_impl_.elements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TSP.LargeArraySegment large_array_segment = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.large_array_segment_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LargeLazyObjectArraySegment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LargeLazyObjectArraySegment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LargeLazyObjectArraySegment::GetClassData() const { return &_class_data_; }


void LargeLazyObjectArraySegment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LargeLazyObjectArraySegment*>(&to_msg);
  auto& from = static_cast<const LargeLazyObjectArraySegment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.LargeLazyObjectArraySegment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.elements_.MergeFrom(from._impl_.elements_);
  if (from._internal_has_large_array_segment()) {
    _this->_internal_mutable_large_array_segment()->::TSP::LargeArraySegment::MergeFrom(
        from._internal_large_array_segment());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LargeLazyObjectArraySegment::CopyFrom(const LargeLazyObjectArraySegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.LargeLazyObjectArraySegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LargeLazyObjectArraySegment::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.elements_))
    return false;
  return true;
}

void LargeLazyObjectArraySegment::InternalSwap(LargeLazyObjectArraySegment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.elements_.InternalSwap(&other->_impl_.elements_);
  swap(_impl_.large_array_segment_, other->_impl_.large_array_segment_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LargeLazyObjectArraySegment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[35]);
}

// ===================================================================

class LargeObjectArraySegment::_Internal {
 public:
  using HasBits = decltype(std::declval<LargeObjectArraySegment>()._impl_._has_bits_);
  static const ::TSP::LargeArraySegment& large_array_segment(const LargeObjectArraySegment* msg);
  static void set_has_large_array_segment(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::LargeArraySegment&
LargeObjectArraySegment::_Internal::large_array_segment(const LargeObjectArraySegment* msg) {
  return *msg->_impl_.large_array_segment_;
}
LargeObjectArraySegment::LargeObjectArraySegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.LargeObjectArraySegment)
}
LargeObjectArraySegment::LargeObjectArraySegment(const LargeObjectArraySegment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LargeObjectArraySegment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.elements_){from._impl_.elements_}
    , decltype(_impl_.large_array_segment_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_large_array_segment()) {
    _this->_impl_.large_array_segment_ = new ::TSP::LargeArraySegment(*from._impl_.large_array_segment_);
  }
  // @@protoc_insertion_point(copy_constructor:TSP.LargeObjectArraySegment)
}

inline void LargeObjectArraySegment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.elements_){arena}
    , decltype(_impl_.large_array_segment_){nullptr}
  };
}

LargeObjectArraySegment::~LargeObjectArraySegment() {
  // @@protoc_insertion_point(destructor:TSP.LargeObjectArraySegment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LargeObjectArraySegment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.elements_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.large_array_segment_;
}

void LargeObjectArraySegment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LargeObjectArraySegment::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.LargeObjectArraySegment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.elements_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.large_array_segment_ != nullptr);
    _impl_.large_array_segment_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LargeObjectArraySegment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.LargeArraySegment large_array_segment = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_large_array_segment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference elements = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_elements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LargeObjectArraySegment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.LargeObjectArraySegment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.LargeArraySegment large_array_segment = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::large_array_segment(this),
        _Internal::large_array_segment(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference elements = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_elements_size()); i < n; i++) {
    const auto& repfield = this->_internal_elements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.LargeObjectArraySegment)
  return target;
}

size_t LargeObjectArraySegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.LargeObjectArraySegment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference elements = 2;
  total_size += 1UL * this->_internal_elements_size();
  for (const auto& msg : this->_impl_.elements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TSP.LargeArraySegment large_array_segment = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.large_array_segment_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LargeObjectArraySegment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LargeObjectArraySegment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LargeObjectArraySegment::GetClassData() const { return &_class_data_; }


void LargeObjectArraySegment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LargeObjectArraySegment*>(&to_msg);
  auto& from = static_cast<const LargeObjectArraySegment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.LargeObjectArraySegment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.elements_.MergeFrom(from._impl_.elements_);
  if (from._internal_has_large_array_segment()) {
    _this->_internal_mutable_large_array_segment()->::TSP::LargeArraySegment::MergeFrom(
        from._internal_large_array_segment());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LargeObjectArraySegment::CopyFrom(const LargeObjectArraySegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.LargeObjectArraySegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LargeObjectArraySegment::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.elements_))
    return false;
  return true;
}

void LargeObjectArraySegment::InternalSwap(LargeObjectArraySegment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.elements_.InternalSwap(&other->_impl_.elements_);
  swap(_impl_.large_array_segment_, other->_impl_.large_array_segment_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LargeObjectArraySegment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[36]);
}

// ===================================================================

class LargeArray::_Internal {
 public:
  using HasBits = decltype(std::declval<LargeArray>()._impl_._has_bits_);
  static void set_has_max_segment_element_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_segment_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_should_delay_archiving(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_delayed_archiving_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_store_outside_object_archive(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_estimated_byte_size(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_max_segment_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

LargeArray::LargeArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.LargeArray)
}
LargeArray::LargeArray(const LargeArray& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LargeArray* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ranges_){from._impl_.ranges_}
    , decltype(_impl_.segments_){from._impl_.segments_}
    , decltype(_impl_.max_segment_element_count_){}
    , decltype(_impl_.max_segment_size_){}
    , decltype(_impl_.delayed_archiving_priority_){}
    , decltype(_impl_.should_delay_archiving_){}
    , decltype(_impl_.store_outside_object_archive_){}
    , decltype(_impl_.estimated_byte_size_){}
    , decltype(_impl_.max_segment_cost_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.max_segment_element_count_, &from._impl_.max_segment_element_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_segment_cost_) -
    reinterpret_cast<char*>(&_impl_.max_segment_element_count_)) + sizeof(_impl_.max_segment_cost_));
  // @@protoc_insertion_point(copy_constructor:TSP.LargeArray)
}

inline void LargeArray::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ranges_){arena}
    , decltype(_impl_.segments_){arena}
    , decltype(_impl_.max_segment_element_count_){uint64_t{0u}}
    , decltype(_impl_.max_segment_size_){uint64_t{0u}}
    , decltype(_impl_.delayed_archiving_priority_){0u}
    , decltype(_impl_.should_delay_archiving_){false}
    , decltype(_impl_.store_outside_object_archive_){false}
    , decltype(_impl_.estimated_byte_size_){uint64_t{0u}}
    , decltype(_impl_.max_segment_cost_){uint64_t{0u}}
  };
}

LargeArray::~LargeArray() {
  // @@protoc_insertion_point(destructor:TSP.LargeArray)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LargeArray::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ranges_.~RepeatedPtrField();
  _impl_.segments_.~RepeatedPtrField();
}

void LargeArray::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LargeArray::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.LargeArray)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ranges_.Clear();
  _impl_.segments_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.max_segment_element_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.max_segment_cost_) -
        reinterpret_cast<char*>(&_impl_.max_segment_element_count_)) + sizeof(_impl_.max_segment_cost_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LargeArray::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSP.Range ranges = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ranges(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference segments = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_segments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 max_segment_element_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_max_segment_element_count(&has_bits);
          _impl_.max_segment_element_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 max_segment_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_max_segment_size(&has_bits);
          _impl_.max_segment_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool should_delay_archiving = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_should_delay_archiving(&has_bits);
          _impl_.should_delay_archiving_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 delayed_archiving_priority = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_delayed_archiving_priority(&has_bits);
          _impl_.delayed_archiving_priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool store_outside_object_archive = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_store_outside_object_archive(&has_bits);
          _impl_.store_outside_object_archive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 estimated_byte_size = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_estimated_byte_size(&has_bits);
          _impl_.estimated_byte_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 max_segment_cost = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_max_segment_cost(&has_bits);
          _impl_.max_segment_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LargeArray::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.LargeArray)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSP.Range ranges = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ranges_size()); i < n; i++) {
    const auto& repfield = this->_internal_ranges(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference segments = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_segments_size()); i < n; i++) {
    const auto& repfield = this->_internal_segments(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 max_segment_element_count = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_max_segment_element_count(), target);
  }

  // optional uint64 max_segment_size = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_max_segment_size(), target);
  }

  // optional bool should_delay_archiving = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_should_delay_archiving(), target);
  }

  // optional uint32 delayed_archiving_priority = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_delayed_archiving_priority(), target);
  }

  // optional bool store_outside_object_archive = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_store_outside_object_archive(), target);
  }

  // optional uint64 estimated_byte_size = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_estimated_byte_size(), target);
  }

  // optional uint64 max_segment_cost = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_max_segment_cost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.LargeArray)
  return target;
}

size_t LargeArray::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.LargeArray)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Range ranges = 1;
  total_size += 1UL * this->_internal_ranges_size();
  for (const auto& msg : this->_impl_.ranges_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference segments = 2;
  total_size += 1UL * this->_internal_segments_size();
  for (const auto& msg : this->_impl_.segments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 max_segment_element_count = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_max_segment_element_count());
    }

    // optional uint64 max_segment_size = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_max_segment_size());
    }

    // optional uint32 delayed_archiving_priority = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_delayed_archiving_priority());
    }

    // optional bool should_delay_archiving = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool store_outside_object_archive = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional uint64 estimated_byte_size = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_estimated_byte_size());
    }

    // optional uint64 max_segment_cost = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_max_segment_cost());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LargeArray::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LargeArray::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LargeArray::GetClassData() const { return &_class_data_; }


void LargeArray::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LargeArray*>(&to_msg);
  auto& from = static_cast<const LargeArray&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.LargeArray)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ranges_.MergeFrom(from._impl_.ranges_);
  _this->_impl_.segments_.MergeFrom(from._impl_.segments_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.max_segment_element_count_ = from._impl_.max_segment_element_count_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.max_segment_size_ = from._impl_.max_segment_size_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.delayed_archiving_priority_ = from._impl_.delayed_archiving_priority_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.should_delay_archiving_ = from._impl_.should_delay_archiving_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.store_outside_object_archive_ = from._impl_.store_outside_object_archive_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.estimated_byte_size_ = from._impl_.estimated_byte_size_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.max_segment_cost_ = from._impl_.max_segment_cost_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LargeArray::CopyFrom(const LargeArray& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.LargeArray)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LargeArray::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.ranges_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.segments_))
    return false;
  return true;
}

void LargeArray::InternalSwap(LargeArray* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.ranges_.InternalSwap(&other->_impl_.ranges_);
  _impl_.segments_.InternalSwap(&other->_impl_.segments_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LargeArray, _impl_.max_segment_cost_)
      + sizeof(LargeArray::_impl_.max_segment_cost_)
      - PROTOBUF_FIELD_OFFSET(LargeArray, _impl_.max_segment_element_count_)>(
          reinterpret_cast<char*>(&_impl_.max_segment_element_count_),
          reinterpret_cast<char*>(&other->_impl_.max_segment_element_count_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LargeArray::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[37]);
}

// ===================================================================

class LargeNumberArray::_Internal {
 public:
  using HasBits = decltype(std::declval<LargeNumberArray>()._impl_._has_bits_);
  static const ::TSP::LargeArray& large_array(const LargeNumberArray* msg);
  static void set_has_large_array(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::LargeArray&
LargeNumberArray::_Internal::large_array(const LargeNumberArray* msg) {
  return *msg->_impl_.large_array_;
}
LargeNumberArray::LargeNumberArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.LargeNumberArray)
}
LargeNumberArray::LargeNumberArray(const LargeNumberArray& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LargeNumberArray* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.large_array_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_large_array()) {
    _this->_impl_.large_array_ = new ::TSP::LargeArray(*from._impl_.large_array_);
  }
  // @@protoc_insertion_point(copy_constructor:TSP.LargeNumberArray)
}

inline void LargeNumberArray::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.large_array_){nullptr}
  };
}

LargeNumberArray::~LargeNumberArray() {
  // @@protoc_insertion_point(destructor:TSP.LargeNumberArray)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LargeNumberArray::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.large_array_;
}

void LargeNumberArray::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LargeNumberArray::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.LargeNumberArray)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.large_array_ != nullptr);
    _impl_.large_array_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LargeNumberArray::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.LargeArray large_array = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_large_array(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LargeNumberArray::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.LargeNumberArray)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.LargeArray large_array = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::large_array(this),
        _Internal::large_array(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.LargeNumberArray)
  return target;
}

size_t LargeNumberArray::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.LargeNumberArray)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.LargeArray large_array = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.large_array_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LargeNumberArray::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LargeNumberArray::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LargeNumberArray::GetClassData() const { return &_class_data_; }


void LargeNumberArray::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LargeNumberArray*>(&to_msg);
  auto& from = static_cast<const LargeNumberArray&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.LargeNumberArray)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_large_array()) {
    _this->_internal_mutable_large_array()->::TSP::LargeArray::MergeFrom(
        from._internal_large_array());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LargeNumberArray::CopyFrom(const LargeNumberArray& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.LargeNumberArray)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LargeNumberArray::IsInitialized() const {
  if (_internal_has_large_array()) {
    if (!_impl_.large_array_->IsInitialized()) return false;
  }
  return true;
}

void LargeNumberArray::InternalSwap(LargeNumberArray* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.large_array_, other->_impl_.large_array_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LargeNumberArray::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[38]);
}

// ===================================================================

class LargeStringArray::_Internal {
 public:
  using HasBits = decltype(std::declval<LargeStringArray>()._impl_._has_bits_);
  static const ::TSP::LargeArray& large_array(const LargeStringArray* msg);
  static void set_has_large_array(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::LargeArray&
LargeStringArray::_Internal::large_array(const LargeStringArray* msg) {
  return *msg->_impl_.large_array_;
}
LargeStringArray::LargeStringArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.LargeStringArray)
}
LargeStringArray::LargeStringArray(const LargeStringArray& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LargeStringArray* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.large_array_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_large_array()) {
    _this->_impl_.large_array_ = new ::TSP::LargeArray(*from._impl_.large_array_);
  }
  // @@protoc_insertion_point(copy_constructor:TSP.LargeStringArray)
}

inline void LargeStringArray::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.large_array_){nullptr}
  };
}

LargeStringArray::~LargeStringArray() {
  // @@protoc_insertion_point(destructor:TSP.LargeStringArray)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LargeStringArray::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.large_array_;
}

void LargeStringArray::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LargeStringArray::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.LargeStringArray)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.large_array_ != nullptr);
    _impl_.large_array_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LargeStringArray::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.LargeArray large_array = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_large_array(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LargeStringArray::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.LargeStringArray)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.LargeArray large_array = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::large_array(this),
        _Internal::large_array(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.LargeStringArray)
  return target;
}

size_t LargeStringArray::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.LargeStringArray)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.LargeArray large_array = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.large_array_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LargeStringArray::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LargeStringArray::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LargeStringArray::GetClassData() const { return &_class_data_; }


void LargeStringArray::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LargeStringArray*>(&to_msg);
  auto& from = static_cast<const LargeStringArray&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.LargeStringArray)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_large_array()) {
    _this->_internal_mutable_large_array()->::TSP::LargeArray::MergeFrom(
        from._internal_large_array());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LargeStringArray::CopyFrom(const LargeStringArray& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.LargeStringArray)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LargeStringArray::IsInitialized() const {
  if (_internal_has_large_array()) {
    if (!_impl_.large_array_->IsInitialized()) return false;
  }
  return true;
}

void LargeStringArray::InternalSwap(LargeStringArray* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.large_array_, other->_impl_.large_array_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LargeStringArray::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[39]);
}

// ===================================================================

class LargeLazyObjectArray::_Internal {
 public:
  using HasBits = decltype(std::declval<LargeLazyObjectArray>()._impl_._has_bits_);
  static const ::TSP::LargeArray& large_array(const LargeLazyObjectArray* msg);
  static void set_has_large_array(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::LargeArray&
LargeLazyObjectArray::_Internal::large_array(const LargeLazyObjectArray* msg) {
  return *msg->_impl_.large_array_;
}
LargeLazyObjectArray::LargeLazyObjectArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.LargeLazyObjectArray)
}
LargeLazyObjectArray::LargeLazyObjectArray(const LargeLazyObjectArray& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LargeLazyObjectArray* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.large_array_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_large_array()) {
    _this->_impl_.large_array_ = new ::TSP::LargeArray(*from._impl_.large_array_);
  }
  // @@protoc_insertion_point(copy_constructor:TSP.LargeLazyObjectArray)
}

inline void LargeLazyObjectArray::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.large_array_){nullptr}
  };
}

LargeLazyObjectArray::~LargeLazyObjectArray() {
  // @@protoc_insertion_point(destructor:TSP.LargeLazyObjectArray)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LargeLazyObjectArray::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.large_array_;
}

void LargeLazyObjectArray::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LargeLazyObjectArray::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.LargeLazyObjectArray)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.large_array_ != nullptr);
    _impl_.large_array_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LargeLazyObjectArray::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.LargeArray large_array = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_large_array(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LargeLazyObjectArray::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.LargeLazyObjectArray)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.LargeArray large_array = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::large_array(this),
        _Internal::large_array(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.LargeLazyObjectArray)
  return target;
}

size_t LargeLazyObjectArray::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.LargeLazyObjectArray)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.LargeArray large_array = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.large_array_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LargeLazyObjectArray::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LargeLazyObjectArray::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LargeLazyObjectArray::GetClassData() const { return &_class_data_; }


void LargeLazyObjectArray::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LargeLazyObjectArray*>(&to_msg);
  auto& from = static_cast<const LargeLazyObjectArray&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.LargeLazyObjectArray)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_large_array()) {
    _this->_internal_mutable_large_array()->::TSP::LargeArray::MergeFrom(
        from._internal_large_array());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LargeLazyObjectArray::CopyFrom(const LargeLazyObjectArray& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.LargeLazyObjectArray)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LargeLazyObjectArray::IsInitialized() const {
  if (_internal_has_large_array()) {
    if (!_impl_.large_array_->IsInitialized()) return false;
  }
  return true;
}

void LargeLazyObjectArray::InternalSwap(LargeLazyObjectArray* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.large_array_, other->_impl_.large_array_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LargeLazyObjectArray::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[40]);
}

// ===================================================================

class LargeObjectArray::_Internal {
 public:
  using HasBits = decltype(std::declval<LargeObjectArray>()._impl_._has_bits_);
  static const ::TSP::LargeArray& large_array(const LargeObjectArray* msg);
  static void set_has_large_array(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::LargeArray&
LargeObjectArray::_Internal::large_array(const LargeObjectArray* msg) {
  return *msg->_impl_.large_array_;
}
LargeObjectArray::LargeObjectArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.LargeObjectArray)
}
LargeObjectArray::LargeObjectArray(const LargeObjectArray& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LargeObjectArray* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.large_array_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_large_array()) {
    _this->_impl_.large_array_ = new ::TSP::LargeArray(*from._impl_.large_array_);
  }
  // @@protoc_insertion_point(copy_constructor:TSP.LargeObjectArray)
}

inline void LargeObjectArray::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.large_array_){nullptr}
  };
}

LargeObjectArray::~LargeObjectArray() {
  // @@protoc_insertion_point(destructor:TSP.LargeObjectArray)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LargeObjectArray::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.large_array_;
}

void LargeObjectArray::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LargeObjectArray::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.LargeObjectArray)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.large_array_ != nullptr);
    _impl_.large_array_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LargeObjectArray::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.LargeArray large_array = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_large_array(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LargeObjectArray::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.LargeObjectArray)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.LargeArray large_array = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::large_array(this),
        _Internal::large_array(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.LargeObjectArray)
  return target;
}

size_t LargeObjectArray::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.LargeObjectArray)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.LargeArray large_array = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.large_array_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LargeObjectArray::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LargeObjectArray::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LargeObjectArray::GetClassData() const { return &_class_data_; }


void LargeObjectArray::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LargeObjectArray*>(&to_msg);
  auto& from = static_cast<const LargeObjectArray&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.LargeObjectArray)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_large_array()) {
    _this->_internal_mutable_large_array()->::TSP::LargeArray::MergeFrom(
        from._internal_large_array());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LargeObjectArray::CopyFrom(const LargeObjectArray& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.LargeObjectArray)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LargeObjectArray::IsInitialized() const {
  if (_internal_has_large_array()) {
    if (!_impl_.large_array_->IsInitialized()) return false;
  }
  return true;
}

void LargeObjectArray::InternalSwap(LargeObjectArray* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.large_array_, other->_impl_.large_array_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LargeObjectArray::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[41]);
}

// ===================================================================

class LargeUUIDArray::_Internal {
 public:
  using HasBits = decltype(std::declval<LargeUUIDArray>()._impl_._has_bits_);
  static const ::TSP::LargeArray& large_array(const LargeUUIDArray* msg);
  static void set_has_large_array(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::LargeArray&
LargeUUIDArray::_Internal::large_array(const LargeUUIDArray* msg) {
  return *msg->_impl_.large_array_;
}
LargeUUIDArray::LargeUUIDArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSP.LargeUUIDArray)
}
LargeUUIDArray::LargeUUIDArray(const LargeUUIDArray& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LargeUUIDArray* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.large_array_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_large_array()) {
    _this->_impl_.large_array_ = new ::TSP::LargeArray(*from._impl_.large_array_);
  }
  // @@protoc_insertion_point(copy_constructor:TSP.LargeUUIDArray)
}

inline void LargeUUIDArray::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.large_array_){nullptr}
  };
}

LargeUUIDArray::~LargeUUIDArray() {
  // @@protoc_insertion_point(destructor:TSP.LargeUUIDArray)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LargeUUIDArray::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.large_array_;
}

void LargeUUIDArray::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LargeUUIDArray::Clear() {
// @@protoc_insertion_point(message_clear_start:TSP.LargeUUIDArray)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.large_array_ != nullptr);
    _impl_.large_array_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LargeUUIDArray::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.LargeArray large_array = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_large_array(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LargeUUIDArray::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSP.LargeUUIDArray)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.LargeArray large_array = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::large_array(this),
        _Internal::large_array(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSP.LargeUUIDArray)
  return target;
}

size_t LargeUUIDArray::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSP.LargeUUIDArray)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.LargeArray large_array = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.large_array_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LargeUUIDArray::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LargeUUIDArray::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LargeUUIDArray::GetClassData() const { return &_class_data_; }


void LargeUUIDArray::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LargeUUIDArray*>(&to_msg);
  auto& from = static_cast<const LargeUUIDArray&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSP.LargeUUIDArray)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_large_array()) {
    _this->_internal_mutable_large_array()->::TSP::LargeArray::MergeFrom(
        from._internal_large_array());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LargeUUIDArray::CopyFrom(const LargeUUIDArray& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSP.LargeUUIDArray)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LargeUUIDArray::IsInitialized() const {
  if (_internal_has_large_array()) {
    if (!_impl_.large_array_->IsInitialized()) return false;
  }
  return true;
}

void LargeUUIDArray::InternalSwap(LargeUUIDArray* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.large_array_, other->_impl_.large_array_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LargeUUIDArray::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSPMessages_2eproto_getter, &descriptor_table_TSPMessages_2eproto_once,
      file_level_metadata_TSPMessages_2eproto[42]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace TSP
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::TSP::Reference*
Arena::CreateMaybeMessage< ::TSP::Reference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::Reference >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::DataReference*
Arena::CreateMaybeMessage< ::TSP::DataReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::DataReference >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::SparseReferenceArray_Entry*
Arena::CreateMaybeMessage< ::TSP::SparseReferenceArray_Entry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::SparseReferenceArray_Entry >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::SparseReferenceArray*
Arena::CreateMaybeMessage< ::TSP::SparseReferenceArray >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::SparseReferenceArray >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::Point*
Arena::CreateMaybeMessage< ::TSP::Point >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::Point >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::Size*
Arena::CreateMaybeMessage< ::TSP::Size >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::Size >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::Range*
Arena::CreateMaybeMessage< ::TSP::Range >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::Range >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::Date*
Arena::CreateMaybeMessage< ::TSP::Date >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::Date >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::IndexSet*
Arena::CreateMaybeMessage< ::TSP::IndexSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::IndexSet >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::Color*
Arena::CreateMaybeMessage< ::TSP::Color >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::Color >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::Path_Element*
Arena::CreateMaybeMessage< ::TSP::Path_Element >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::Path_Element >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::Path*
Arena::CreateMaybeMessage< ::TSP::Path >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::Path >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::ReferenceDictionary_Entry*
Arena::CreateMaybeMessage< ::TSP::ReferenceDictionary_Entry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::ReferenceDictionary_Entry >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::ReferenceDictionary*
Arena::CreateMaybeMessage< ::TSP::ReferenceDictionary >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::ReferenceDictionary >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::UUID*
Arena::CreateMaybeMessage< ::TSP::UUID >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::UUID >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::CFUUIDArchive*
Arena::CreateMaybeMessage< ::TSP::CFUUIDArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::CFUUIDArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::UUIDSetArchive*
Arena::CreateMaybeMessage< ::TSP::UUIDSetArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::UUIDSetArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::UUIDMapArchive*
Arena::CreateMaybeMessage< ::TSP::UUIDMapArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::UUIDMapArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::UUIDMultiMapArchive*
Arena::CreateMaybeMessage< ::TSP::UUIDMultiMapArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::UUIDMultiMapArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::UUIDCoordArchive*
Arena::CreateMaybeMessage< ::TSP::UUIDCoordArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::UUIDCoordArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::UUIDRectArchive*
Arena::CreateMaybeMessage< ::TSP::UUIDRectArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::UUIDRectArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::SparseUUIDArray_Entry*
Arena::CreateMaybeMessage< ::TSP::SparseUUIDArray_Entry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::SparseUUIDArray_Entry >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::SparseUUIDArray*
Arena::CreateMaybeMessage< ::TSP::SparseUUIDArray >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::SparseUUIDArray >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::UUIDPath*
Arena::CreateMaybeMessage< ::TSP::UUIDPath >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::UUIDPath >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::SparseUUIDPathArray_Entry*
Arena::CreateMaybeMessage< ::TSP::SparseUUIDPathArray_Entry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::SparseUUIDPathArray_Entry >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::SparseUUIDPathArray*
Arena::CreateMaybeMessage< ::TSP::SparseUUIDPathArray >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::SparseUUIDPathArray >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::PasteboardObject*
Arena::CreateMaybeMessage< ::TSP::PasteboardObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::PasteboardObject >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::ObjectCollection*
Arena::CreateMaybeMessage< ::TSP::ObjectCollection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::ObjectCollection >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::ObjectContainer*
Arena::CreateMaybeMessage< ::TSP::ObjectContainer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::ObjectContainer >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::DataAttributes*
Arena::CreateMaybeMessage< ::TSP::DataAttributes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::DataAttributes >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::LargeArraySegment*
Arena::CreateMaybeMessage< ::TSP::LargeArraySegment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::LargeArraySegment >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::LargeNumberArraySegment*
Arena::CreateMaybeMessage< ::TSP::LargeNumberArraySegment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::LargeNumberArraySegment >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::LargeStringArraySegment_OptionalElement*
Arena::CreateMaybeMessage< ::TSP::LargeStringArraySegment_OptionalElement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::LargeStringArraySegment_OptionalElement >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::LargeStringArraySegment*
Arena::CreateMaybeMessage< ::TSP::LargeStringArraySegment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::LargeStringArraySegment >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::LargeUUIDArraySegment*
Arena::CreateMaybeMessage< ::TSP::LargeUUIDArraySegment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::LargeUUIDArraySegment >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::LargeLazyObjectArraySegment*
Arena::CreateMaybeMessage< ::TSP::LargeLazyObjectArraySegment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::LargeLazyObjectArraySegment >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::LargeObjectArraySegment*
Arena::CreateMaybeMessage< ::TSP::LargeObjectArraySegment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::LargeObjectArraySegment >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::LargeArray*
Arena::CreateMaybeMessage< ::TSP::LargeArray >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::LargeArray >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::LargeNumberArray*
Arena::CreateMaybeMessage< ::TSP::LargeNumberArray >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::LargeNumberArray >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::LargeStringArray*
Arena::CreateMaybeMessage< ::TSP::LargeStringArray >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::LargeStringArray >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::LargeLazyObjectArray*
Arena::CreateMaybeMessage< ::TSP::LargeLazyObjectArray >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::LargeLazyObjectArray >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::LargeObjectArray*
Arena::CreateMaybeMessage< ::TSP::LargeObjectArray >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::LargeObjectArray >(arena);
}
template<> PROTOBUF_NOINLINE ::TSP::LargeUUIDArray*
Arena::CreateMaybeMessage< ::TSP::LargeUUIDArray >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSP::LargeUUIDArray >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
