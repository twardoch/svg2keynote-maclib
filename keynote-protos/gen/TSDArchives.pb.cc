// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSDArchives.proto

#include "TSDArchives.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace TSD {
PROTOBUF_CONSTEXPR EdgeInsetsArchive::EdgeInsetsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.top_)*/0
  , /*decltype(_impl_.left_)*/0
  , /*decltype(_impl_.bottom_)*/0
  , /*decltype(_impl_.right_)*/0} {}
struct EdgeInsetsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EdgeInsetsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EdgeInsetsArchiveDefaultTypeInternal() {}
  union {
    EdgeInsetsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EdgeInsetsArchiveDefaultTypeInternal _EdgeInsetsArchive_default_instance_;
PROTOBUF_CONSTEXPR GeometryArchive::GeometryArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.size_)*/nullptr
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.angle_)*/0} {}
struct GeometryArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GeometryArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GeometryArchiveDefaultTypeInternal() {}
  union {
    GeometryArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeometryArchiveDefaultTypeInternal _GeometryArchive_default_instance_;
PROTOBUF_CONSTEXPR PointPathSourceArchive::PointPathSourceArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.point_)*/nullptr
  , /*decltype(_impl_.naturalsize_)*/nullptr
  , /*decltype(_impl_.type_)*/0} {}
struct PointPathSourceArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointPathSourceArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointPathSourceArchiveDefaultTypeInternal() {}
  union {
    PointPathSourceArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointPathSourceArchiveDefaultTypeInternal _PointPathSourceArchive_default_instance_;
PROTOBUF_CONSTEXPR ScalarPathSourceArchive::ScalarPathSourceArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.naturalsize_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.scalar_)*/0
  , /*decltype(_impl_.is_curve_continuous_)*/false} {}
struct ScalarPathSourceArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScalarPathSourceArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScalarPathSourceArchiveDefaultTypeInternal() {}
  union {
    ScalarPathSourceArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScalarPathSourceArchiveDefaultTypeInternal _ScalarPathSourceArchive_default_instance_;
PROTOBUF_CONSTEXPR BezierPathSourceArchive::BezierPathSourceArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.naturalsize_)*/nullptr
  , /*decltype(_impl_.path_)*/nullptr} {}
struct BezierPathSourceArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BezierPathSourceArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BezierPathSourceArchiveDefaultTypeInternal() {}
  union {
    BezierPathSourceArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BezierPathSourceArchiveDefaultTypeInternal _BezierPathSourceArchive_default_instance_;
PROTOBUF_CONSTEXPR CalloutPathSourceArchive::CalloutPathSourceArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.natural_size_)*/nullptr
  , /*decltype(_impl_.tail_position_)*/nullptr
  , /*decltype(_impl_.tail_size_)*/0
  , /*decltype(_impl_.corner_radius_)*/0
  , /*decltype(_impl_.center_tail_)*/false} {}
struct CalloutPathSourceArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CalloutPathSourceArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CalloutPathSourceArchiveDefaultTypeInternal() {}
  union {
    CalloutPathSourceArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CalloutPathSourceArchiveDefaultTypeInternal _CalloutPathSourceArchive_default_instance_;
PROTOBUF_CONSTEXPR ConnectionLinePathSourceArchive::ConnectionLinePathSourceArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.outset_from_)*/0
  , /*decltype(_impl_.outset_to_)*/0} {}
struct ConnectionLinePathSourceArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionLinePathSourceArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionLinePathSourceArchiveDefaultTypeInternal() {}
  union {
    ConnectionLinePathSourceArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionLinePathSourceArchiveDefaultTypeInternal _ConnectionLinePathSourceArchive_default_instance_;
PROTOBUF_CONSTEXPR EditableBezierPathSourceArchive_Node::EditableBezierPathSourceArchive_Node(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.incontrolpoint_)*/nullptr
  , /*decltype(_impl_.nodepoint_)*/nullptr
  , /*decltype(_impl_.outcontrolpoint_)*/nullptr
  , /*decltype(_impl_.type_)*/1} {}
struct EditableBezierPathSourceArchive_NodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EditableBezierPathSourceArchive_NodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EditableBezierPathSourceArchive_NodeDefaultTypeInternal() {}
  union {
    EditableBezierPathSourceArchive_Node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EditableBezierPathSourceArchive_NodeDefaultTypeInternal _EditableBezierPathSourceArchive_Node_default_instance_;
PROTOBUF_CONSTEXPR EditableBezierPathSourceArchive_Subpath::EditableBezierPathSourceArchive_Subpath(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.nodes_)*/{}
  , /*decltype(_impl_.closed_)*/false} {}
struct EditableBezierPathSourceArchive_SubpathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EditableBezierPathSourceArchive_SubpathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EditableBezierPathSourceArchive_SubpathDefaultTypeInternal() {}
  union {
    EditableBezierPathSourceArchive_Subpath _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EditableBezierPathSourceArchive_SubpathDefaultTypeInternal _EditableBezierPathSourceArchive_Subpath_default_instance_;
PROTOBUF_CONSTEXPR EditableBezierPathSourceArchive::EditableBezierPathSourceArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subpaths_)*/{}
  , /*decltype(_impl_.naturalsize_)*/nullptr} {}
struct EditableBezierPathSourceArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EditableBezierPathSourceArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EditableBezierPathSourceArchiveDefaultTypeInternal() {}
  union {
    EditableBezierPathSourceArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EditableBezierPathSourceArchiveDefaultTypeInternal _EditableBezierPathSourceArchive_default_instance_;
PROTOBUF_CONSTEXPR PathSourceArchive::PathSourceArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.localizationkey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.userdefinedname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.point_path_source_)*/nullptr
  , /*decltype(_impl_.scalar_path_source_)*/nullptr
  , /*decltype(_impl_.bezier_path_source_)*/nullptr
  , /*decltype(_impl_.callout_path_source_)*/nullptr
  , /*decltype(_impl_.connection_line_path_source_)*/nullptr
  , /*decltype(_impl_.editable_bezier_path_source_)*/nullptr
  , /*decltype(_impl_.horizontalflip_)*/false
  , /*decltype(_impl_.verticalflip_)*/false} {}
struct PathSourceArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PathSourceArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PathSourceArchiveDefaultTypeInternal() {}
  union {
    PathSourceArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PathSourceArchiveDefaultTypeInternal _PathSourceArchive_default_instance_;
PROTOBUF_CONSTEXPR AngleGradientArchive::AngleGradientArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gradientangle_)*/0} {}
struct AngleGradientArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AngleGradientArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AngleGradientArchiveDefaultTypeInternal() {}
  union {
    AngleGradientArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AngleGradientArchiveDefaultTypeInternal _AngleGradientArchive_default_instance_;
PROTOBUF_CONSTEXPR TransformGradientArchive::TransformGradientArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.start_)*/nullptr
  , /*decltype(_impl_.end_)*/nullptr
  , /*decltype(_impl_.basenaturalsize_)*/nullptr} {}
struct TransformGradientArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransformGradientArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransformGradientArchiveDefaultTypeInternal() {}
  union {
    TransformGradientArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransformGradientArchiveDefaultTypeInternal _TransformGradientArchive_default_instance_;
PROTOBUF_CONSTEXPR GradientArchive_GradientStop::GradientArchive_GradientStop(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/nullptr
  , /*decltype(_impl_.fraction_)*/0
  , /*decltype(_impl_.inflection_)*/0} {}
struct GradientArchive_GradientStopDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GradientArchive_GradientStopDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GradientArchive_GradientStopDefaultTypeInternal() {}
  union {
    GradientArchive_GradientStop _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GradientArchive_GradientStopDefaultTypeInternal _GradientArchive_GradientStop_default_instance_;
PROTOBUF_CONSTEXPR GradientArchive::GradientArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stops_)*/{}
  , /*decltype(_impl_.anglegradient_)*/nullptr
  , /*decltype(_impl_.transformgradient_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.opacity_)*/0
  , /*decltype(_impl_.advancedgradient_)*/false} {}
struct GradientArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GradientArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GradientArchiveDefaultTypeInternal() {}
  union {
    GradientArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GradientArchiveDefaultTypeInternal _GradientArchive_default_instance_;
PROTOBUF_CONSTEXPR ImageFillArchive::ImageFillArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.database_imagedata_)*/nullptr
  , /*decltype(_impl_.tint_)*/nullptr
  , /*decltype(_impl_.fillsize_)*/nullptr
  , /*decltype(_impl_.database_originalimagedata_)*/nullptr
  , /*decltype(_impl_.imagedata_)*/nullptr
  , /*decltype(_impl_.originalimagedata_)*/nullptr
  , /*decltype(_impl_.referencecolor_)*/nullptr
  , /*decltype(_impl_.technique_)*/0
  , /*decltype(_impl_.interpretsuntaggedimagedataasgeneric_)*/false} {}
struct ImageFillArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageFillArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageFillArchiveDefaultTypeInternal() {}
  union {
    ImageFillArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageFillArchiveDefaultTypeInternal _ImageFillArchive_default_instance_;
PROTOBUF_CONSTEXPR FillArchive::FillArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/nullptr
  , /*decltype(_impl_.gradient_)*/nullptr
  , /*decltype(_impl_.image_)*/nullptr} {}
struct FillArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FillArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FillArchiveDefaultTypeInternal() {}
  union {
    FillArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FillArchiveDefaultTypeInternal _FillArchive_default_instance_;
PROTOBUF_CONSTEXPR StrokePatternArchive::StrokePatternArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pattern_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.phase_)*/0
  , /*decltype(_impl_.count_)*/0u} {}
struct StrokePatternArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StrokePatternArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StrokePatternArchiveDefaultTypeInternal() {}
  union {
    StrokePatternArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StrokePatternArchiveDefaultTypeInternal _StrokePatternArchive_default_instance_;
PROTOBUF_CONSTEXPR StrokeArchive::StrokeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/nullptr
  , /*decltype(_impl_.pattern_)*/nullptr
  , /*decltype(_impl_.smart_stroke_)*/nullptr
  , /*decltype(_impl_.frame_)*/nullptr
  , /*decltype(_impl_.patterned_stroke_)*/nullptr
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.cap_)*/0
  , /*decltype(_impl_.join_)*/0
  , /*decltype(_impl_.miter_limit_)*/0} {}
struct StrokeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StrokeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StrokeArchiveDefaultTypeInternal() {}
  union {
    StrokeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StrokeArchiveDefaultTypeInternal _StrokeArchive_default_instance_;
PROTOBUF_CONSTEXPR SmartStrokeArchive::SmartStrokeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stroke_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.parametervalues_)*/nullptr
  , /*decltype(_impl_.pattern_offset_distance_)*/0
  , /*decltype(_impl_.random_seed_)*/0u} {}
struct SmartStrokeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SmartStrokeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SmartStrokeArchiveDefaultTypeInternal() {}
  union {
    SmartStrokeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SmartStrokeArchiveDefaultTypeInternal _SmartStrokeArchive_default_instance_;
PROTOBUF_CONSTEXPR FrameArchive::FrameArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.framename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.assetscale_)*/0} {}
struct FrameArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameArchiveDefaultTypeInternal() {}
  union {
    FrameArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameArchiveDefaultTypeInternal _FrameArchive_default_instance_;
PROTOBUF_CONSTEXPR PatternedStrokeArchive::PatternedStrokeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pattern_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PatternedStrokeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PatternedStrokeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PatternedStrokeArchiveDefaultTypeInternal() {}
  union {
    PatternedStrokeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PatternedStrokeArchiveDefaultTypeInternal _PatternedStrokeArchive_default_instance_;
PROTOBUF_CONSTEXPR LineEndArchive::LineEndArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.identifier_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.path_)*/nullptr
  , /*decltype(_impl_.end_point_)*/nullptr
  , /*decltype(_impl_.line_join_)*/0
  , /*decltype(_impl_.is_filled_)*/false} {}
struct LineEndArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LineEndArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LineEndArchiveDefaultTypeInternal() {}
  union {
    LineEndArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LineEndArchiveDefaultTypeInternal _LineEndArchive_default_instance_;
PROTOBUF_CONSTEXPR ShadowArchive::ShadowArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/nullptr
  , /*decltype(_impl_.dropshadow_)*/nullptr
  , /*decltype(_impl_.contactshadow_)*/nullptr
  , /*decltype(_impl_.curvedshadow_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.is_enabled_)*/true
  , /*decltype(_impl_.angle_)*/315
  , /*decltype(_impl_.offset_)*/5
  , /*decltype(_impl_.radius_)*/1
  , /*decltype(_impl_.opacity_)*/1} {}
struct ShadowArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShadowArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShadowArchiveDefaultTypeInternal() {}
  union {
    ShadowArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShadowArchiveDefaultTypeInternal _ShadowArchive_default_instance_;
PROTOBUF_CONSTEXPR DropShadowArchive::DropShadowArchive(
    ::_pbi::ConstantInitialized) {}
struct DropShadowArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DropShadowArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DropShadowArchiveDefaultTypeInternal() {}
  union {
    DropShadowArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DropShadowArchiveDefaultTypeInternal _DropShadowArchive_default_instance_;
PROTOBUF_CONSTEXPR ContactShadowArchive::ContactShadowArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.offset_)*/0
  , /*decltype(_impl_.height_)*/0.2f} {}
struct ContactShadowArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContactShadowArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContactShadowArchiveDefaultTypeInternal() {}
  union {
    ContactShadowArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContactShadowArchiveDefaultTypeInternal _ContactShadowArchive_default_instance_;
PROTOBUF_CONSTEXPR CurvedShadowArchive::CurvedShadowArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.curve_)*/0.6f} {}
struct CurvedShadowArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CurvedShadowArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CurvedShadowArchiveDefaultTypeInternal() {}
  union {
    CurvedShadowArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CurvedShadowArchiveDefaultTypeInternal _CurvedShadowArchive_default_instance_;
PROTOBUF_CONSTEXPR ReflectionArchive::ReflectionArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.opacity_)*/0.5f} {}
struct ReflectionArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReflectionArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReflectionArchiveDefaultTypeInternal() {}
  union {
    ReflectionArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReflectionArchiveDefaultTypeInternal _ReflectionArchive_default_instance_;
PROTOBUF_CONSTEXPR ImageAdjustmentsArchive::ImageAdjustmentsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.exposure_)*/0
  , /*decltype(_impl_.saturation_)*/0
  , /*decltype(_impl_.contrast_)*/0
  , /*decltype(_impl_.highlights_)*/0
  , /*decltype(_impl_.shadows_)*/0
  , /*decltype(_impl_.sharpness_)*/0
  , /*decltype(_impl_.denoise_)*/0
  , /*decltype(_impl_.temperature_)*/0
  , /*decltype(_impl_.tint_)*/0
  , /*decltype(_impl_.bottom_level_)*/0
  , /*decltype(_impl_.gamma_)*/0
  , /*decltype(_impl_.enhance_)*/false
  , /*decltype(_impl_.represents_sage_adjustments_)*/false
  , /*decltype(_impl_.top_level_)*/1} {}
struct ImageAdjustmentsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageAdjustmentsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageAdjustmentsArchiveDefaultTypeInternal() {}
  union {
    ImageAdjustmentsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageAdjustmentsArchiveDefaultTypeInternal _ImageAdjustmentsArchive_default_instance_;
PROTOBUF_CONSTEXPR ShapeStylePropertiesArchive::ShapeStylePropertiesArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.fill_)*/nullptr
  , /*decltype(_impl_.stroke_)*/nullptr
  , /*decltype(_impl_.shadow_)*/nullptr
  , /*decltype(_impl_.reflection_)*/nullptr
  , /*decltype(_impl_.head_line_end_)*/nullptr
  , /*decltype(_impl_.tail_line_end_)*/nullptr
  , /*decltype(_impl_.opacity_)*/0} {}
struct ShapeStylePropertiesArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeStylePropertiesArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeStylePropertiesArchiveDefaultTypeInternal() {}
  union {
    ShapeStylePropertiesArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeStylePropertiesArchiveDefaultTypeInternal _ShapeStylePropertiesArchive_default_instance_;
PROTOBUF_CONSTEXPR ShapeStyleArchive::ShapeStyleArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.shape_properties_)*/nullptr
  , /*decltype(_impl_.override_count_)*/0u} {}
struct ShapeStyleArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeStyleArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeStyleArchiveDefaultTypeInternal() {}
  union {
    ShapeStyleArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeStyleArchiveDefaultTypeInternal _ShapeStyleArchive_default_instance_;
PROTOBUF_CONSTEXPR MediaStylePropertiesArchive::MediaStylePropertiesArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stroke_)*/nullptr
  , /*decltype(_impl_.shadow_)*/nullptr
  , /*decltype(_impl_.reflection_)*/nullptr
  , /*decltype(_impl_.opacity_)*/0} {}
struct MediaStylePropertiesArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MediaStylePropertiesArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MediaStylePropertiesArchiveDefaultTypeInternal() {}
  union {
    MediaStylePropertiesArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MediaStylePropertiesArchiveDefaultTypeInternal _MediaStylePropertiesArchive_default_instance_;
PROTOBUF_CONSTEXPR MediaStyleArchive::MediaStyleArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.media_properties_)*/nullptr
  , /*decltype(_impl_.override_count_)*/0u} {}
struct MediaStyleArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MediaStyleArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MediaStyleArchiveDefaultTypeInternal() {}
  union {
    MediaStyleArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MediaStyleArchiveDefaultTypeInternal _MediaStyleArchive_default_instance_;
PROTOBUF_CONSTEXPR ThemePresetsArchive::ThemePresetsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.gradient_fill_presets_)*/{}
  , /*decltype(_impl_.image_fill_presets_)*/{}
  , /*decltype(_impl_.shadow_presets_)*/{}
  , /*decltype(_impl_.line_style_presets_)*/{}
  , /*decltype(_impl_.shape_style_presets_)*/{}
  , /*decltype(_impl_.textbox_style_presets_)*/{}
  , /*decltype(_impl_.image_style_presets_)*/{}
  , /*decltype(_impl_.movie_style_presets_)*/{}
  , /*decltype(_impl_.drawing_line_style_presets_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ThemePresetsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThemePresetsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThemePresetsArchiveDefaultTypeInternal() {}
  union {
    ThemePresetsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThemePresetsArchiveDefaultTypeInternal _ThemePresetsArchive_default_instance_;
PROTOBUF_CONSTEXPR ThemeReplaceFillPresetCommandArchive::ThemeReplaceFillPresetCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.theme_)*/nullptr
  , /*decltype(_impl_.fill_)*/nullptr
  , /*decltype(_impl_.old_fill_)*/nullptr
  , /*decltype(_impl_.index_)*/0u} {}
struct ThemeReplaceFillPresetCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThemeReplaceFillPresetCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThemeReplaceFillPresetCommandArchiveDefaultTypeInternal() {}
  union {
    ThemeReplaceFillPresetCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThemeReplaceFillPresetCommandArchiveDefaultTypeInternal _ThemeReplaceFillPresetCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR DrawableArchive::DrawableArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pencil_annotations_)*/{}
  , /*decltype(_impl_.hyperlink_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.accessibility_description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.geometry_)*/nullptr
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.exterior_text_wrap_)*/nullptr
  , /*decltype(_impl_.comment_)*/nullptr
  , /*decltype(_impl_.title_)*/nullptr
  , /*decltype(_impl_.caption_)*/nullptr
  , /*decltype(_impl_.locked_)*/false
  , /*decltype(_impl_.aspect_ratio_locked_)*/false
  , /*decltype(_impl_.title_hidden_)*/false
  , /*decltype(_impl_.caption_hidden_)*/false} {}
struct DrawableArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawableArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawableArchiveDefaultTypeInternal() {}
  union {
    DrawableArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawableArchiveDefaultTypeInternal _DrawableArchive_default_instance_;
PROTOBUF_CONSTEXPR ContainerArchive::ContainerArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.children_)*/{}
  , /*decltype(_impl_.geometry_)*/nullptr
  , /*decltype(_impl_.parent_)*/nullptr} {}
struct ContainerArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainerArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainerArchiveDefaultTypeInternal() {}
  union {
    ContainerArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainerArchiveDefaultTypeInternal _ContainerArchive_default_instance_;
PROTOBUF_CONSTEXPR GroupArchive::GroupArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.children_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.fake_shape_for_empty_group_)*/nullptr} {}
struct GroupArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupArchiveDefaultTypeInternal() {}
  union {
    GroupArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupArchiveDefaultTypeInternal _GroupArchive_default_instance_;
PROTOBUF_CONSTEXPR FreehandDrawingAnimationArchive::FreehandDrawingAnimationArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.duration_)*/0
  , /*decltype(_impl_.should_loop_)*/false} {}
struct FreehandDrawingAnimationArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FreehandDrawingAnimationArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FreehandDrawingAnimationArchiveDefaultTypeInternal() {}
  union {
    FreehandDrawingAnimationArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FreehandDrawingAnimationArchiveDefaultTypeInternal _FreehandDrawingAnimationArchive_default_instance_;
PROTOBUF_CONSTEXPR FreehandDrawingArchive::FreehandDrawingArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.spacer_shape_)*/nullptr
  , /*decltype(_impl_.animation_)*/nullptr
  , /*decltype(_impl_.opacity_)*/0
  , /*decltype(_impl_.last_clamped_scale_)*/0} {}
struct FreehandDrawingArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FreehandDrawingArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FreehandDrawingArchiveDefaultTypeInternal() {}
  union {
    FreehandDrawingArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FreehandDrawingArchiveDefaultTypeInternal _FreehandDrawingArchive_default_instance_;
PROTOBUF_CONSTEXPR ShapeArchive::ShapeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.style_)*/nullptr
  , /*decltype(_impl_.pathsource_)*/nullptr
  , /*decltype(_impl_.head_line_end_)*/nullptr
  , /*decltype(_impl_.tail_line_end_)*/nullptr
  , /*decltype(_impl_.strokepatternoffsetdistance_)*/0} {}
struct ShapeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeArchiveDefaultTypeInternal() {}
  union {
    ShapeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeArchiveDefaultTypeInternal _ShapeArchive_default_instance_;
PROTOBUF_CONSTEXPR ConnectionLineArchive::ConnectionLineArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.connected_from_)*/nullptr
  , /*decltype(_impl_.connected_to_)*/nullptr
  , /*decltype(_impl_.connected_to_uuid_)*/nullptr
  , /*decltype(_impl_.connected_from_uuid_)*/nullptr} {}
struct ConnectionLineArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionLineArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionLineArchiveDefaultTypeInternal() {}
  union {
    ConnectionLineArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionLineArchiveDefaultTypeInternal _ConnectionLineArchive_default_instance_;
PROTOBUF_CONSTEXPR ImageArchive::ImageArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.database_data_)*/nullptr
  , /*decltype(_impl_.style_)*/nullptr
  , /*decltype(_impl_.originalsize_)*/nullptr
  , /*decltype(_impl_.mask_)*/nullptr
  , /*decltype(_impl_.database_thumbnaildata_)*/nullptr
  , /*decltype(_impl_.database_originaldata_)*/nullptr
  , /*decltype(_impl_.naturalsize_)*/nullptr
  , /*decltype(_impl_.instantalphapath_)*/nullptr
  , /*decltype(_impl_.data_)*/nullptr
  , /*decltype(_impl_.thumbnaildata_)*/nullptr
  , /*decltype(_impl_.originaldata_)*/nullptr
  , /*decltype(_impl_.imageadjustments_)*/nullptr
  , /*decltype(_impl_.adjustedimagedata_)*/nullptr
  , /*decltype(_impl_.thumbnailadjustedimagedata_)*/nullptr
  , /*decltype(_impl_.enhancedimagedata_)*/nullptr
  , /*decltype(_impl_.traced_path_)*/nullptr
  , /*decltype(_impl_.attribution_)*/nullptr
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.interpretsuntaggedimagedataasgeneric_)*/false
  , /*decltype(_impl_.should_trace_pdf_content_)*/false
  , /*decltype(_impl_.background_removed_)*/false} {}
struct ImageArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageArchiveDefaultTypeInternal() {}
  union {
    ImageArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageArchiveDefaultTypeInternal _ImageArchive_default_instance_;
PROTOBUF_CONSTEXPR MaskArchive::MaskArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.pathsource_)*/nullptr} {}
struct MaskArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MaskArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MaskArchiveDefaultTypeInternal() {}
  union {
    MaskArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MaskArchiveDefaultTypeInternal _MaskArchive_default_instance_;
PROTOBUF_CONSTEXPR ImageDataAttributes::ImageDataAttributes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pixel_size_)*/nullptr
  , /*decltype(_impl_.image_is_srgb_)*/false
  , /*decltype(_impl_.should_be_interpreted_as_generic_if_untagged_)*/false} {}
struct ImageDataAttributesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageDataAttributesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageDataAttributesDefaultTypeInternal() {}
  union {
    ImageDataAttributes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageDataAttributesDefaultTypeInternal _ImageDataAttributes_default_instance_;
PROTOBUF_CONSTEXPR MovieArchive::MovieArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.movieremoteurl_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.imported_auxiliary_movie_data_original_filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.database_moviedata_)*/nullptr
  , /*decltype(_impl_.database_posterimagedata_)*/nullptr
  , /*decltype(_impl_.database_audioonlyimagedata_)*/nullptr
  , /*decltype(_impl_.moviedata_)*/nullptr
  , /*decltype(_impl_.posterimagedata_)*/nullptr
  , /*decltype(_impl_.audioonlyimagedata_)*/nullptr
  , /*decltype(_impl_.style_)*/nullptr
  , /*decltype(_impl_.originalsize_)*/nullptr
  , /*decltype(_impl_.naturalsize_)*/nullptr
  , /*decltype(_impl_.importedauxiliarymoviedata_)*/nullptr
  , /*decltype(_impl_.attribution_)*/nullptr
  , /*decltype(_impl_.fingerprint_)*/nullptr
  , /*decltype(_impl_.starttime_)*/0
  , /*decltype(_impl_.endtime_)*/0
  , /*decltype(_impl_.postertime_)*/0
  , /*decltype(_impl_.loopoptionasinteger_)*/0u
  , /*decltype(_impl_.volume_)*/0
  , /*decltype(_impl_.playablestate_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.autoplay_)*/false
  , /*decltype(_impl_.audioonly_)*/false
  , /*decltype(_impl_.streaming_)*/false
  , /*decltype(_impl_.nativeaudiorecording_)*/false
  , /*decltype(_impl_.loop_option_)*/0
  , /*decltype(_impl_.playsacrossslides_)*/false
  , /*decltype(_impl_.poster_image_generated_with_alpha_support_)*/false
  , /*decltype(_impl_.is_live_video_)*/false} {}
struct MovieArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MovieArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MovieArchiveDefaultTypeInternal() {}
  union {
    MovieArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MovieArchiveDefaultTypeInternal _MovieArchive_default_instance_;
PROTOBUF_CONSTEXPR ExteriorTextWrapArchive::ExteriorTextWrapArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.direction_)*/0u
  , /*decltype(_impl_.fit_type_)*/0u
  , /*decltype(_impl_.margin_)*/0
  , /*decltype(_impl_.alpha_threshold_)*/0
  , /*decltype(_impl_.is_html_wrap_)*/false} {}
struct ExteriorTextWrapArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExteriorTextWrapArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExteriorTextWrapArchiveDefaultTypeInternal() {}
  union {
    ExteriorTextWrapArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExteriorTextWrapArchiveDefaultTypeInternal _ExteriorTextWrapArchive_default_instance_;
PROTOBUF_CONSTEXPR DrawableContentDescription::DrawableContentDescription(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.element_kind_)*/0u
  , /*decltype(_impl_.is_anchored_to_text_)*/false
  , /*decltype(_impl_.is_floating_above_text_)*/false
  , /*decltype(_impl_.is_inline_with_text_)*/false} {}
struct DrawableContentDescriptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawableContentDescriptionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawableContentDescriptionDefaultTypeInternal() {}
  union {
    DrawableContentDescription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawableContentDescriptionDefaultTypeInternal _DrawableContentDescription_default_instance_;
PROTOBUF_CONSTEXPR FreehandDrawingContentDescription::FreehandDrawingContentDescription(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.source_doc_wanted_spacer_shape_)*/false} {}
struct FreehandDrawingContentDescriptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FreehandDrawingContentDescriptionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FreehandDrawingContentDescriptionDefaultTypeInternal() {}
  union {
    FreehandDrawingContentDescription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FreehandDrawingContentDescriptionDefaultTypeInternal _FreehandDrawingContentDescription_default_instance_;
PROTOBUF_CONSTEXPR FreehandDrawingToolkitUIState::FreehandDrawingToolkitUIState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.current_color_)*/nullptr
  , /*decltype(_impl_.pen_tool_color_)*/nullptr
  , /*decltype(_impl_.pencil_tool_color_)*/nullptr
  , /*decltype(_impl_.crayon_tool_color_)*/nullptr
  , /*decltype(_impl_.fill_tool_color_)*/nullptr
  , /*decltype(_impl_.most_recent_restorable_tool_type_)*/0
  , /*decltype(_impl_.pen_tool_opacity_)*/0
  , /*decltype(_impl_.pen_tool_unscaled_width_)*/0
  , /*decltype(_impl_.pencil_tool_opacity_)*/0
  , /*decltype(_impl_.pencil_tool_unscaled_width_)*/0
  , /*decltype(_impl_.crayon_tool_opacity_)*/0
  , /*decltype(_impl_.crayon_tool_unscaled_width_)*/0
  , /*decltype(_impl_.fill_tool_opacity_)*/0
  , /*decltype(_impl_.eraser_tool_scaled_width_)*/0
  , /*decltype(_impl_.eraser_tool_erases_whole_objects_)*/false} {}
struct FreehandDrawingToolkitUIStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FreehandDrawingToolkitUIStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FreehandDrawingToolkitUIStateDefaultTypeInternal() {}
  union {
    FreehandDrawingToolkitUIState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FreehandDrawingToolkitUIStateDefaultTypeInternal _FreehandDrawingToolkitUIState_default_instance_;
PROTOBUF_CONSTEXPR StandinCaptionArchive::StandinCaptionArchive(
    ::_pbi::ConstantInitialized) {}
struct StandinCaptionArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StandinCaptionArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StandinCaptionArchiveDefaultTypeInternal() {}
  union {
    StandinCaptionArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StandinCaptionArchiveDefaultTypeInternal _StandinCaptionArchive_default_instance_;
PROTOBUF_CONSTEXPR GuideArchive::GuideArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.offset_)*/0
  , /*decltype(_impl_.start_)*/0
  , /*decltype(_impl_.end_)*/0
  , /*decltype(_impl_.dynamic_)*/false
  , /*decltype(_impl_.infinite_)*/false} {}
struct GuideArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GuideArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GuideArchiveDefaultTypeInternal() {}
  union {
    GuideArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GuideArchiveDefaultTypeInternal _GuideArchive_default_instance_;
PROTOBUF_CONSTEXPR UserDefinedGuideArchive::UserDefinedGuideArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.position_)*/0} {}
struct UserDefinedGuideArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserDefinedGuideArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserDefinedGuideArchiveDefaultTypeInternal() {}
  union {
    UserDefinedGuideArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserDefinedGuideArchiveDefaultTypeInternal _UserDefinedGuideArchive_default_instance_;
PROTOBUF_CONSTEXPR GuideStorageArchive::GuideStorageArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.userdefinedguides_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GuideStorageArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GuideStorageArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GuideStorageArchiveDefaultTypeInternal() {}
  union {
    GuideStorageArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GuideStorageArchiveDefaultTypeInternal _GuideStorageArchive_default_instance_;
PROTOBUF_CONSTEXPR CanvasSelectionArchive::CanvasSelectionArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.infos_)*/{}
  , /*decltype(_impl_.non_interactive_infos_)*/{}
  , /*decltype(_impl_.container_)*/nullptr} {}
struct CanvasSelectionArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CanvasSelectionArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CanvasSelectionArchiveDefaultTypeInternal() {}
  union {
    CanvasSelectionArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CanvasSelectionArchiveDefaultTypeInternal _CanvasSelectionArchive_default_instance_;
PROTOBUF_CONSTEXPR DrawableSelectionArchive::DrawableSelectionArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.infos_)*/{}
  , /*decltype(_impl_.non_interactive_infos_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DrawableSelectionArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawableSelectionArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawableSelectionArchiveDefaultTypeInternal() {}
  union {
    DrawableSelectionArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawableSelectionArchiveDefaultTypeInternal _DrawableSelectionArchive_default_instance_;
PROTOBUF_CONSTEXPR GroupSelectionArchive::GroupSelectionArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.has_selected_infos_in_non_group_container_)*/false} {}
struct GroupSelectionArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupSelectionArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupSelectionArchiveDefaultTypeInternal() {}
  union {
    GroupSelectionArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupSelectionArchiveDefaultTypeInternal _GroupSelectionArchive_default_instance_;
PROTOBUF_CONSTEXPR PathSelectionArchive::PathSelectionArchive(
    ::_pbi::ConstantInitialized) {}
struct PathSelectionArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PathSelectionArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PathSelectionArchiveDefaultTypeInternal() {}
  union {
    PathSelectionArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PathSelectionArchiveDefaultTypeInternal _PathSelectionArchive_default_instance_;
PROTOBUF_CONSTEXPR InfoHyperlinkSelectionArchive::InfoHyperlinkSelectionArchive(
    ::_pbi::ConstantInitialized) {}
struct InfoHyperlinkSelectionArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InfoHyperlinkSelectionArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InfoHyperlinkSelectionArchiveDefaultTypeInternal() {}
  union {
    InfoHyperlinkSelectionArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InfoHyperlinkSelectionArchiveDefaultTypeInternal _InfoHyperlinkSelectionArchive_default_instance_;
PROTOBUF_CONSTEXPR CommentStorageArchive::CommentStorageArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.replies_)*/{}
  , /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.creation_date_)*/nullptr
  , /*decltype(_impl_.author_)*/nullptr
  , /*decltype(_impl_.storage_uuid_)*/nullptr} {}
struct CommentStorageArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommentStorageArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommentStorageArchiveDefaultTypeInternal() {}
  union {
    CommentStorageArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommentStorageArchiveDefaultTypeInternal _CommentStorageArchive_default_instance_;
PROTOBUF_CONSTEXPR ReplaceAnnotationAuthorCommandArchive::ReplaceAnnotationAuthorCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.old_annotation_author_)*/nullptr
  , /*decltype(_impl_.new_annotation_author_)*/nullptr} {}
struct ReplaceAnnotationAuthorCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplaceAnnotationAuthorCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplaceAnnotationAuthorCommandArchiveDefaultTypeInternal() {}
  union {
    ReplaceAnnotationAuthorCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplaceAnnotationAuthorCommandArchiveDefaultTypeInternal _ReplaceAnnotationAuthorCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR PencilAnnotationArchive::PencilAnnotationArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pencil_annotation_storage_)*/nullptr} {}
struct PencilAnnotationArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PencilAnnotationArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PencilAnnotationArchiveDefaultTypeInternal() {}
  union {
    PencilAnnotationArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PencilAnnotationArchiveDefaultTypeInternal _PencilAnnotationArchive_default_instance_;
PROTOBUF_CONSTEXPR PencilAnnotationSelectionArchive::PencilAnnotationSelectionArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pencil_annotation_)*/nullptr} {}
struct PencilAnnotationSelectionArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PencilAnnotationSelectionArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PencilAnnotationSelectionArchiveDefaultTypeInternal() {}
  union {
    PencilAnnotationSelectionArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PencilAnnotationSelectionArchiveDefaultTypeInternal _PencilAnnotationSelectionArchive_default_instance_;
PROTOBUF_CONSTEXPR PencilAnnotationStorageArchive::PencilAnnotationStorageArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.callout_sub_storages_)*/{}
  , /*decltype(_impl_.sub_storages_)*/{}
  , /*decltype(_impl_.markup_offset_)*/nullptr
  , /*decltype(_impl_.rasterized_image_)*/nullptr
  , /*decltype(_impl_.legacy_encoded_drawing_)*/nullptr
  , /*decltype(_impl_.drawing_path_)*/nullptr
  , /*decltype(_impl_.strokes_bounding_box_origin_)*/nullptr
  , /*decltype(_impl_.strokes_bounding_box_size_)*/nullptr
  , /*decltype(_impl_.original_attached_size_)*/nullptr
  , /*decltype(_impl_.pen_color_)*/nullptr
  , /*decltype(_impl_.creation_date_)*/nullptr
  , /*decltype(_impl_.encoded_drawing_)*/nullptr
  , /*decltype(_impl_.stroke_points_frame_origin_)*/nullptr
  , /*decltype(_impl_.stroke_points_frame_size_)*/nullptr
  , /*decltype(_impl_.rendered_frame_origin_)*/nullptr
  , /*decltype(_impl_.rendered_frame_size_)*/nullptr
  , /*decltype(_impl_.attached_location_)*/0
  , /*decltype(_impl_.attached_type_)*/0
  , /*decltype(_impl_.percent_of_pa_contained_in_parent_rep_)*/0
  , /*decltype(_impl_.text_baselines_touched_count_)*/uint64_t{0u}
  , /*decltype(_impl_.visible_strokes_count_)*/uint64_t{0u}
  , /*decltype(_impl_.tool_type_)*/0
  , /*decltype(_impl_.compound_annotation_type_)*/0
  , /*decltype(_impl_.pencil_annotation_drawing_scale_)*/0} {}
struct PencilAnnotationStorageArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PencilAnnotationStorageArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PencilAnnotationStorageArchiveDefaultTypeInternal() {}
  union {
    PencilAnnotationStorageArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PencilAnnotationStorageArchiveDefaultTypeInternal _PencilAnnotationStorageArchive_default_instance_;
PROTOBUF_CONSTEXPR SpecColorFillSetColorArchive::SpecColorFillSetColorArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/nullptr} {}
struct SpecColorFillSetColorArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpecColorFillSetColorArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpecColorFillSetColorArchiveDefaultTypeInternal() {}
  union {
    SpecColorFillSetColorArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpecColorFillSetColorArchiveDefaultTypeInternal _SpecColorFillSetColorArchive_default_instance_;
PROTOBUF_CONSTEXPR SpecFrameSetAssetScaleArchive::SpecFrameSetAssetScaleArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.asset_scale_)*/0} {}
struct SpecFrameSetAssetScaleArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpecFrameSetAssetScaleArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpecFrameSetAssetScaleArchiveDefaultTypeInternal() {}
  union {
    SpecFrameSetAssetScaleArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpecFrameSetAssetScaleArchiveDefaultTypeInternal _SpecFrameSetAssetScaleArchive_default_instance_;
PROTOBUF_CONSTEXPR SpecGradientFillSetAngleArchive::SpecGradientFillSetAngleArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.angle_)*/0} {}
struct SpecGradientFillSetAngleArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpecGradientFillSetAngleArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpecGradientFillSetAngleArchiveDefaultTypeInternal() {}
  union {
    SpecGradientFillSetAngleArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpecGradientFillSetAngleArchiveDefaultTypeInternal _SpecGradientFillSetAngleArchive_default_instance_;
PROTOBUF_CONSTEXPR SpecImageFillSetTechniqueArchive::SpecImageFillSetTechniqueArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.technique_)*/0} {}
struct SpecImageFillSetTechniqueArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpecImageFillSetTechniqueArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpecImageFillSetTechniqueArchiveDefaultTypeInternal() {}
  union {
    SpecImageFillSetTechniqueArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpecImageFillSetTechniqueArchiveDefaultTypeInternal _SpecImageFillSetTechniqueArchive_default_instance_;
PROTOBUF_CONSTEXPR SpecReflectionSetOpacityArchive::SpecReflectionSetOpacityArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.opacity_)*/0} {}
struct SpecReflectionSetOpacityArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpecReflectionSetOpacityArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpecReflectionSetOpacityArchiveDefaultTypeInternal() {}
  union {
    SpecReflectionSetOpacityArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpecReflectionSetOpacityArchiveDefaultTypeInternal _SpecReflectionSetOpacityArchive_default_instance_;
PROTOBUF_CONSTEXPR SpecShadowSetAngleArchive::SpecShadowSetAngleArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.angle_)*/0} {}
struct SpecShadowSetAngleArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpecShadowSetAngleArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpecShadowSetAngleArchiveDefaultTypeInternal() {}
  union {
    SpecShadowSetAngleArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpecShadowSetAngleArchiveDefaultTypeInternal _SpecShadowSetAngleArchive_default_instance_;
PROTOBUF_CONSTEXPR SpecShadowSetColorArchive::SpecShadowSetColorArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/nullptr} {}
struct SpecShadowSetColorArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpecShadowSetColorArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpecShadowSetColorArchiveDefaultTypeInternal() {}
  union {
    SpecShadowSetColorArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpecShadowSetColorArchiveDefaultTypeInternal _SpecShadowSetColorArchive_default_instance_;
PROTOBUF_CONSTEXPR SpecShadowSetOffsetArchive::SpecShadowSetOffsetArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.offset_)*/0} {}
struct SpecShadowSetOffsetArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpecShadowSetOffsetArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpecShadowSetOffsetArchiveDefaultTypeInternal() {}
  union {
    SpecShadowSetOffsetArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpecShadowSetOffsetArchiveDefaultTypeInternal _SpecShadowSetOffsetArchive_default_instance_;
PROTOBUF_CONSTEXPR SpecShadowSetOpacityArchive::SpecShadowSetOpacityArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.opacity_)*/0} {}
struct SpecShadowSetOpacityArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpecShadowSetOpacityArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpecShadowSetOpacityArchiveDefaultTypeInternal() {}
  union {
    SpecShadowSetOpacityArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpecShadowSetOpacityArchiveDefaultTypeInternal _SpecShadowSetOpacityArchive_default_instance_;
PROTOBUF_CONSTEXPR SpecShadowSetRadiusArchive::SpecShadowSetRadiusArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.radius_)*/0} {}
struct SpecShadowSetRadiusArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpecShadowSetRadiusArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpecShadowSetRadiusArchiveDefaultTypeInternal() {}
  union {
    SpecShadowSetRadiusArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpecShadowSetRadiusArchiveDefaultTypeInternal _SpecShadowSetRadiusArchive_default_instance_;
PROTOBUF_CONSTEXPR SpecStrokeSetColorArchive::SpecStrokeSetColorArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/nullptr} {}
struct SpecStrokeSetColorArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpecStrokeSetColorArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpecStrokeSetColorArchiveDefaultTypeInternal() {}
  union {
    SpecStrokeSetColorArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpecStrokeSetColorArchiveDefaultTypeInternal _SpecStrokeSetColorArchive_default_instance_;
PROTOBUF_CONSTEXPR SpecStrokeSetPatternArchive::SpecStrokeSetPatternArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/nullptr
  , /*decltype(_impl_.pattern_)*/nullptr
  , /*decltype(_impl_.line_cap_)*/0
  , /*decltype(_impl_.line_join_)*/0
  , /*decltype(_impl_.miter_limit_)*/0
  , /*decltype(_impl_.width_)*/0} {}
struct SpecStrokeSetPatternArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpecStrokeSetPatternArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpecStrokeSetPatternArchiveDefaultTypeInternal() {}
  union {
    SpecStrokeSetPatternArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpecStrokeSetPatternArchiveDefaultTypeInternal _SpecStrokeSetPatternArchive_default_instance_;
PROTOBUF_CONSTEXPR SpecStrokeSetWidthArchive::SpecStrokeSetWidthArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.width_)*/0} {}
struct SpecStrokeSetWidthArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpecStrokeSetWidthArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpecStrokeSetWidthArchiveDefaultTypeInternal() {}
  union {
    SpecStrokeSetWidthArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpecStrokeSetWidthArchiveDefaultTypeInternal _SpecStrokeSetWidthArchive_default_instance_;
PROTOBUF_CONSTEXPR Attribution::Attribution(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.external_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.author_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.author_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct AttributionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttributionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttributionDefaultTypeInternal() {}
  union {
    Attribution _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttributionDefaultTypeInternal _Attribution_default_instance_;
PROTOBUF_CONSTEXPR MovieFingerprint::MovieFingerprint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tracks_)*/{}
  , /*decltype(_impl_.version_)*/{}
  , /*decltype(_impl_._version_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MovieFingerprintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MovieFingerprintDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MovieFingerprintDefaultTypeInternal() {}
  union {
    MovieFingerprint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MovieFingerprintDefaultTypeInternal _MovieFingerprint_default_instance_;
PROTOBUF_CONSTEXPR MovieFingerprintTrack::MovieFingerprintTrack(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.media_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sample_data_digest_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.extended_language_tag_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.natural_size_)*/nullptr
  , /*decltype(_impl_.total_sample_data_length_)*/int64_t{0}
  , /*decltype(_impl_.time_range_start_value_)*/int64_t{0}
  , /*decltype(_impl_.time_range_start_timescale_)*/0
  , /*decltype(_impl_.enabled_)*/false
  , /*decltype(_impl_.time_range_start_is_valid_)*/false
  , /*decltype(_impl_.time_range_duration_is_valid_)*/false
  , /*decltype(_impl_.time_range_duration_value_)*/int64_t{0}
  , /*decltype(_impl_.preferred_transform_a_)*/0
  , /*decltype(_impl_.preferred_transform_b_)*/0
  , /*decltype(_impl_.preferred_transform_c_)*/0
  , /*decltype(_impl_.preferred_transform_d_)*/0
  , /*decltype(_impl_.preferred_transform_tx_)*/0
  , /*decltype(_impl_.preferred_transform_ty_)*/0
  , /*decltype(_impl_.preferred_volume_)*/0
  , /*decltype(_impl_.time_range_duration_timescale_)*/0} {}
struct MovieFingerprintTrackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MovieFingerprintTrackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MovieFingerprintTrackDefaultTypeInternal() {}
  union {
    MovieFingerprintTrack _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MovieFingerprintTrackDefaultTypeInternal _MovieFingerprintTrack_default_instance_;
}  // namespace TSD
static ::_pb::Metadata file_level_metadata_TSDArchives_2eproto[80];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_TSDArchives_2eproto[14];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_TSDArchives_2eproto = nullptr;

const uint32_t TableStruct_TSDArchives_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::TSD::EdgeInsetsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::EdgeInsetsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::EdgeInsetsArchive, _impl_.top_),
  PROTOBUF_FIELD_OFFSET(::TSD::EdgeInsetsArchive, _impl_.left_),
  PROTOBUF_FIELD_OFFSET(::TSD::EdgeInsetsArchive, _impl_.bottom_),
  PROTOBUF_FIELD_OFFSET(::TSD::EdgeInsetsArchive, _impl_.right_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::GeometryArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::GeometryArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::GeometryArchive, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::TSD::GeometryArchive, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::TSD::GeometryArchive, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::TSD::GeometryArchive, _impl_.angle_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::PointPathSourceArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::PointPathSourceArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::PointPathSourceArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::PointPathSourceArchive, _impl_.point_),
  PROTOBUF_FIELD_OFFSET(::TSD::PointPathSourceArchive, _impl_.naturalsize_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::ScalarPathSourceArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ScalarPathSourceArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ScalarPathSourceArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::ScalarPathSourceArchive, _impl_.scalar_),
  PROTOBUF_FIELD_OFFSET(::TSD::ScalarPathSourceArchive, _impl_.naturalsize_),
  PROTOBUF_FIELD_OFFSET(::TSD::ScalarPathSourceArchive, _impl_.is_curve_continuous_),
  1,
  2,
  0,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::BezierPathSourceArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::BezierPathSourceArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::BezierPathSourceArchive, _impl_.path_string_),
  PROTOBUF_FIELD_OFFSET(::TSD::BezierPathSourceArchive, _impl_.naturalsize_),
  PROTOBUF_FIELD_OFFSET(::TSD::BezierPathSourceArchive, _impl_.path_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::CalloutPathSourceArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::CalloutPathSourceArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::CalloutPathSourceArchive, _impl_.natural_size_),
  PROTOBUF_FIELD_OFFSET(::TSD::CalloutPathSourceArchive, _impl_.tail_position_),
  PROTOBUF_FIELD_OFFSET(::TSD::CalloutPathSourceArchive, _impl_.tail_size_),
  PROTOBUF_FIELD_OFFSET(::TSD::CalloutPathSourceArchive, _impl_.corner_radius_),
  PROTOBUF_FIELD_OFFSET(::TSD::CalloutPathSourceArchive, _impl_.center_tail_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLinePathSourceArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLinePathSourceArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLinePathSourceArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLinePathSourceArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLinePathSourceArchive, _impl_.outset_from_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLinePathSourceArchive, _impl_.outset_to_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Node, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Node, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Node, _impl_.incontrolpoint_),
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Node, _impl_.nodepoint_),
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Node, _impl_.outcontrolpoint_),
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Node, _impl_.type_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Subpath, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Subpath, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Subpath, _impl_.nodes_),
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Subpath, _impl_.closed_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive, _impl_.subpaths_),
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive, _impl_.naturalsize_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.horizontalflip_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.verticalflip_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.point_path_source_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.scalar_path_source_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.bezier_path_source_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.callout_path_source_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.connection_line_path_source_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.editable_bezier_path_source_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.localizationkey_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.userdefinedname_),
  8,
  9,
  2,
  3,
  4,
  5,
  6,
  7,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::AngleGradientArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::AngleGradientArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::AngleGradientArchive, _impl_.gradientangle_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::TransformGradientArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::TransformGradientArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::TransformGradientArchive, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::TSD::TransformGradientArchive, _impl_.end_),
  PROTOBUF_FIELD_OFFSET(::TSD::TransformGradientArchive, _impl_.basenaturalsize_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive_GradientStop, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive_GradientStop, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive_GradientStop, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive_GradientStop, _impl_.fraction_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive_GradientStop, _impl_.inflection_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive, _impl_.stops_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive, _impl_.opacity_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive, _impl_.advancedgradient_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive, _impl_.anglegradient_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive, _impl_.transformgradient_),
  2,
  ~0u,
  3,
  4,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.imagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.technique_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.tint_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.fillsize_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.originalimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.interpretsuntaggedimagedataasgeneric_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.referencecolor_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.database_imagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.database_originalimagedata_),
  4,
  7,
  1,
  2,
  5,
  8,
  6,
  0,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::FillArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::FillArchive, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::TSD::FillArchive, _impl_._extensions_),
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::FillArchive, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::TSD::FillArchive, _impl_.gradient_),
  PROTOBUF_FIELD_OFFSET(::TSD::FillArchive, _impl_.image_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::StrokePatternArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokePatternArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::StrokePatternArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokePatternArchive, _impl_.phase_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokePatternArchive, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokePatternArchive, _impl_.pattern_),
  0,
  1,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.cap_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.join_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.miter_limit_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.pattern_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.smart_stroke_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.frame_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.patterned_stroke_),
  0,
  5,
  6,
  7,
  8,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TSD::SmartStrokeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::SmartStrokeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::SmartStrokeArchive, _impl_.stroke_name_),
  PROTOBUF_FIELD_OFFSET(::TSD::SmartStrokeArchive, _impl_.random_seed_),
  PROTOBUF_FIELD_OFFSET(::TSD::SmartStrokeArchive, _impl_.parametervalues_),
  PROTOBUF_FIELD_OFFSET(::TSD::SmartStrokeArchive, _impl_.pattern_offset_distance_),
  0,
  3,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::FrameArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::FrameArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::FrameArchive, _impl_.framename_),
  PROTOBUF_FIELD_OFFSET(::TSD::FrameArchive, _impl_.assetscale_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::PatternedStrokeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::PatternedStrokeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::PatternedStrokeArchive, _impl_.pattern_name_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::LineEndArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::LineEndArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::LineEndArchive, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::TSD::LineEndArchive, _impl_.line_join_),
  PROTOBUF_FIELD_OFFSET(::TSD::LineEndArchive, _impl_.end_point_),
  PROTOBUF_FIELD_OFFSET(::TSD::LineEndArchive, _impl_.is_filled_),
  PROTOBUF_FIELD_OFFSET(::TSD::LineEndArchive, _impl_.identifier_),
  1,
  3,
  2,
  4,
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.angle_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.offset_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.radius_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.opacity_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.is_enabled_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.dropshadow_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.contactshadow_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.curvedshadow_),
  0,
  6,
  7,
  8,
  9,
  5,
  4,
  1,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSD::DropShadowArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ContactShadowArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContactShadowArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ContactShadowArchive, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContactShadowArchive, _impl_.offset_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::CurvedShadowArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::CurvedShadowArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::CurvedShadowArchive, _impl_.curve_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::ReflectionArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ReflectionArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ReflectionArchive, _impl_.opacity_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.exposure_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.saturation_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.contrast_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.highlights_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.shadows_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.sharpness_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.denoise_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.temperature_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.tint_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.bottom_level_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.top_level_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.gamma_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.enhance_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.represents_sage_adjustments_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  13,
  10,
  11,
  12,
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStylePropertiesArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStylePropertiesArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStylePropertiesArchive, _impl_.fill_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStylePropertiesArchive, _impl_.stroke_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStylePropertiesArchive, _impl_.opacity_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStylePropertiesArchive, _impl_.shadow_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStylePropertiesArchive, _impl_.reflection_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStylePropertiesArchive, _impl_.head_line_end_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStylePropertiesArchive, _impl_.tail_line_end_),
  0,
  1,
  6,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStyleArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStyleArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStyleArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStyleArchive, _impl_.override_count_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStyleArchive, _impl_.shape_properties_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStylePropertiesArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStylePropertiesArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStylePropertiesArchive, _impl_.stroke_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStylePropertiesArchive, _impl_.opacity_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStylePropertiesArchive, _impl_.shadow_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStylePropertiesArchive, _impl_.reflection_),
  0,
  3,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStyleArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStyleArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStyleArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStyleArchive, _impl_.override_count_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStyleArchive, _impl_.media_properties_),
  0,
  2,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.gradient_fill_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.image_fill_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.shadow_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.line_style_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.shape_style_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.textbox_style_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.image_style_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.movie_style_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.drawing_line_style_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemeReplaceFillPresetCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemeReplaceFillPresetCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ThemeReplaceFillPresetCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemeReplaceFillPresetCommandArchive, _impl_.theme_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemeReplaceFillPresetCommandArchive, _impl_.fill_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemeReplaceFillPresetCommandArchive, _impl_.old_fill_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemeReplaceFillPresetCommandArchive, _impl_.index_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.geometry_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.exterior_text_wrap_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.hyperlink_url_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.locked_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.comment_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.aspect_ratio_locked_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.accessibility_description_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.pencil_annotations_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.caption_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.title_hidden_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.caption_hidden_),
  2,
  3,
  4,
  0,
  8,
  5,
  9,
  1,
  ~0u,
  6,
  7,
  10,
  11,
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerArchive, _impl_.geometry_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerArchive, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerArchive, _impl_.children_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TSD::GroupArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::GroupArchive, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::TSD::GroupArchive, _impl_._extensions_),
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::GroupArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::GroupArchive, _impl_.children_),
  PROTOBUF_FIELD_OFFSET(::TSD::GroupArchive, _impl_.fake_shape_for_empty_group_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingAnimationArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingAnimationArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingAnimationArchive, _impl_.duration_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingAnimationArchive, _impl_.should_loop_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingArchive, _impl_.spacer_shape_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingArchive, _impl_.opacity_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingArchive, _impl_.animation_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingArchive, _impl_.last_clamped_scale_),
  0,
  2,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeArchive, _impl_.style_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeArchive, _impl_.pathsource_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeArchive, _impl_.head_line_end_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeArchive, _impl_.tail_line_end_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeArchive, _impl_.strokepatternoffsetdistance_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineArchive, _impl_.connected_from_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineArchive, _impl_.connected_to_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineArchive, _impl_.connected_to_uuid_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineArchive, _impl_.connected_from_uuid_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_._extensions_),
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.style_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.originalsize_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.mask_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.thumbnaildata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.originaldata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.naturalsize_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.instantalphapath_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.imageadjustments_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.enhancedimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.adjustedimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.thumbnailadjustedimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.interpretsuntaggedimagedataasgeneric_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.database_data_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.database_thumbnaildata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.database_originaldata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.traced_path_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.attribution_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.should_trace_pdf_content_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.background_removed_),
  0,
  9,
  2,
  3,
  4,
  10,
  18,
  11,
  7,
  8,
  12,
  15,
  13,
  14,
  19,
  1,
  5,
  6,
  16,
  17,
  20,
  21,
  PROTOBUF_FIELD_OFFSET(::TSD::MaskArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::MaskArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::MaskArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::MaskArchive, _impl_.pathsource_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::ImageDataAttributes, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageDataAttributes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ImageDataAttributes, _impl_.pixel_size_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageDataAttributes, _impl_.image_is_srgb_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageDataAttributes, _impl_.should_be_interpreted_as_generic_if_untagged_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_._extensions_),
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.moviedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.importedauxiliarymoviedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.imported_auxiliary_movie_data_original_filename_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.movieremoteurl_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.starttime_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.endtime_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.postertime_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.loopoptionasinteger_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.loop_option_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.volume_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.autoplay_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.audioonly_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.streaming_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.nativeaudiorecording_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.playsacrossslides_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.posterimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.audioonlyimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.poster_image_generated_with_alpha_support_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.playablestate_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.database_moviedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.database_posterimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.database_audioonlyimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.style_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.originalsize_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.naturalsize_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.attribution_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.fingerprint_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.is_live_video_),
  2,
  6,
  12,
  1,
  0,
  15,
  16,
  17,
  18,
  26,
  19,
  22,
  23,
  24,
  25,
  27,
  7,
  8,
  28,
  20,
  21,
  3,
  4,
  5,
  9,
  10,
  11,
  13,
  14,
  29,
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapArchive, _impl_.direction_),
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapArchive, _impl_.fit_type_),
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapArchive, _impl_.margin_),
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapArchive, _impl_.alpha_threshold_),
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapArchive, _impl_.is_html_wrap_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableContentDescription, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableContentDescription, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableContentDescription, _impl_.element_kind_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableContentDescription, _impl_.is_anchored_to_text_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableContentDescription, _impl_.is_floating_above_text_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableContentDescription, _impl_.is_inline_with_text_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingContentDescription, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingContentDescription, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingContentDescription, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingContentDescription, _impl_.source_doc_wanted_spacer_shape_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _impl_.current_color_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _impl_.most_recent_restorable_tool_type_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _impl_.pen_tool_opacity_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _impl_.pen_tool_unscaled_width_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _impl_.pencil_tool_opacity_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _impl_.pencil_tool_unscaled_width_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _impl_.crayon_tool_opacity_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _impl_.crayon_tool_unscaled_width_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _impl_.fill_tool_opacity_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _impl_.eraser_tool_scaled_width_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _impl_.eraser_tool_erases_whole_objects_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _impl_.pen_tool_color_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _impl_.pencil_tool_color_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _impl_.crayon_tool_color_),
  PROTOBUF_FIELD_OFFSET(::TSD::FreehandDrawingToolkitUIState, _impl_.fill_tool_color_),
  0,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  1,
  2,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSD::StandinCaptionArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::GuideArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::GuideArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideArchive, _impl_.offset_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideArchive, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideArchive, _impl_.end_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideArchive, _impl_.dynamic_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideArchive, _impl_.infinite_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TSD::UserDefinedGuideArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::UserDefinedGuideArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::UserDefinedGuideArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::UserDefinedGuideArchive, _impl_.position_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSD::GuideStorageArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::GuideStorageArchive, _impl_.userdefinedguides_),
  PROTOBUF_FIELD_OFFSET(::TSD::CanvasSelectionArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::CanvasSelectionArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::CanvasSelectionArchive, _impl_.infos_),
  PROTOBUF_FIELD_OFFSET(::TSD::CanvasSelectionArchive, _impl_.non_interactive_infos_),
  PROTOBUF_FIELD_OFFSET(::TSD::CanvasSelectionArchive, _impl_.container_),
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableSelectionArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableSelectionArchive, _impl_.infos_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableSelectionArchive, _impl_.non_interactive_infos_),
  PROTOBUF_FIELD_OFFSET(::TSD::GroupSelectionArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::GroupSelectionArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::GroupSelectionArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::GroupSelectionArchive, _impl_.has_selected_infos_in_non_group_container_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSD::PathSelectionArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSD::InfoHyperlinkSelectionArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageArchive, _impl_.text_),
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageArchive, _impl_.creation_date_),
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageArchive, _impl_.author_),
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageArchive, _impl_.replies_),
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageArchive, _impl_.storage_uuid_),
  0,
  1,
  2,
  ~0u,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::ReplaceAnnotationAuthorCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ReplaceAnnotationAuthorCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ReplaceAnnotationAuthorCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ReplaceAnnotationAuthorCommandArchive, _impl_.old_annotation_author_),
  PROTOBUF_FIELD_OFFSET(::TSD::ReplaceAnnotationAuthorCommandArchive, _impl_.new_annotation_author_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationArchive, _impl_.pencil_annotation_storage_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationSelectionArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationSelectionArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationSelectionArchive, _impl_.pencil_annotation_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.attached_location_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.markup_offset_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.rasterized_image_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.legacy_encoded_drawing_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.drawing_path_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.strokes_bounding_box_origin_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.strokes_bounding_box_size_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.attached_type_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.original_attached_size_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.percent_of_pa_contained_in_parent_rep_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.text_baselines_touched_count_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.visible_strokes_count_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.pen_color_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.tool_type_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.callout_sub_storages_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.creation_date_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.pencil_annotation_drawing_scale_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.compound_annotation_type_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.sub_storages_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.encoded_drawing_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.stroke_points_frame_origin_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.stroke_points_frame_size_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.rendered_frame_origin_),
  PROTOBUF_FIELD_OFFSET(::TSD::PencilAnnotationStorageArchive, _impl_.rendered_frame_size_),
  14,
  0,
  1,
  2,
  3,
  4,
  5,
  15,
  6,
  16,
  17,
  18,
  7,
  19,
  ~0u,
  8,
  21,
  20,
  ~0u,
  9,
  10,
  11,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::TSD::SpecColorFillSetColorArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecColorFillSetColorArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::SpecColorFillSetColorArchive, _impl_.color_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::SpecFrameSetAssetScaleArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecFrameSetAssetScaleArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::SpecFrameSetAssetScaleArchive, _impl_.asset_scale_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::SpecGradientFillSetAngleArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecGradientFillSetAngleArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::SpecGradientFillSetAngleArchive, _impl_.angle_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::SpecImageFillSetTechniqueArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecImageFillSetTechniqueArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::SpecImageFillSetTechniqueArchive, _impl_.technique_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::SpecReflectionSetOpacityArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecReflectionSetOpacityArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::SpecReflectionSetOpacityArchive, _impl_.opacity_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::SpecShadowSetAngleArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecShadowSetAngleArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::SpecShadowSetAngleArchive, _impl_.angle_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::SpecShadowSetColorArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecShadowSetColorArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::SpecShadowSetColorArchive, _impl_.color_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::SpecShadowSetOffsetArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecShadowSetOffsetArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::SpecShadowSetOffsetArchive, _impl_.offset_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::SpecShadowSetOpacityArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecShadowSetOpacityArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::SpecShadowSetOpacityArchive, _impl_.opacity_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::SpecShadowSetRadiusArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecShadowSetRadiusArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::SpecShadowSetRadiusArchive, _impl_.radius_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::SpecStrokeSetColorArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecStrokeSetColorArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::SpecStrokeSetColorArchive, _impl_.color_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::SpecStrokeSetPatternArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecStrokeSetPatternArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::SpecStrokeSetPatternArchive, _impl_.line_cap_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecStrokeSetPatternArchive, _impl_.line_join_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecStrokeSetPatternArchive, _impl_.miter_limit_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecStrokeSetPatternArchive, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecStrokeSetPatternArchive, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecStrokeSetPatternArchive, _impl_.pattern_),
  2,
  3,
  4,
  5,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::SpecStrokeSetWidthArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::SpecStrokeSetWidthArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::SpecStrokeSetWidthArchive, _impl_.width_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::Attribution, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::Attribution, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::Attribution, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::TSD::Attribution, _impl_.description_text_),
  PROTOBUF_FIELD_OFFSET(::TSD::Attribution, _impl_.external_url_),
  PROTOBUF_FIELD_OFFSET(::TSD::Attribution, _impl_.author_name_),
  PROTOBUF_FIELD_OFFSET(::TSD::Attribution, _impl_.author_url_),
  0,
  1,
  2,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprint, _impl_.tracks_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprint, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.media_type_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.enabled_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.total_sample_data_length_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.sample_data_digest_string_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.time_range_start_value_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.time_range_start_timescale_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.time_range_start_is_valid_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.time_range_duration_value_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.time_range_duration_timescale_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.time_range_duration_is_valid_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.natural_size_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.preferred_transform_a_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.preferred_transform_b_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.preferred_transform_c_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.preferred_transform_d_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.preferred_transform_tx_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.preferred_transform_ty_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.preferred_volume_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.language_code_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieFingerprintTrack, _impl_.extended_language_tag_),
  0,
  8,
  5,
  1,
  6,
  7,
  9,
  11,
  19,
  10,
  4,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  2,
  3,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 10, -1, sizeof(::TSD::EdgeInsetsArchive)},
  { 14, 24, -1, sizeof(::TSD::GeometryArchive)},
  { 28, 37, -1, sizeof(::TSD::PointPathSourceArchive)},
  { 40, 50, -1, sizeof(::TSD::ScalarPathSourceArchive)},
  { 54, 63, -1, sizeof(::TSD::BezierPathSourceArchive)},
  { 66, 77, -1, sizeof(::TSD::CalloutPathSourceArchive)},
  { 82, 92, -1, sizeof(::TSD::ConnectionLinePathSourceArchive)},
  { 96, 106, -1, sizeof(::TSD::EditableBezierPathSourceArchive_Node)},
  { 110, 118, -1, sizeof(::TSD::EditableBezierPathSourceArchive_Subpath)},
  { 120, 128, -1, sizeof(::TSD::EditableBezierPathSourceArchive)},
  { 130, 146, -1, sizeof(::TSD::PathSourceArchive)},
  { 156, 163, -1, sizeof(::TSD::AngleGradientArchive)},
  { 164, 173, -1, sizeof(::TSD::TransformGradientArchive)},
  { 176, 185, -1, sizeof(::TSD::GradientArchive_GradientStop)},
  { 188, 200, -1, sizeof(::TSD::GradientArchive)},
  { 206, 221, -1, sizeof(::TSD::ImageFillArchive)},
  { 230, 239, -1, sizeof(::TSD::FillArchive)},
  { 242, 252, -1, sizeof(::TSD::StrokePatternArchive)},
  { 256, 271, -1, sizeof(::TSD::StrokeArchive)},
  { 280, 290, -1, sizeof(::TSD::SmartStrokeArchive)},
  { 294, 302, -1, sizeof(::TSD::FrameArchive)},
  { 304, 311, -1, sizeof(::TSD::PatternedStrokeArchive)},
  { 312, 323, -1, sizeof(::TSD::LineEndArchive)},
  { 328, 344, -1, sizeof(::TSD::ShadowArchive)},
  { 354, -1, -1, sizeof(::TSD::DropShadowArchive)},
  { 360, 368, -1, sizeof(::TSD::ContactShadowArchive)},
  { 370, 377, -1, sizeof(::TSD::CurvedShadowArchive)},
  { 378, 385, -1, sizeof(::TSD::ReflectionArchive)},
  { 386, 406, -1, sizeof(::TSD::ImageAdjustmentsArchive)},
  { 420, 433, -1, sizeof(::TSD::ShapeStylePropertiesArchive)},
  { 440, 449, -1, sizeof(::TSD::ShapeStyleArchive)},
  { 452, 462, -1, sizeof(::TSD::MediaStylePropertiesArchive)},
  { 466, 475, -1, sizeof(::TSD::MediaStyleArchive)},
  { 478, -1, -1, sizeof(::TSD::ThemePresetsArchive)},
  { 493, 504, -1, sizeof(::TSD::ThemeReplaceFillPresetCommandArchive)},
  { 509, 528, -1, sizeof(::TSD::DrawableArchive)},
  { 541, 550, -1, sizeof(::TSD::ContainerArchive)},
  { 553, 562, -1, sizeof(::TSD::GroupArchive)},
  { 565, 573, -1, sizeof(::TSD::FreehandDrawingAnimationArchive)},
  { 575, 585, -1, sizeof(::TSD::FreehandDrawingArchive)},
  { 589, 601, -1, sizeof(::TSD::ShapeArchive)},
  { 607, 618, -1, sizeof(::TSD::ConnectionLineArchive)},
  { 623, 651, -1, sizeof(::TSD::ImageArchive)},
  { 673, 681, -1, sizeof(::TSD::MaskArchive)},
  { 683, 692, -1, sizeof(::TSD::ImageDataAttributes)},
  { 695, 731, -1, sizeof(::TSD::MovieArchive)},
  { 761, 773, -1, sizeof(::TSD::ExteriorTextWrapArchive)},
  { 779, 789, -1, sizeof(::TSD::DrawableContentDescription)},
  { 793, 801, -1, sizeof(::TSD::FreehandDrawingContentDescription)},
  { 803, 824, -1, sizeof(::TSD::FreehandDrawingToolkitUIState)},
  { 839, -1, -1, sizeof(::TSD::StandinCaptionArchive)},
  { 845, 857, -1, sizeof(::TSD::GuideArchive)},
  { 863, 871, -1, sizeof(::TSD::UserDefinedGuideArchive)},
  { 873, -1, -1, sizeof(::TSD::GuideStorageArchive)},
  { 880, 889, -1, sizeof(::TSD::CanvasSelectionArchive)},
  { 892, -1, -1, sizeof(::TSD::DrawableSelectionArchive)},
  { 900, 908, -1, sizeof(::TSD::GroupSelectionArchive)},
  { 910, -1, -1, sizeof(::TSD::PathSelectionArchive)},
  { 916, -1, -1, sizeof(::TSD::InfoHyperlinkSelectionArchive)},
  { 922, 933, -1, sizeof(::TSD::CommentStorageArchive)},
  { 938, 947, -1, sizeof(::TSD::ReplaceAnnotationAuthorCommandArchive)},
  { 950, 957, -1, sizeof(::TSD::PencilAnnotationArchive)},
  { 958, 965, -1, sizeof(::TSD::PencilAnnotationSelectionArchive)},
  { 966, 996, -1, sizeof(::TSD::PencilAnnotationStorageArchive)},
  { 1020, 1027, -1, sizeof(::TSD::SpecColorFillSetColorArchive)},
  { 1028, 1035, -1, sizeof(::TSD::SpecFrameSetAssetScaleArchive)},
  { 1036, 1043, -1, sizeof(::TSD::SpecGradientFillSetAngleArchive)},
  { 1044, 1051, -1, sizeof(::TSD::SpecImageFillSetTechniqueArchive)},
  { 1052, 1059, -1, sizeof(::TSD::SpecReflectionSetOpacityArchive)},
  { 1060, 1067, -1, sizeof(::TSD::SpecShadowSetAngleArchive)},
  { 1068, 1075, -1, sizeof(::TSD::SpecShadowSetColorArchive)},
  { 1076, 1083, -1, sizeof(::TSD::SpecShadowSetOffsetArchive)},
  { 1084, 1091, -1, sizeof(::TSD::SpecShadowSetOpacityArchive)},
  { 1092, 1099, -1, sizeof(::TSD::SpecShadowSetRadiusArchive)},
  { 1100, 1107, -1, sizeof(::TSD::SpecStrokeSetColorArchive)},
  { 1108, 1120, -1, sizeof(::TSD::SpecStrokeSetPatternArchive)},
  { 1126, 1133, -1, sizeof(::TSD::SpecStrokeSetWidthArchive)},
  { 1134, 1145, -1, sizeof(::TSD::Attribution)},
  { 1150, -1, -1, sizeof(::TSD::MovieFingerprint)},
  { 1158, 1184, -1, sizeof(::TSD::MovieFingerprintTrack)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::TSD::_EdgeInsetsArchive_default_instance_._instance,
  &::TSD::_GeometryArchive_default_instance_._instance,
  &::TSD::_PointPathSourceArchive_default_instance_._instance,
  &::TSD::_ScalarPathSourceArchive_default_instance_._instance,
  &::TSD::_BezierPathSourceArchive_default_instance_._instance,
  &::TSD::_CalloutPathSourceArchive_default_instance_._instance,
  &::TSD::_ConnectionLinePathSourceArchive_default_instance_._instance,
  &::TSD::_EditableBezierPathSourceArchive_Node_default_instance_._instance,
  &::TSD::_EditableBezierPathSourceArchive_Subpath_default_instance_._instance,
  &::TSD::_EditableBezierPathSourceArchive_default_instance_._instance,
  &::TSD::_PathSourceArchive_default_instance_._instance,
  &::TSD::_AngleGradientArchive_default_instance_._instance,
  &::TSD::_TransformGradientArchive_default_instance_._instance,
  &::TSD::_GradientArchive_GradientStop_default_instance_._instance,
  &::TSD::_GradientArchive_default_instance_._instance,
  &::TSD::_ImageFillArchive_default_instance_._instance,
  &::TSD::_FillArchive_default_instance_._instance,
  &::TSD::_StrokePatternArchive_default_instance_._instance,
  &::TSD::_StrokeArchive_default_instance_._instance,
  &::TSD::_SmartStrokeArchive_default_instance_._instance,
  &::TSD::_FrameArchive_default_instance_._instance,
  &::TSD::_PatternedStrokeArchive_default_instance_._instance,
  &::TSD::_LineEndArchive_default_instance_._instance,
  &::TSD::_ShadowArchive_default_instance_._instance,
  &::TSD::_DropShadowArchive_default_instance_._instance,
  &::TSD::_ContactShadowArchive_default_instance_._instance,
  &::TSD::_CurvedShadowArchive_default_instance_._instance,
  &::TSD::_ReflectionArchive_default_instance_._instance,
  &::TSD::_ImageAdjustmentsArchive_default_instance_._instance,
  &::TSD::_ShapeStylePropertiesArchive_default_instance_._instance,
  &::TSD::_ShapeStyleArchive_default_instance_._instance,
  &::TSD::_MediaStylePropertiesArchive_default_instance_._instance,
  &::TSD::_MediaStyleArchive_default_instance_._instance,
  &::TSD::_ThemePresetsArchive_default_instance_._instance,
  &::TSD::_ThemeReplaceFillPresetCommandArchive_default_instance_._instance,
  &::TSD::_DrawableArchive_default_instance_._instance,
  &::TSD::_ContainerArchive_default_instance_._instance,
  &::TSD::_GroupArchive_default_instance_._instance,
  &::TSD::_FreehandDrawingAnimationArchive_default_instance_._instance,
  &::TSD::_FreehandDrawingArchive_default_instance_._instance,
  &::TSD::_ShapeArchive_default_instance_._instance,
  &::TSD::_ConnectionLineArchive_default_instance_._instance,
  &::TSD::_ImageArchive_default_instance_._instance,
  &::TSD::_MaskArchive_default_instance_._instance,
  &::TSD::_ImageDataAttributes_default_instance_._instance,
  &::TSD::_MovieArchive_default_instance_._instance,
  &::TSD::_ExteriorTextWrapArchive_default_instance_._instance,
  &::TSD::_DrawableContentDescription_default_instance_._instance,
  &::TSD::_FreehandDrawingContentDescription_default_instance_._instance,
  &::TSD::_FreehandDrawingToolkitUIState_default_instance_._instance,
  &::TSD::_StandinCaptionArchive_default_instance_._instance,
  &::TSD::_GuideArchive_default_instance_._instance,
  &::TSD::_UserDefinedGuideArchive_default_instance_._instance,
  &::TSD::_GuideStorageArchive_default_instance_._instance,
  &::TSD::_CanvasSelectionArchive_default_instance_._instance,
  &::TSD::_DrawableSelectionArchive_default_instance_._instance,
  &::TSD::_GroupSelectionArchive_default_instance_._instance,
  &::TSD::_PathSelectionArchive_default_instance_._instance,
  &::TSD::_InfoHyperlinkSelectionArchive_default_instance_._instance,
  &::TSD::_CommentStorageArchive_default_instance_._instance,
  &::TSD::_ReplaceAnnotationAuthorCommandArchive_default_instance_._instance,
  &::TSD::_PencilAnnotationArchive_default_instance_._instance,
  &::TSD::_PencilAnnotationSelectionArchive_default_instance_._instance,
  &::TSD::_PencilAnnotationStorageArchive_default_instance_._instance,
  &::TSD::_SpecColorFillSetColorArchive_default_instance_._instance,
  &::TSD::_SpecFrameSetAssetScaleArchive_default_instance_._instance,
  &::TSD::_SpecGradientFillSetAngleArchive_default_instance_._instance,
  &::TSD::_SpecImageFillSetTechniqueArchive_default_instance_._instance,
  &::TSD::_SpecReflectionSetOpacityArchive_default_instance_._instance,
  &::TSD::_SpecShadowSetAngleArchive_default_instance_._instance,
  &::TSD::_SpecShadowSetColorArchive_default_instance_._instance,
  &::TSD::_SpecShadowSetOffsetArchive_default_instance_._instance,
  &::TSD::_SpecShadowSetOpacityArchive_default_instance_._instance,
  &::TSD::_SpecShadowSetRadiusArchive_default_instance_._instance,
  &::TSD::_SpecStrokeSetColorArchive_default_instance_._instance,
  &::TSD::_SpecStrokeSetPatternArchive_default_instance_._instance,
  &::TSD::_SpecStrokeSetWidthArchive_default_instance_._instance,
  &::TSD::_Attribution_default_instance_._instance,
  &::TSD::_MovieFingerprint_default_instance_._instance,
  &::TSD::_MovieFingerprintTrack_default_instance_._instance,
};

const char descriptor_table_protodef_TSDArchives_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021TSDArchives.proto\022\003TSD\032\021TSPMessages.pr"
  "oto\032\021TSKArchives.proto\032\021TSSArchives.prot"
  "o\"M\n\021EdgeInsetsArchive\022\013\n\003top\030\001 \002(\002\022\014\n\004l"
  "eft\030\002 \002(\002\022\016\n\006bottom\030\003 \002(\002\022\r\n\005right\030\004 \002(\002"
  "\"f\n\017GeometryArchive\022\034\n\010position\030\001 \001(\0132\n."
  "TSP.Point\022\027\n\004size\030\002 \001(\0132\t.TSP.Size\022\r\n\005fl"
  "ags\030\003 \001(\r\022\r\n\005angle\030\004 \001(\002\"\216\002\n\026PointPathSo"
  "urceArchive\022=\n\004type\030\001 \001(\0162/.TSD.PointPat"
  "hSourceArchive.PointPathSourceType\022\031\n\005po"
  "int\030\002 \001(\0132\n.TSP.Point\022\036\n\013naturalSize\030\003 \001"
  "(\0132\t.TSP.Size\"z\n\023PointPathSourceType\022\027\n\023"
  "kTSDLeftSingleArrow\020\000\022\030\n\024kTSDRightSingle"
  "Arrow\020\001\022\023\n\017kTSDDoubleArrow\020\n\022\014\n\010kTSDStar"
  "\020d\022\r\n\010kTSDPlus\020\310\001\"\202\002\n\027ScalarPathSourceAr"
  "chive\022\?\n\004type\030\001 \001(\01621.TSD.ScalarPathSour"
  "ceArchive.ScalarPathSourceType\022\016\n\006scalar"
  "\030\002 \001(\002\022\036\n\013naturalSize\030\003 \001(\0132\t.TSP.Size\022\033"
  "\n\023is_curve_continuous\030\004 \001(\010\"Y\n\024ScalarPat"
  "hSourceType\022\030\n\024kTSDRoundedRectangle\020\000\022\026\n"
  "\022kTSDRegularPolygon\020\001\022\017\n\013kTSDChevron\020\002\"k"
  "\n\027BezierPathSourceArchive\022\027\n\013path_string"
  "\030\001 \001(\tB\002\030\001\022\036\n\013naturalSize\030\002 \001(\0132\t.TSP.Si"
  "ze\022\027\n\004path\030\003 \001(\0132\t.TSP.Path\"\235\001\n\030CalloutP"
  "athSourceArchive\022\037\n\014natural_size\030\001 \001(\0132\t"
  ".TSP.Size\022!\n\rtail_position\030\002 \001(\0132\n.TSP.P"
  "oint\022\021\n\ttail_size\030\003 \001(\002\022\025\n\rcorner_radius"
  "\030\004 \001(\002\022\023\n\013center_tail\030\005 \001(\010\"\262\002\n\037Connecti"
  "onLinePathSourceArchive\022+\n\005super\030\001 \002(\0132\034"
  ".TSD.BezierPathSourceArchive\022O\n\004type\030\002 \001"
  "(\0162A.TSD.ConnectionLinePathSourceArchive"
  ".ConnectionLinePathSourceType\022\023\n\013outset_"
  "from\030\003 \001(\002\022\021\n\toutset_to\030\004 \001(\002\"i\n\034Connect"
  "ionLinePathSourceType\022#\n\037kTSDConnectionL"
  "ineTypeQuadratic\020\000\022$\n kTSDConnectionLine"
  "TypeOrthogonal\020\001\"\263\003\n\037EditableBezierPathS"
  "ourceArchive\022>\n\010subpaths\030\001 \003(\0132,.TSD.Edi"
  "tableBezierPathSourceArchive.Subpath\022\036\n\013"
  "naturalSize\030\002 \001(\0132\t.TSP.Size\032\253\001\n\004Node\022\"\n"
  "\016inControlPoint\030\001 \002(\0132\n.TSP.Point\022\035\n\tnod"
  "ePoint\030\002 \002(\0132\n.TSP.Point\022#\n\017outControlPo"
  "int\030\003 \002(\0132\n.TSP.Point\022;\n\004type\030\004 \002(\0162-.TS"
  "D.EditableBezierPathSourceArchive.NodeTy"
  "pe\032S\n\007Subpath\0228\n\005nodes\030\001 \003(\0132).TSD.Edita"
  "bleBezierPathSourceArchive.Node\022\016\n\006close"
  "d\030\002 \002(\010\"-\n\010NodeType\022\t\n\005sharp\020\001\022\n\n\006bezier"
  "\020\002\022\n\n\006smooth\020\003\"\361\003\n\021PathSourceArchive\022\026\n\016"
  "horizontalFlip\030\001 \001(\010\022\024\n\014verticalFlip\030\002 \001"
  "(\010\0226\n\021point_path_source\030\003 \001(\0132\033.TSD.Poin"
  "tPathSourceArchive\0228\n\022scalar_path_source"
  "\030\004 \001(\0132\034.TSD.ScalarPathSourceArchive\0228\n\022"
  "bezier_path_source\030\005 \001(\0132\034.TSD.BezierPat"
  "hSourceArchive\022:\n\023callout_path_source\030\006 "
  "\001(\0132\035.TSD.CalloutPathSourceArchive\022I\n\033co"
  "nnection_line_path_source\030\007 \001(\0132$.TSD.Co"
  "nnectionLinePathSourceArchive\022I\n\033editabl"
  "e_bezier_path_source\030\010 \001(\0132$.TSD.Editabl"
  "eBezierPathSourceArchive\022\027\n\017localization"
  "Key\030\t \001(\t\022\027\n\017userDefinedName\030\n \001(\t\"-\n\024An"
  "gleGradientArchive\022\025\n\rgradientangle\030\002 \001("
  "\002\"r\n\030TransformGradientArchive\022\031\n\005start\030\001"
  " \001(\0132\n.TSP.Point\022\027\n\003end\030\002 \001(\0132\n.TSP.Poin"
  "t\022\"\n\017baseNaturalSize\030\003 \001(\0132\t.TSP.Size\"\204\003"
  "\n\017GradientArchive\022/\n\004type\030\001 \001(\0162!.TSD.Gr"
  "adientArchive.GradientType\0220\n\005stops\030\002 \003("
  "\0132!.TSD.GradientArchive.GradientStop\022\017\n\007"
  "opacity\030\003 \001(\002\022\030\n\020advancedGradient\030\004 \001(\010\022"
  "0\n\ranglegradient\030\005 \001(\0132\031.TSD.AngleGradie"
  "ntArchive\0228\n\021transformgradient\030\006 \001(\0132\035.T"
  "SD.TransformGradientArchive\032O\n\014GradientS"
  "top\022\031\n\005color\030\001 \001(\0132\n.TSP.Color\022\020\n\010fracti"
  "on\030\002 \001(\002\022\022\n\ninflection\030\003 \001(\002\"&\n\014Gradient"
  "Type\022\n\n\006Linear\020\000\022\n\n\006Radial\020\001\"\376\003\n\020ImageFi"
  "llArchive\022%\n\timagedata\030\006 \001(\0132\022.TSP.DataR"
  "eference\022H\n\ttechnique\030\002 \001(\0162(.TSD.ImageF"
  "illArchive.ImageFillTechnique:\013NaturalSi"
  "ze\022\030\n\004tint\030\003 \001(\0132\n.TSP.Color\022\033\n\010fillsize"
  "\030\004 \001(\0132\t.TSP.Size\0221\n\021originalimagedata\030\007"
  " \001(\0132\022.TSP.DataReferenceB\002\030\001\022,\n$interpre"
  "tsUntaggedImageDataAsGeneric\030\010 \001(\010\022\"\n\016re"
  "ferencecolor\030\t \001(\0132\n.TSP.Color\022*\n\022databa"
  "se_imagedata\030\001 \001(\0132\016.TSP.Reference\0222\n\032da"
  "tabase_originalimagedata\030\005 \001(\0132\016.TSP.Ref"
  "erence\"]\n\022ImageFillTechnique\022\017\n\013NaturalS"
  "ize\020\000\022\013\n\007Stretch\020\001\022\010\n\004Tile\020\002\022\017\n\013ScaleToF"
  "ill\020\003\022\016\n\nScaleToFit\020\004\"\200\001\n\013FillArchive\022\031\n"
  "\005color\030\001 \001(\0132\n.TSP.Color\022&\n\010gradient\030\002 \001"
  "(\0132\024.TSD.GradientArchive\022$\n\005image\030\003 \001(\0132"
  "\025.TSD.ImageFillArchive*\010\010d\020\200\200\200\200\002\"\317\001\n\024Str"
  "okePatternArchive\0229\n\004type\030\001 \001(\0162+.TSD.St"
  "rokePatternArchive.StrokePatternType\022\r\n\005"
  "phase\030\002 \001(\002\022\r\n\005count\030\003 \001(\r\022\017\n\007pattern\030\004 "
  "\003(\002\"M\n\021StrokePatternType\022\016\n\nTSDPattern\020\000"
  "\022\023\n\017TSDSolidPattern\020\001\022\023\n\017TSDEmptyPattern"
  "\020\002\"\375\002\n\rStrokeArchive\022\031\n\005color\030\001 \001(\0132\n.TS"
  "P.Color\022\r\n\005width\030\002 \001(\002\022\'\n\003cap\030\003 \001(\0162\032.TS"
  "D.StrokeArchive.LineCap\022\033\n\004join\030\004 \001(\0162\r."
  "TSD.LineJoin\022\023\n\013miter_limit\030\005 \001(\002\022*\n\007pat"
  "tern\030\006 \001(\0132\031.TSD.StrokePatternArchive\022-\n"
  "\014smart_stroke\030\007 \001(\0132\027.TSD.SmartStrokeArc"
  "hive\022 \n\005frame\030\010 \001(\0132\021.TSD.FrameArchive\0225"
  "\n\020patterned_stroke\030\t \001(\0132\033.TSD.Patterned"
  "StrokeArchive\"3\n\007LineCap\022\013\n\007ButtCap\020\000\022\014\n"
  "\010RoundCap\020\001\022\r\n\tSquareCap\020\002\"\222\001\n\022SmartStro"
  "keArchive\022\023\n\013stroke_name\030\002 \001(\t\022\023\n\013random"
  "_seed\030\003 \001(\r\0221\n\017parameterValues\030\004 \001(\0132\030.T"
  "SP.ReferenceDictionary\022\037\n\027pattern_offset"
  "_distance\030\005 \001(\001\"5\n\014FrameArchive\022\021\n\tframe"
  "Name\030\002 \001(\t\022\022\n\nassetScale\030\003 \001(\002\".\n\026Patter"
  "nedStrokeArchive\022\024\n\014pattern_name\030\002 \001(\t\"\234"
  "\001\n\016LineEndArchive\022\027\n\004path\030\001 \001(\0132\t.TSP.Pa"
  "th\022+\n\tline_join\030\002 \001(\0162\r.TSD.LineJoin:\tMi"
  "terJoin\022\035\n\tend_point\030\003 \001(\0132\n.TSP.Point\022\021"
  "\n\tis_filled\030\004 \001(\010\022\022\n\nidentifier\030\005 \001(\t\"\250\003"
  "\n\rShadowArchive\022\031\n\005color\030\001 \001(\0132\n.TSP.Col"
  "or\022\022\n\005angle\030\002 \001(\002:\003315\022\021\n\006offset\030\003 \001(\002:\001"
  "5\022\021\n\006radius\030\004 \001(\005:\0011\022\022\n\007opacity\030\005 \001(\002:\0011"
  "\022\030\n\nis_enabled\030\006 \001(\010:\004true\022:\n\004type\030\007 \001(\016"
  "2\035.TSD.ShadowArchive.ShadowType:\rTSDDrop"
  "Shadow\022*\n\ndropShadow\030\010 \001(\0132\026.TSD.DropSha"
  "dowArchive\0220\n\rcontactShadow\030\t \001(\0132\031.TSD."
  "ContactShadowArchive\022.\n\014curvedShadow\030\n \001"
  "(\0132\030.TSD.CurvedShadowArchive\"J\n\nShadowTy"
  "pe\022\021\n\rTSDDropShadow\020\000\022\024\n\020TSDContactShado"
  "w\020\001\022\023\n\017TSDCurvedShadow\020\002\"\023\n\021DropShadowAr"
  "chive\">\n\024ContactShadowArchive\022\023\n\006height\030"
  "\002 \001(\002:\0030.2\022\021\n\006offset\030\004 \001(\002:\0010\")\n\023CurvedS"
  "hadowArchive\022\022\n\005curve\030\001 \001(\002:\0030.6\")\n\021Refl"
  "ectionArchive\022\024\n\007opacity\030\001 \001(\002:\0030.5\"\274\002\n\027"
  "ImageAdjustmentsArchive\022\020\n\010exposure\030\001 \001("
  "\002\022\022\n\nsaturation\030\002 \001(\002\022\020\n\010contrast\030\003 \001(\002\022"
  "\022\n\nhighlights\030\004 \001(\002\022\017\n\007shadows\030\005 \001(\002\022\021\n\t"
  "sharpness\030\006 \001(\002\022\017\n\007denoise\030\007 \001(\002\022\023\n\013temp"
  "erature\030\010 \001(\002\022\014\n\004tint\030\t \001(\002\022\024\n\014bottom_le"
  "vel\030\n \001(\002\022\024\n\ttop_level\030\013 \001(\002:\0011\022\r\n\005gamma"
  "\030\014 \001(\002\022\026\n\007enhance\030\r \001(\010:\005false\022*\n\033repres"
  "ents_sage_adjustments\030\016 \001(\010:\005false\"\232\002\n\033S"
  "hapeStylePropertiesArchive\022\036\n\004fill\030\001 \001(\013"
  "2\020.TSD.FillArchive\022\"\n\006stroke\030\002 \001(\0132\022.TSD"
  ".StrokeArchive\022\017\n\007opacity\030\003 \001(\002\022\"\n\006shado"
  "w\030\004 \001(\0132\022.TSD.ShadowArchive\022*\n\nreflectio"
  "n\030\005 \001(\0132\026.TSD.ReflectionArchive\022*\n\rhead_"
  "line_end\030\006 \001(\0132\023.TSD.LineEndArchive\022*\n\rt"
  "ail_line_end\030\007 \001(\0132\023.TSD.LineEndArchive\""
  "\214\001\n\021ShapeStyleArchive\022 \n\005super\030\001 \002(\0132\021.T"
  "SS.StyleArchive\022\031\n\016override_count\030\n \001(\r:"
  "\0010\022:\n\020shape_properties\030\013 \001(\0132 .TSD.Shape"
  "StylePropertiesArchive\"\242\001\n\033MediaStylePro"
  "pertiesArchive\022\"\n\006stroke\030\001 \001(\0132\022.TSD.Str"
  "okeArchive\022\017\n\007opacity\030\002 \001(\002\022\"\n\006shadow\030\003 "
  "\001(\0132\022.TSD.ShadowArchive\022*\n\nreflection\030\004 "
  "\001(\0132\026.TSD.ReflectionArchive\"\214\001\n\021MediaSty"
  "leArchive\022 \n\005super\030\001 \002(\0132\021.TSS.StyleArch"
  "ive\022\031\n\016override_count\030\n \001(\r:\0010\022:\n\020media_"
  "properties\030\013 \001(\0132 .TSD.MediaStylePropert"
  "iesArchive\"\366\003\n\023ThemePresetsArchive\022/\n\025gr"
  "adient_fill_presets\030\001 \003(\0132\020.TSD.FillArch"
  "ive\022,\n\022image_fill_presets\030\002 \003(\0132\020.TSD.Fi"
  "llArchive\022*\n\016shadow_presets\030\003 \003(\0132\022.TSD."
  "ShadowArchive\022*\n\022line_style_presets\030\004 \003("
  "\0132\016.TSP.Reference\022+\n\023shape_style_presets"
  "\030\005 \003(\0132\016.TSP.Reference\022-\n\025textbox_style_"
  "presets\030\006 \003(\0132\016.TSP.Reference\022+\n\023image_s"
  "tyle_presets\030\007 \003(\0132\016.TSP.Reference\022+\n\023mo"
  "vie_style_presets\030\010 \003(\0132\016.TSP.Reference\022"
  "2\n\032drawing_line_style_presets\030\t \003(\0132\016.TS"
  "P.Reference2>\n\textension\022\021.TSS.ThemeArch"
  "ive\030d \001(\0132\030.TSD.ThemePresetsArchive\"\274\001\n$"
  "ThemeReplaceFillPresetCommandArchive\022\"\n\005"
  "super\030\001 \002(\0132\023.TSK.CommandArchive\022\035\n\005them"
  "e\030\002 \002(\0132\016.TSP.Reference\022\036\n\004fill\030\003 \002(\0132\020."
  "TSD.FillArchive\022\"\n\010old_fill\030\004 \002(\0132\020.TSD."
  "FillArchive\022\r\n\005index\030\005 \002(\r\"\265\003\n\017DrawableA"
  "rchive\022&\n\010geometry\030\001 \001(\0132\024.TSD.GeometryA"
  "rchive\022\036\n\006parent\030\002 \001(\0132\016.TSP.Reference\0228"
  "\n\022exterior_text_wrap\030\003 \001(\0132\034.TSD.Exterio"
  "rTextWrapArchive\022\025\n\rhyperlink_url\030\004 \001(\t\022"
  "\016\n\006locked\030\005 \001(\010\022\037\n\007comment\030\006 \001(\0132\016.TSP.R"
  "eference\022\033\n\023aspect_ratio_locked\030\007 \001(\010\022!\n"
  "\031accessibility_description\030\010 \001(\t\022*\n\022penc"
  "il_annotations\030\t \003(\0132\016.TSP.Reference\022\035\n\005"
  "title\030\n \001(\0132\016.TSP.Reference\022\037\n\007caption\030\013"
  " \001(\0132\016.TSP.Reference\022\024\n\014title_hidden\030\014 \001"
  "(\010\022\026\n\016caption_hidden\030\r \001(\010\"|\n\020ContainerA"
  "rchive\022&\n\010geometry\030\001 \001(\0132\024.TSD.GeometryA"
  "rchive\022\036\n\006parent\030\002 \001(\0132\016.TSP.Reference\022 "
  "\n\010children\030\003 \003(\0132\016.TSP.Reference\"\223\001\n\014Gro"
  "upArchive\022#\n\005super\030\001 \002(\0132\024.TSD.DrawableA"
  "rchive\022 \n\010children\030\002 \003(\0132\016.TSP.Reference"
  "\0222\n\032fake_shape_for_empty_group\030\003 \001(\0132\016.T"
  "SP.Reference*\010\010d\020\200\200\200\200\002\"H\n\037FreehandDrawin"
  "gAnimationArchive\022\020\n\010duration\030\001 \001(\001\022\023\n\013s"
  "hould_loop\030\002 \001(\010\"\366\001\n\026FreehandDrawingArch"
  "ive\022$\n\014spacer_shape\030\001 \001(\0132\016.TSP.Referenc"
  "e\022\017\n\007opacity\030\002 \001(\001\0227\n\tanimation\030\003 \001(\0132$."
  "TSD.FreehandDrawingAnimationArchive\022\032\n\022l"
  "ast_clamped_scale\030\004 \001(\0012P\n\030freehand_draw"
  "ing_archive\022\021.TSD.GroupArchive\030d \001(\0132\033.T"
  "SD.FreehandDrawingArchive\"\203\002\n\014ShapeArchi"
  "ve\022#\n\005super\030\001 \002(\0132\024.TSD.DrawableArchive\022"
  "\035\n\005style\030\002 \001(\0132\016.TSP.Reference\022*\n\npathso"
  "urce\030\003 \001(\0132\026.TSD.PathSourceArchive\022.\n\rhe"
  "ad_line_end\030\004 \001(\0132\023.TSD.LineEndArchiveB\002"
  "\030\001\022.\n\rtail_line_end\030\005 \001(\0132\023.TSD.LineEndA"
  "rchiveB\002\030\001\022#\n\033strokePatternOffsetDistanc"
  "e\030\006 \001(\002\"\325\001\n\025ConnectionLineArchive\022 \n\005sup"
  "er\030\001 \002(\0132\021.TSD.ShapeArchive\022&\n\016connected"
  "_from\030\002 \001(\0132\016.TSP.Reference\022$\n\014connected"
  "_to\030\003 \001(\0132\016.TSP.Reference\022$\n\021connected_t"
  "o_uuid\030\004 \001(\0132\t.TSP.UUID\022&\n\023connected_fro"
  "m_uuid\030\005 \001(\0132\t.TSP.UUID\"\352\006\n\014ImageArchive"
  "\022#\n\005super\030\001 \002(\0132\024.TSD.DrawableArchive\022 \n"
  "\004data\030\013 \001(\0132\022.TSP.DataReference\022\035\n\005style"
  "\030\003 \001(\0132\016.TSP.Reference\022\037\n\014originalSize\030\004"
  " \001(\0132\t.TSP.Size\022\034\n\004mask\030\005 \001(\0132\016.TSP.Refe"
  "rence\022)\n\rthumbnailData\030\014 \001(\0132\022.TSP.DataR"
  "eference\022\r\n\005flags\030\007 \001(\r\022(\n\014originalData\030"
  "\r \001(\0132\022.TSP.DataReference\022\036\n\013naturalSize"
  "\030\t \001(\0132\t.TSP.Size\022#\n\020instantAlphaPath\030\n "
  "\001(\0132\t.TSP.Path\0226\n\020imageAdjustments\030\016 \001(\013"
  "2\034.TSD.ImageAdjustmentsArchive\022-\n\021enhanc"
  "edImageData\030\021 \001(\0132\022.TSP.DataReference\022-\n"
  "\021adjustedImageData\030\017 \001(\0132\022.TSP.DataRefer"
  "ence\0226\n\032thumbnailAdjustedImageData\030\020 \001(\013"
  "2\022.TSP.DataReference\022,\n$interpretsUntagg"
  "edImageDataAsGeneric\030\022 \001(\010\022%\n\rdatabase_d"
  "ata\030\002 \001(\0132\016.TSP.Reference\022.\n\026database_th"
  "umbnailData\030\006 \001(\0132\016.TSP.Reference\022-\n\025dat"
  "abase_originalData\030\010 \001(\0132\016.TSP.Reference"
  "\022\036\n\013traced_path\030\023 \001(\0132\t.TSP.Path\022%\n\013attr"
  "ibution\030\024 \001(\0132\020.TSD.Attribution\022 \n\030shoul"
  "d_trace_pdf_content\030\025 \001(\010\022\032\n\022background_"
  "removed\030\026 \001(\010*\005\010d\020\350\007\"^\n\013MaskArchive\022#\n\005s"
  "uper\030\001 \002(\0132\024.TSD.DrawableArchive\022*\n\npath"
  "source\030\002 \001(\0132\026.TSD.PathSourceArchive\"\317\001\n"
  "\023ImageDataAttributes\022\035\n\npixel_size\030\001 \001(\013"
  "2\t.TSP.Size\022\025\n\rimage_is_srgb\030\002 \001(\010\0224\n,sh"
  "ould_be_interpreted_as_generic_if_untagg"
  "ed\030\003 \001(\0102L\n\025image_data_attributes\022\023.TSP."
  "DataAttributes\030d \001(\0132\030.TSD.ImageDataAttr"
  "ibutes\"\333\010\n\014MovieArchive\022#\n\005super\030\001 \002(\0132\024"
  ".TSD.DrawableArchive\022%\n\tmovieData\030\016 \001(\0132"
  "\022.TSP.DataReference\0226\n\032importedAuxiliary"
  "MovieData\030\026 \001(\0132\022.TSP.DataReference\0227\n/i"
  "mported_auxiliary_movie_data_original_fi"
  "lename\030\031 \001(\t\022\026\n\016movieRemoteURL\030\021 \001(\t\022\021\n\t"
  "startTime\030\003 \001(\002\022\017\n\007endTime\030\004 \001(\002\022\022\n\npost"
  "erTime\030\005 \001(\002\022\037\n\023loopOptionAsInteger\030\006 \001("
  "\rB\002\030\001\022<\n\013loop_option\030\030 \001(\0162!.TSD.MovieAr"
  "chive.MovieLoopOption:\004None\022\016\n\006volume\030\007 "
  "\001(\002\022\024\n\010autoPlay\030\010 \001(\010B\002\030\001\022\021\n\taudioOnly\030\t"
  " \001(\010\022\021\n\tstreaming\030\022 \001(\010\022\034\n\024nativeAudioRe"
  "cording\030\033 \001(\010\022\031\n\021playsAcrossSlides\030\034 \001(\010"
  "\022+\n\017posterImageData\030\017 \001(\0132\022.TSP.DataRefe"
  "rence\022.\n\022audioOnlyImageData\030\020 \001(\0132\022.TSP."
  "DataReference\0221\n)poster_image_generated_"
  "with_alpha_support\030\027 \001(\010\022\025\n\rplayableStat"
  "e\030\014 \001(\r\022\r\n\005flags\030\r \001(\r\022*\n\022database_movie"
  "Data\030\002 \001(\0132\016.TSP.Reference\0220\n\030database_p"
  "osterImageData\030\n \001(\0132\016.TSP.Reference\0223\n\033"
  "database_audioOnlyImageData\030\013 \001(\0132\016.TSP."
  "Reference\022\035\n\005style\030\023 \001(\0132\016.TSP.Reference"
  "\022\037\n\014originalSize\030\024 \001(\0132\t.TSP.Size\022\036\n\013nat"
  "uralSize\030\025 \001(\0132\t.TSP.Size\022%\n\013attribution"
  "\030\032 \001(\0132\020.TSD.Attribution\022*\n\013fingerprint\030"
  "\035 \001(\0132\025.TSD.MovieFingerprint\022\034\n\ris_live_"
  "video\030\036 \001(\010:\005false\"9\n\017MovieLoopOption\022\010\n"
  "\004None\020\000\022\n\n\006Repeat\020\001\022\020\n\014BackAndForth\020\002*\005\010"
  "d\020\350\007\"\213\001\n\027ExteriorTextWrapArchive\022\014\n\004type"
  "\030\001 \001(\r\022\021\n\tdirection\030\002 \001(\r\022\020\n\010fit_type\030\003 "
  "\001(\r\022\016\n\006margin\030\004 \001(\002\022\027\n\017alpha_threshold\030\005"
  " \001(\002\022\024\n\014is_html_wrap\030\006 \001(\010\"\214\001\n\032DrawableC"
  "ontentDescription\022\024\n\014element_kind\030\001 \001(\r\022"
  "\033\n\023is_anchored_to_text\030\002 \001(\010\022\036\n\026is_float"
  "ing_above_text\030\003 \001(\010\022\033\n\023is_inline_with_t"
  "ext\030\004 \001(\010\"{\n!FreehandDrawingContentDescr"
  "iption\022.\n\005super\030\001 \002(\0132\037.TSD.DrawableCont"
  "entDescription\022&\n\036source_doc_wanted_spac"
  "er_shape\030\002 \001(\010\"\321\005\n\035FreehandDrawingToolki"
  "tUIState\022%\n\rcurrent_color\030\001 \001(\0132\n.TSP.Co"
  "lorB\002\030\001\022i\n most_recent_restorable_tool_t"
  "ype\030\002 \001(\0162:.TSD.FreehandDrawingToolkitUI"
  "State.FreehandDrawingToolType:\003Pen\022\030\n\020pe"
  "n_tool_opacity\030\003 \001(\002\022\037\n\027pen_tool_unscale"
  "d_width\030\004 \001(\002\022\033\n\023pencil_tool_opacity\030\005 \001"
  "(\002\022\"\n\032pencil_tool_unscaled_width\030\006 \001(\002\022\033"
  "\n\023crayon_tool_opacity\030\007 \001(\002\022\"\n\032crayon_to"
  "ol_unscaled_width\030\010 \001(\002\022\031\n\021fill_tool_opa"
  "city\030\t \001(\002\022 \n\030eraser_tool_scaled_width\030\n"
  " \001(\002\022(\n eraser_tool_erases_whole_objects"
  "\030\013 \001(\010\022\"\n\016pen_tool_color\030\014 \001(\0132\n.TSP.Col"
  "or\022%\n\021pencil_tool_color\030\r \001(\0132\n.TSP.Colo"
  "r\022%\n\021crayon_tool_color\030\016 \001(\0132\n.TSP.Color"
  "\022#\n\017fill_tool_color\030\017 \001(\0132\n.TSP.Color\"c\n"
  "\027FreehandDrawingToolType\022\007\n\003Pen\020\000\022\n\n\006Pen"
  "cil\020\001\022\n\n\006Crayon\020\002\022\010\n\004Fill\020\003\022\n\n\006Eraser\020\004\022"
  "\021\n\rMarqueeSelect\020\005\"\027\n\025StandinCaptionArch"
  "ive\"\263\001\n\014GuideArchive\022)\n\004type\030\001 \001(\0162\033.TSD"
  ".GuideArchive.GuideType\022\016\n\006offset\030\002 \001(\002\022"
  "\r\n\005start\030\003 \001(\002\022\013\n\003end\030\004 \001(\002\022\017\n\007dynamic\030\005"
  " \001(\010\022\020\n\010infinite\030\006 \001(\010\")\n\tGuideType\022\016\n\nH"
  "orizontal\020\000\022\014\n\010Vertical\020\001\"\214\001\n\027UserDefine"
  "dGuideArchive\0224\n\004type\030\001 \001(\0162&.TSD.UserDe"
  "finedGuideArchive.GuideType\022\020\n\010position\030"
  "\002 \001(\002\")\n\tGuideType\022\016\n\nHorizontal\020\000\022\014\n\010Ve"
  "rtical\020\001\"N\n\023GuideStorageArchive\0227\n\021userD"
  "efinedGuides\030\001 \003(\0132\034.TSD.UserDefinedGuid"
  "eArchive\"\215\001\n\026CanvasSelectionArchive\022\035\n\005i"
  "nfos\030\001 \003(\0132\016.TSP.Reference\022-\n\025non_intera"
  "ctive_infos\030\003 \003(\0132\016.TSP.Reference\022%\n\tcon"
  "tainer\030\002 \001(\0132\016.TSP.ReferenceB\002\030\001\"h\n\030Draw"
  "ableSelectionArchive\022\035\n\005infos\030\002 \003(\0132\016.TS"
  "P.Reference\022-\n\025non_interactive_infos\030\003 \003"
  "(\0132\016.TSP.Reference\"x\n\025GroupSelectionArch"
  "ive\022,\n\005super\030\001 \002(\0132\035.TSD.DrawableSelecti"
  "onArchive\0221\n)has_selected_infos_in_non_g"
  "roup_container\030\002 \001(\010\"\026\n\024PathSelectionArc"
  "hive\"\037\n\035InfoHyperlinkSelectionArchive\"\251\001"
  "\n\025CommentStorageArchive\022\014\n\004text\030\001 \001(\t\022 \n"
  "\rcreation_date\030\002 \001(\0132\t.TSP.Date\022\036\n\006autho"
  "r\030\003 \001(\0132\016.TSP.Reference\022\037\n\007replies\030\004 \003(\013"
  "2\016.TSP.Reference\022\037\n\014storage_uuid\030\005 \001(\0132\t"
  ".TSP.UUID\"\251\001\n%ReplaceAnnotationAuthorCom"
  "mandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK.Command"
  "Archive\022-\n\025old_annotation_author\030\002 \001(\0132\016"
  ".TSP.Reference\022-\n\025new_annotation_author\030"
  "\003 \001(\0132\016.TSP.Reference\"L\n\027PencilAnnotatio"
  "nArchive\0221\n\031pencil_annotation_storage\030\001 "
  "\001(\0132\016.TSP.Reference\"M\n PencilAnnotationS"
  "electionArchive\022)\n\021pencil_annotation\030\001 \001"
  "(\0132\016.TSP.Reference\"\306\007\n\036PencilAnnotationS"
  "torageArchive\022\031\n\021attached_location\030\001 \001(\005"
  "\022!\n\rmarkup_offset\030\002 \001(\0132\n.TSP.Point\022,\n\020r"
  "asterized_image\030\003 \001(\0132\022.TSP.DataReferenc"
  "e\0222\n\026legacy_encoded_drawing\030\004 \001(\0132\022.TSP."
  "DataReference\022\037\n\014drawing_path\030\005 \001(\0132\t.TS"
  "P.Path\022/\n\033strokes_bounding_box_origin\030\006 "
  "\001(\0132\n.TSP.Point\022,\n\031strokes_bounding_box_"
  "size\030\007 \001(\0132\t.TSP.Size\022\025\n\rattached_type\030\010"
  " \001(\005\022)\n\026original_attached_size\030\t \001(\0132\t.T"
  "SP.Size\022-\n%percent_of_pa_contained_in_pa"
  "rent_rep\030\n \001(\001\022$\n\034text_baselines_touched"
  "_count\030\013 \001(\004\022\035\n\025visible_strokes_count\030\014 "
  "\001(\004\022\035\n\tpen_color\030\r \001(\0132\n.TSP.Color\022\021\n\tto"
  "ol_type\030\016 \001(\005\022,\n\024callout_sub_storages\030\017 "
  "\003(\0132\016.TSP.Reference\022 \n\rcreation_date\030\020 \001"
  "(\0132\t.TSP.Date\022\'\n\037pencil_annotation_drawi"
  "ng_scale\030\021 \001(\001\022 \n\030compound_annotation_ty"
  "pe\030\022 \001(\005\022$\n\014sub_storages\030\023 \003(\0132\016.TSP.Ref"
  "erence\022+\n\017encoded_drawing\030\024 \001(\0132\022.TSP.Da"
  "taReference\022.\n\032stroke_points_frame_origi"
  "n\030\025 \001(\0132\n.TSP.Point\022+\n\030stroke_points_fra"
  "me_size\030\026 \001(\0132\t.TSP.Size\022)\n\025rendered_fra"
  "me_origin\030\027 \001(\0132\n.TSP.Point\022&\n\023rendered_"
  "frame_size\030\030 \001(\0132\t.TSP.Size\"9\n\034SpecColor"
  "FillSetColorArchive\022\031\n\005color\030\001 \002(\0132\n.TSP"
  ".Color\"4\n\035SpecFrameSetAssetScaleArchive\022"
  "\023\n\013asset_scale\030\001 \002(\001\"0\n\037SpecGradientFill"
  "SetAngleArchive\022\r\n\005angle\030\001 \002(\001\"5\n SpecIm"
  "ageFillSetTechniqueArchive\022\021\n\ttechnique\030"
  "\001 \002(\005\"2\n\037SpecReflectionSetOpacityArchive"
  "\022\017\n\007opacity\030\001 \002(\001\"*\n\031SpecShadowSetAngleA"
  "rchive\022\r\n\005angle\030\001 \002(\001\"6\n\031SpecShadowSetCo"
  "lorArchive\022\031\n\005color\030\001 \002(\0132\n.TSP.Color\",\n"
  "\032SpecShadowSetOffsetArchive\022\016\n\006offset\030\001 "
  "\002(\001\".\n\033SpecShadowSetOpacityArchive\022\017\n\007op"
  "acity\030\001 \002(\001\",\n\032SpecShadowSetRadiusArchiv"
  "e\022\016\n\006radius\030\001 \002(\005\"6\n\031SpecStrokeSetColorA"
  "rchive\022\031\n\005color\030\001 \002(\0132\n.TSP.Color\"\255\001\n\033Sp"
  "ecStrokeSetPatternArchive\022\020\n\010line_cap\030\001 "
  "\001(\005\022\021\n\tline_join\030\002 \001(\005\022\023\n\013miter_limit\030\003 "
  "\001(\001\022\r\n\005width\030\004 \001(\001\022\031\n\005color\030\005 \001(\0132\n.TSP."
  "Color\022*\n\007pattern\030\006 \002(\0132\031.TSD.StrokePatte"
  "rnArchive\"*\n\031SpecStrokeSetWidthArchive\022\r"
  "\n\005width\030\001 \002(\001\"u\n\013Attribution\022\r\n\005title\030\001 "
  "\001(\t\022\030\n\020description_text\030\002 \001(\t\022\024\n\014externa"
  "l_url\030\003 \001(\t\022\023\n\013author_name\030\004 \001(\t\022\022\n\nauth"
  "or_url\030\005 \001(\t\"S\n\020MovieFingerprint\022*\n\006trac"
  "ks\030\001 \003(\0132\032.TSD.MovieFingerprintTrack\022\023\n\007"
  "version\030\002 \003(\rB\002\020\001\"\205\005\n\025MovieFingerprintTr"
  "ack\022\022\n\nmedia_type\030\001 \001(\t\022\017\n\007enabled\030\002 \001(\010"
  "\022 \n\030total_sample_data_length\030\003 \001(\003\022!\n\031sa"
  "mple_data_digest_string\030\004 \001(\t\022\036\n\026time_ra"
  "nge_start_value\030\005 \001(\003\022\"\n\032time_range_star"
  "t_timescale\030\006 \001(\005\022!\n\031time_range_start_is"
  "_valid\030\007 \001(\010\022!\n\031time_range_duration_valu"
  "e\030\010 \001(\003\022%\n\035time_range_duration_timescale"
  "\030\t \001(\005\022$\n\034time_range_duration_is_valid\030\n"
  " \001(\010\022\037\n\014natural_size\030\013 \001(\0132\t.TSP.Size\022\035\n"
  "\025preferred_transform_a\030\014 \001(\001\022\035\n\025preferre"
  "d_transform_b\030\r \001(\001\022\035\n\025preferred_transfo"
  "rm_c\030\016 \001(\001\022\035\n\025preferred_transform_d\030\017 \001("
  "\001\022\036\n\026preferred_transform_tx\030\020 \001(\001\022\036\n\026pre"
  "ferred_transform_ty\030\021 \001(\001\022\030\n\020preferred_v"
  "olume\030\022 \001(\001\022\025\n\rlanguage_code\030\023 \001(\t\022\035\n\025ex"
  "tended_language_tag\030\024 \001(\t*7\n\010LineJoin\022\r\n"
  "\tMiterJoin\020\000\022\r\n\tRoundJoin\020\001\022\r\n\tBevelJoin"
  "\020\002:A\n\004fill\022 .TSS.CommandPropertyEntryArc"
  "hive\030\310\001 \001(\0132\020.TSD.FillArchive:E\n\006stroke\022"
  " .TSS.CommandPropertyEntryArchive\030\311\001 \001(\013"
  "2\022.TSD.StrokeArchive"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_TSDArchives_2eproto_deps[3] = {
  &::descriptor_table_TSKArchives_2eproto,
  &::descriptor_table_TSPMessages_2eproto,
  &::descriptor_table_TSSArchives_2eproto,
};
static ::_pbi::once_flag descriptor_table_TSDArchives_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_TSDArchives_2eproto = {
    false, false, 15980, descriptor_table_protodef_TSDArchives_2eproto,
    "TSDArchives.proto",
    &descriptor_table_TSDArchives_2eproto_once, descriptor_table_TSDArchives_2eproto_deps, 3, 80,
    schemas, file_default_instances, TableStruct_TSDArchives_2eproto::offsets,
    file_level_metadata_TSDArchives_2eproto, file_level_enum_descriptors_TSDArchives_2eproto,
    file_level_service_descriptors_TSDArchives_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_TSDArchives_2eproto_getter() {
  return &descriptor_table_TSDArchives_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_TSDArchives_2eproto(&descriptor_table_TSDArchives_2eproto);
namespace TSD {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PointPathSourceArchive_PointPathSourceType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[0];
}
bool PointPathSourceArchive_PointPathSourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 10:
    case 100:
    case 200:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::kTSDLeftSingleArrow;
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::kTSDRightSingleArrow;
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::kTSDDoubleArrow;
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::kTSDStar;
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::kTSDPlus;
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::PointPathSourceType_MIN;
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::PointPathSourceType_MAX;
constexpr int PointPathSourceArchive::PointPathSourceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScalarPathSourceArchive_ScalarPathSourceType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[1];
}
bool ScalarPathSourceArchive_ScalarPathSourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive::kTSDRoundedRectangle;
constexpr ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive::kTSDRegularPolygon;
constexpr ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive::kTSDChevron;
constexpr ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive::ScalarPathSourceType_MIN;
constexpr ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive::ScalarPathSourceType_MAX;
constexpr int ScalarPathSourceArchive::ScalarPathSourceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[2];
}
bool ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive::kTSDConnectionLineTypeQuadratic;
constexpr ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive::kTSDConnectionLineTypeOrthogonal;
constexpr ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive::ConnectionLinePathSourceType_MIN;
constexpr ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive::ConnectionLinePathSourceType_MAX;
constexpr int ConnectionLinePathSourceArchive::ConnectionLinePathSourceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EditableBezierPathSourceArchive_NodeType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[3];
}
bool EditableBezierPathSourceArchive_NodeType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive::sharp;
constexpr EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive::bezier;
constexpr EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive::smooth;
constexpr EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive::NodeType_MIN;
constexpr EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive::NodeType_MAX;
constexpr int EditableBezierPathSourceArchive::NodeType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GradientArchive_GradientType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[4];
}
bool GradientArchive_GradientType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GradientArchive_GradientType GradientArchive::Linear;
constexpr GradientArchive_GradientType GradientArchive::Radial;
constexpr GradientArchive_GradientType GradientArchive::GradientType_MIN;
constexpr GradientArchive_GradientType GradientArchive::GradientType_MAX;
constexpr int GradientArchive::GradientType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageFillArchive_ImageFillTechnique_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[5];
}
bool ImageFillArchive_ImageFillTechnique_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive::NaturalSize;
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive::Stretch;
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive::Tile;
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive::ScaleToFill;
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive::ScaleToFit;
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive::ImageFillTechnique_MIN;
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive::ImageFillTechnique_MAX;
constexpr int ImageFillArchive::ImageFillTechnique_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StrokePatternArchive_StrokePatternType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[6];
}
bool StrokePatternArchive_StrokePatternType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr StrokePatternArchive_StrokePatternType StrokePatternArchive::TSDPattern;
constexpr StrokePatternArchive_StrokePatternType StrokePatternArchive::TSDSolidPattern;
constexpr StrokePatternArchive_StrokePatternType StrokePatternArchive::TSDEmptyPattern;
constexpr StrokePatternArchive_StrokePatternType StrokePatternArchive::StrokePatternType_MIN;
constexpr StrokePatternArchive_StrokePatternType StrokePatternArchive::StrokePatternType_MAX;
constexpr int StrokePatternArchive::StrokePatternType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StrokeArchive_LineCap_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[7];
}
bool StrokeArchive_LineCap_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr StrokeArchive_LineCap StrokeArchive::ButtCap;
constexpr StrokeArchive_LineCap StrokeArchive::RoundCap;
constexpr StrokeArchive_LineCap StrokeArchive::SquareCap;
constexpr StrokeArchive_LineCap StrokeArchive::LineCap_MIN;
constexpr StrokeArchive_LineCap StrokeArchive::LineCap_MAX;
constexpr int StrokeArchive::LineCap_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShadowArchive_ShadowType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[8];
}
bool ShadowArchive_ShadowType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ShadowArchive_ShadowType ShadowArchive::TSDDropShadow;
constexpr ShadowArchive_ShadowType ShadowArchive::TSDContactShadow;
constexpr ShadowArchive_ShadowType ShadowArchive::TSDCurvedShadow;
constexpr ShadowArchive_ShadowType ShadowArchive::ShadowType_MIN;
constexpr ShadowArchive_ShadowType ShadowArchive::ShadowType_MAX;
constexpr int ShadowArchive::ShadowType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MovieArchive_MovieLoopOption_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[9];
}
bool MovieArchive_MovieLoopOption_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MovieArchive_MovieLoopOption MovieArchive::None;
constexpr MovieArchive_MovieLoopOption MovieArchive::Repeat;
constexpr MovieArchive_MovieLoopOption MovieArchive::BackAndForth;
constexpr MovieArchive_MovieLoopOption MovieArchive::MovieLoopOption_MIN;
constexpr MovieArchive_MovieLoopOption MovieArchive::MovieLoopOption_MAX;
constexpr int MovieArchive::MovieLoopOption_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FreehandDrawingToolkitUIState_FreehandDrawingToolType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[10];
}
bool FreehandDrawingToolkitUIState_FreehandDrawingToolType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr FreehandDrawingToolkitUIState_FreehandDrawingToolType FreehandDrawingToolkitUIState::Pen;
constexpr FreehandDrawingToolkitUIState_FreehandDrawingToolType FreehandDrawingToolkitUIState::Pencil;
constexpr FreehandDrawingToolkitUIState_FreehandDrawingToolType FreehandDrawingToolkitUIState::Crayon;
constexpr FreehandDrawingToolkitUIState_FreehandDrawingToolType FreehandDrawingToolkitUIState::Fill;
constexpr FreehandDrawingToolkitUIState_FreehandDrawingToolType FreehandDrawingToolkitUIState::Eraser;
constexpr FreehandDrawingToolkitUIState_FreehandDrawingToolType FreehandDrawingToolkitUIState::MarqueeSelect;
constexpr FreehandDrawingToolkitUIState_FreehandDrawingToolType FreehandDrawingToolkitUIState::FreehandDrawingToolType_MIN;
constexpr FreehandDrawingToolkitUIState_FreehandDrawingToolType FreehandDrawingToolkitUIState::FreehandDrawingToolType_MAX;
constexpr int FreehandDrawingToolkitUIState::FreehandDrawingToolType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GuideArchive_GuideType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[11];
}
bool GuideArchive_GuideType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GuideArchive_GuideType GuideArchive::Horizontal;
constexpr GuideArchive_GuideType GuideArchive::Vertical;
constexpr GuideArchive_GuideType GuideArchive::GuideType_MIN;
constexpr GuideArchive_GuideType GuideArchive::GuideType_MAX;
constexpr int GuideArchive::GuideType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserDefinedGuideArchive_GuideType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[12];
}
bool UserDefinedGuideArchive_GuideType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UserDefinedGuideArchive_GuideType UserDefinedGuideArchive::Horizontal;
constexpr UserDefinedGuideArchive_GuideType UserDefinedGuideArchive::Vertical;
constexpr UserDefinedGuideArchive_GuideType UserDefinedGuideArchive::GuideType_MIN;
constexpr UserDefinedGuideArchive_GuideType UserDefinedGuideArchive::GuideType_MAX;
constexpr int UserDefinedGuideArchive::GuideType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LineJoin_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[13];
}
bool LineJoin_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class EdgeInsetsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<EdgeInsetsArchive>()._impl_._has_bits_);
  static void set_has_top(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_left(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bottom(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_right(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

EdgeInsetsArchive::EdgeInsetsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.EdgeInsetsArchive)
}
EdgeInsetsArchive::EdgeInsetsArchive(const EdgeInsetsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EdgeInsetsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.top_){}
    , decltype(_impl_.left_){}
    , decltype(_impl_.bottom_){}
    , decltype(_impl_.right_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.top_, &from._impl_.top_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.right_) -
    reinterpret_cast<char*>(&_impl_.top_)) + sizeof(_impl_.right_));
  // @@protoc_insertion_point(copy_constructor:TSD.EdgeInsetsArchive)
}

inline void EdgeInsetsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.top_){0}
    , decltype(_impl_.left_){0}
    , decltype(_impl_.bottom_){0}
    , decltype(_impl_.right_){0}
  };
}

EdgeInsetsArchive::~EdgeInsetsArchive() {
  // @@protoc_insertion_point(destructor:TSD.EdgeInsetsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EdgeInsetsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EdgeInsetsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EdgeInsetsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.EdgeInsetsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.top_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.right_) -
        reinterpret_cast<char*>(&_impl_.top_)) + sizeof(_impl_.right_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EdgeInsetsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required float top = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_top(&has_bits);
          _impl_.top_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float left = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_left(&has_bits);
          _impl_.left_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float bottom = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_bottom(&has_bits);
          _impl_.bottom_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float right = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_right(&has_bits);
          _impl_.right_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EdgeInsetsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.EdgeInsetsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required float top = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_top(), target);
  }

  // required float left = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_left(), target);
  }

  // required float bottom = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_bottom(), target);
  }

  // required float right = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_right(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.EdgeInsetsArchive)
  return target;
}

size_t EdgeInsetsArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSD.EdgeInsetsArchive)
  size_t total_size = 0;

  if (_internal_has_top()) {
    // required float top = 1;
    total_size += 1 + 4;
  }

  if (_internal_has_left()) {
    // required float left = 2;
    total_size += 1 + 4;
  }

  if (_internal_has_bottom()) {
    // required float bottom = 3;
    total_size += 1 + 4;
  }

  if (_internal_has_right()) {
    // required float right = 4;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t EdgeInsetsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.EdgeInsetsArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required float top = 1;
    total_size += 1 + 4;

    // required float left = 2;
    total_size += 1 + 4;

    // required float bottom = 3;
    total_size += 1 + 4;

    // required float right = 4;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EdgeInsetsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EdgeInsetsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EdgeInsetsArchive::GetClassData() const { return &_class_data_; }


void EdgeInsetsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EdgeInsetsArchive*>(&to_msg);
  auto& from = static_cast<const EdgeInsetsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.EdgeInsetsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.top_ = from._impl_.top_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.left_ = from._impl_.left_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.bottom_ = from._impl_.bottom_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.right_ = from._impl_.right_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EdgeInsetsArchive::CopyFrom(const EdgeInsetsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.EdgeInsetsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EdgeInsetsArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void EdgeInsetsArchive::InternalSwap(EdgeInsetsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EdgeInsetsArchive, _impl_.right_)
      + sizeof(EdgeInsetsArchive::_impl_.right_)
      - PROTOBUF_FIELD_OFFSET(EdgeInsetsArchive, _impl_.top_)>(
          reinterpret_cast<char*>(&_impl_.top_),
          reinterpret_cast<char*>(&other->_impl_.top_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EdgeInsetsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[0]);
}

// ===================================================================

class GeometryArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<GeometryArchive>()._impl_._has_bits_);
  static const ::TSP::Point& position(const GeometryArchive* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Size& size(const GeometryArchive* msg);
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::TSP::Point&
GeometryArchive::_Internal::position(const GeometryArchive* msg) {
  return *msg->_impl_.position_;
}
const ::TSP::Size&
GeometryArchive::_Internal::size(const GeometryArchive* msg) {
  return *msg->_impl_.size_;
}
void GeometryArchive::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void GeometryArchive::clear_size() {
  if (_impl_.size_ != nullptr) _impl_.size_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
GeometryArchive::GeometryArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.GeometryArchive)
}
GeometryArchive::GeometryArchive(const GeometryArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GeometryArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.size_){nullptr}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.angle_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::TSP::Point(*from._impl_.position_);
  }
  if (from._internal_has_size()) {
    _this->_impl_.size_ = new ::TSP::Size(*from._impl_.size_);
  }
  ::memcpy(&_impl_.flags_, &from._impl_.flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.angle_) -
    reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.angle_));
  // @@protoc_insertion_point(copy_constructor:TSD.GeometryArchive)
}

inline void GeometryArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.size_){nullptr}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.angle_){0}
  };
}

GeometryArchive::~GeometryArchive() {
  // @@protoc_insertion_point(destructor:TSD.GeometryArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GeometryArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.size_;
}

void GeometryArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GeometryArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.GeometryArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.size_ != nullptr);
      _impl_.size_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.angle_) -
        reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.angle_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GeometryArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Point position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float angle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_angle(&has_bits);
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GeometryArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.GeometryArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Point position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::size(this),
        _Internal::size(this).GetCachedSize(), target, stream);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_flags(), target);
  }

  // optional float angle = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.GeometryArchive)
  return target;
}

size_t GeometryArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.GeometryArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .TSP.Point position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // optional .TSP.Size size = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.size_);
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional float angle = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GeometryArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GeometryArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GeometryArchive::GetClassData() const { return &_class_data_; }


void GeometryArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GeometryArchive*>(&to_msg);
  auto& from = static_cast<const GeometryArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.GeometryArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::TSP::Point::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_size()->::TSP::Size::MergeFrom(
          from._internal_size());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.angle_ = from._impl_.angle_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GeometryArchive::CopyFrom(const GeometryArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.GeometryArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeometryArchive::IsInitialized() const {
  if (_internal_has_position()) {
    if (!_impl_.position_->IsInitialized()) return false;
  }
  if (_internal_has_size()) {
    if (!_impl_.size_->IsInitialized()) return false;
  }
  return true;
}

void GeometryArchive::InternalSwap(GeometryArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GeometryArchive, _impl_.angle_)
      + sizeof(GeometryArchive::_impl_.angle_)
      - PROTOBUF_FIELD_OFFSET(GeometryArchive, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GeometryArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[1]);
}

// ===================================================================

class PointPathSourceArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PointPathSourceArchive>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Point& point(const PointPathSourceArchive* msg);
  static void set_has_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Size& naturalsize(const PointPathSourceArchive* msg);
  static void set_has_naturalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSP::Point&
PointPathSourceArchive::_Internal::point(const PointPathSourceArchive* msg) {
  return *msg->_impl_.point_;
}
const ::TSP::Size&
PointPathSourceArchive::_Internal::naturalsize(const PointPathSourceArchive* msg) {
  return *msg->_impl_.naturalsize_;
}
void PointPathSourceArchive::clear_point() {
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PointPathSourceArchive::clear_naturalsize() {
  if (_impl_.naturalsize_ != nullptr) _impl_.naturalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
PointPathSourceArchive::PointPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.PointPathSourceArchive)
}
PointPathSourceArchive::PointPathSourceArchive(const PointPathSourceArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PointPathSourceArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_point()) {
    _this->_impl_.point_ = new ::TSP::Point(*from._impl_.point_);
  }
  if (from._internal_has_naturalsize()) {
    _this->_impl_.naturalsize_ = new ::TSP::Size(*from._impl_.naturalsize_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:TSD.PointPathSourceArchive)
}

inline void PointPathSourceArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.type_){0}
  };
}

PointPathSourceArchive::~PointPathSourceArchive() {
  // @@protoc_insertion_point(destructor:TSD.PointPathSourceArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PointPathSourceArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.point_;
  if (this != internal_default_instance()) delete _impl_.naturalsize_;
}

void PointPathSourceArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PointPathSourceArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.PointPathSourceArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.point_ != nullptr);
      _impl_.point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.naturalsize_ != nullptr);
      _impl_.naturalsize_->Clear();
    }
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PointPathSourceArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.PointPathSourceArchive.PointPathSourceType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::PointPathSourceArchive_PointPathSourceType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::PointPathSourceArchive_PointPathSourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Point point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size naturalSize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_naturalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PointPathSourceArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.PointPathSourceArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.PointPathSourceArchive.PointPathSourceType type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional .TSP.Point point = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::point(this),
        _Internal::point(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size naturalSize = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::naturalsize(this),
        _Internal::naturalsize(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.PointPathSourceArchive)
  return target;
}

size_t PointPathSourceArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.PointPathSourceArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSP.Point point = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.point_);
    }

    // optional .TSP.Size naturalSize = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.naturalsize_);
    }

    // optional .TSD.PointPathSourceArchive.PointPathSourceType type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointPathSourceArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PointPathSourceArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointPathSourceArchive::GetClassData() const { return &_class_data_; }


void PointPathSourceArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PointPathSourceArchive*>(&to_msg);
  auto& from = static_cast<const PointPathSourceArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.PointPathSourceArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_point()->::TSP::Point::MergeFrom(
          from._internal_point());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_naturalsize()->::TSP::Size::MergeFrom(
          from._internal_naturalsize());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PointPathSourceArchive::CopyFrom(const PointPathSourceArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.PointPathSourceArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointPathSourceArchive::IsInitialized() const {
  if (_internal_has_point()) {
    if (!_impl_.point_->IsInitialized()) return false;
  }
  if (_internal_has_naturalsize()) {
    if (!_impl_.naturalsize_->IsInitialized()) return false;
  }
  return true;
}

void PointPathSourceArchive::InternalSwap(PointPathSourceArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PointPathSourceArchive, _impl_.type_)
      + sizeof(PointPathSourceArchive::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(PointPathSourceArchive, _impl_.point_)>(
          reinterpret_cast<char*>(&_impl_.point_),
          reinterpret_cast<char*>(&other->_impl_.point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PointPathSourceArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[2]);
}

// ===================================================================

class ScalarPathSourceArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ScalarPathSourceArchive>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_scalar(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Size& naturalsize(const ScalarPathSourceArchive* msg);
  static void set_has_naturalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_curve_continuous(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::TSP::Size&
ScalarPathSourceArchive::_Internal::naturalsize(const ScalarPathSourceArchive* msg) {
  return *msg->_impl_.naturalsize_;
}
void ScalarPathSourceArchive::clear_naturalsize() {
  if (_impl_.naturalsize_ != nullptr) _impl_.naturalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ScalarPathSourceArchive::ScalarPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ScalarPathSourceArchive)
}
ScalarPathSourceArchive::ScalarPathSourceArchive(const ScalarPathSourceArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ScalarPathSourceArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.scalar_){}
    , decltype(_impl_.is_curve_continuous_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_naturalsize()) {
    _this->_impl_.naturalsize_ = new ::TSP::Size(*from._impl_.naturalsize_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_curve_continuous_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.is_curve_continuous_));
  // @@protoc_insertion_point(copy_constructor:TSD.ScalarPathSourceArchive)
}

inline void ScalarPathSourceArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.scalar_){0}
    , decltype(_impl_.is_curve_continuous_){false}
  };
}

ScalarPathSourceArchive::~ScalarPathSourceArchive() {
  // @@protoc_insertion_point(destructor:TSD.ScalarPathSourceArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScalarPathSourceArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.naturalsize_;
}

void ScalarPathSourceArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ScalarPathSourceArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ScalarPathSourceArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.naturalsize_ != nullptr);
    _impl_.naturalsize_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_curve_continuous_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.is_curve_continuous_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ScalarPathSourceArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.ScalarPathSourceArchive.ScalarPathSourceType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::ScalarPathSourceArchive_ScalarPathSourceType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::ScalarPathSourceArchive_ScalarPathSourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float scalar = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_scalar(&has_bits);
          _impl_.scalar_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size naturalSize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_naturalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_curve_continuous = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_curve_continuous(&has_bits);
          _impl_.is_curve_continuous_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScalarPathSourceArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ScalarPathSourceArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.ScalarPathSourceArchive.ScalarPathSourceType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional float scalar = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_scalar(), target);
  }

  // optional .TSP.Size naturalSize = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::naturalsize(this),
        _Internal::naturalsize(this).GetCachedSize(), target, stream);
  }

  // optional bool is_curve_continuous = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_curve_continuous(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ScalarPathSourceArchive)
  return target;
}

size_t ScalarPathSourceArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ScalarPathSourceArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .TSP.Size naturalSize = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.naturalsize_);
    }

    // optional .TSD.ScalarPathSourceArchive.ScalarPathSourceType type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional float scalar = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional bool is_curve_continuous = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ScalarPathSourceArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ScalarPathSourceArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ScalarPathSourceArchive::GetClassData() const { return &_class_data_; }


void ScalarPathSourceArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ScalarPathSourceArchive*>(&to_msg);
  auto& from = static_cast<const ScalarPathSourceArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ScalarPathSourceArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_naturalsize()->::TSP::Size::MergeFrom(
          from._internal_naturalsize());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.scalar_ = from._impl_.scalar_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_curve_continuous_ = from._impl_.is_curve_continuous_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ScalarPathSourceArchive::CopyFrom(const ScalarPathSourceArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ScalarPathSourceArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScalarPathSourceArchive::IsInitialized() const {
  if (_internal_has_naturalsize()) {
    if (!_impl_.naturalsize_->IsInitialized()) return false;
  }
  return true;
}

void ScalarPathSourceArchive::InternalSwap(ScalarPathSourceArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScalarPathSourceArchive, _impl_.is_curve_continuous_)
      + sizeof(ScalarPathSourceArchive::_impl_.is_curve_continuous_)
      - PROTOBUF_FIELD_OFFSET(ScalarPathSourceArchive, _impl_.naturalsize_)>(
          reinterpret_cast<char*>(&_impl_.naturalsize_),
          reinterpret_cast<char*>(&other->_impl_.naturalsize_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ScalarPathSourceArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[3]);
}

// ===================================================================

class BezierPathSourceArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<BezierPathSourceArchive>()._impl_._has_bits_);
  static void set_has_path_string(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Size& naturalsize(const BezierPathSourceArchive* msg);
  static void set_has_naturalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Path& path(const BezierPathSourceArchive* msg);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSP::Size&
BezierPathSourceArchive::_Internal::naturalsize(const BezierPathSourceArchive* msg) {
  return *msg->_impl_.naturalsize_;
}
const ::TSP::Path&
BezierPathSourceArchive::_Internal::path(const BezierPathSourceArchive* msg) {
  return *msg->_impl_.path_;
}
void BezierPathSourceArchive::clear_naturalsize() {
  if (_impl_.naturalsize_ != nullptr) _impl_.naturalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void BezierPathSourceArchive::clear_path() {
  if (_impl_.path_ != nullptr) _impl_.path_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
BezierPathSourceArchive::BezierPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.BezierPathSourceArchive)
}
BezierPathSourceArchive::BezierPathSourceArchive(const BezierPathSourceArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BezierPathSourceArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_string_){}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.path_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path_string()) {
    _this->_impl_.path_string_.Set(from._internal_path_string(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_naturalsize()) {
    _this->_impl_.naturalsize_ = new ::TSP::Size(*from._impl_.naturalsize_);
  }
  if (from._internal_has_path()) {
    _this->_impl_.path_ = new ::TSP::Path(*from._impl_.path_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.BezierPathSourceArchive)
}

inline void BezierPathSourceArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_string_){}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.path_){nullptr}
  };
  _impl_.path_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BezierPathSourceArchive::~BezierPathSourceArchive() {
  // @@protoc_insertion_point(destructor:TSD.BezierPathSourceArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BezierPathSourceArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_string_.Destroy();
  if (this != internal_default_instance()) delete _impl_.naturalsize_;
  if (this != internal_default_instance()) delete _impl_.path_;
}

void BezierPathSourceArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BezierPathSourceArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.BezierPathSourceArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.path_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.naturalsize_ != nullptr);
      _impl_.naturalsize_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.path_ != nullptr);
      _impl_.path_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BezierPathSourceArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string path_string = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.BezierPathSourceArchive.path_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size naturalSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_naturalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Path path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BezierPathSourceArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.BezierPathSourceArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string path_string = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_path_string().data(), static_cast<int>(this->_internal_path_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.BezierPathSourceArchive.path_string");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path_string(), target);
  }

  // optional .TSP.Size naturalSize = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::naturalsize(this),
        _Internal::naturalsize(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Path path = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::path(this),
        _Internal::path(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.BezierPathSourceArchive)
  return target;
}

size_t BezierPathSourceArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.BezierPathSourceArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string path_string = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_path_string());
    }

    // optional .TSP.Size naturalSize = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.naturalsize_);
    }

    // optional .TSP.Path path = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.path_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BezierPathSourceArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BezierPathSourceArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BezierPathSourceArchive::GetClassData() const { return &_class_data_; }


void BezierPathSourceArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BezierPathSourceArchive*>(&to_msg);
  auto& from = static_cast<const BezierPathSourceArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.BezierPathSourceArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_path_string(from._internal_path_string());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_naturalsize()->::TSP::Size::MergeFrom(
          from._internal_naturalsize());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_path()->::TSP::Path::MergeFrom(
          from._internal_path());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BezierPathSourceArchive::CopyFrom(const BezierPathSourceArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.BezierPathSourceArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BezierPathSourceArchive::IsInitialized() const {
  if (_internal_has_naturalsize()) {
    if (!_impl_.naturalsize_->IsInitialized()) return false;
  }
  if (_internal_has_path()) {
    if (!_impl_.path_->IsInitialized()) return false;
  }
  return true;
}

void BezierPathSourceArchive::InternalSwap(BezierPathSourceArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_string_, lhs_arena,
      &other->_impl_.path_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BezierPathSourceArchive, _impl_.path_)
      + sizeof(BezierPathSourceArchive::_impl_.path_)
      - PROTOBUF_FIELD_OFFSET(BezierPathSourceArchive, _impl_.naturalsize_)>(
          reinterpret_cast<char*>(&_impl_.naturalsize_),
          reinterpret_cast<char*>(&other->_impl_.naturalsize_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BezierPathSourceArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[4]);
}

// ===================================================================

class CalloutPathSourceArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CalloutPathSourceArchive>()._impl_._has_bits_);
  static const ::TSP::Size& natural_size(const CalloutPathSourceArchive* msg);
  static void set_has_natural_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Point& tail_position(const CalloutPathSourceArchive* msg);
  static void set_has_tail_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tail_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_corner_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_center_tail(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::TSP::Size&
CalloutPathSourceArchive::_Internal::natural_size(const CalloutPathSourceArchive* msg) {
  return *msg->_impl_.natural_size_;
}
const ::TSP::Point&
CalloutPathSourceArchive::_Internal::tail_position(const CalloutPathSourceArchive* msg) {
  return *msg->_impl_.tail_position_;
}
void CalloutPathSourceArchive::clear_natural_size() {
  if (_impl_.natural_size_ != nullptr) _impl_.natural_size_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CalloutPathSourceArchive::clear_tail_position() {
  if (_impl_.tail_position_ != nullptr) _impl_.tail_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CalloutPathSourceArchive::CalloutPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.CalloutPathSourceArchive)
}
CalloutPathSourceArchive::CalloutPathSourceArchive(const CalloutPathSourceArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CalloutPathSourceArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.natural_size_){nullptr}
    , decltype(_impl_.tail_position_){nullptr}
    , decltype(_impl_.tail_size_){}
    , decltype(_impl_.corner_radius_){}
    , decltype(_impl_.center_tail_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_natural_size()) {
    _this->_impl_.natural_size_ = new ::TSP::Size(*from._impl_.natural_size_);
  }
  if (from._internal_has_tail_position()) {
    _this->_impl_.tail_position_ = new ::TSP::Point(*from._impl_.tail_position_);
  }
  ::memcpy(&_impl_.tail_size_, &from._impl_.tail_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.center_tail_) -
    reinterpret_cast<char*>(&_impl_.tail_size_)) + sizeof(_impl_.center_tail_));
  // @@protoc_insertion_point(copy_constructor:TSD.CalloutPathSourceArchive)
}

inline void CalloutPathSourceArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.natural_size_){nullptr}
    , decltype(_impl_.tail_position_){nullptr}
    , decltype(_impl_.tail_size_){0}
    , decltype(_impl_.corner_radius_){0}
    , decltype(_impl_.center_tail_){false}
  };
}

CalloutPathSourceArchive::~CalloutPathSourceArchive() {
  // @@protoc_insertion_point(destructor:TSD.CalloutPathSourceArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CalloutPathSourceArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.natural_size_;
  if (this != internal_default_instance()) delete _impl_.tail_position_;
}

void CalloutPathSourceArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CalloutPathSourceArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.CalloutPathSourceArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.natural_size_ != nullptr);
      _impl_.natural_size_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.tail_position_ != nullptr);
      _impl_.tail_position_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.tail_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.center_tail_) -
        reinterpret_cast<char*>(&_impl_.tail_size_)) + sizeof(_impl_.center_tail_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CalloutPathSourceArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Size natural_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_natural_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Point tail_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tail_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float tail_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_tail_size(&has_bits);
          _impl_.tail_size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float corner_radius = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_corner_radius(&has_bits);
          _impl_.corner_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool center_tail = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_center_tail(&has_bits);
          _impl_.center_tail_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CalloutPathSourceArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.CalloutPathSourceArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Size natural_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::natural_size(this),
        _Internal::natural_size(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Point tail_position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::tail_position(this),
        _Internal::tail_position(this).GetCachedSize(), target, stream);
  }

  // optional float tail_size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_tail_size(), target);
  }

  // optional float corner_radius = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_corner_radius(), target);
  }

  // optional bool center_tail = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_center_tail(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.CalloutPathSourceArchive)
  return target;
}

size_t CalloutPathSourceArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.CalloutPathSourceArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSP.Size natural_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.natural_size_);
    }

    // optional .TSP.Point tail_position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tail_position_);
    }

    // optional float tail_size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float corner_radius = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional bool center_tail = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CalloutPathSourceArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CalloutPathSourceArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CalloutPathSourceArchive::GetClassData() const { return &_class_data_; }


void CalloutPathSourceArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CalloutPathSourceArchive*>(&to_msg);
  auto& from = static_cast<const CalloutPathSourceArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.CalloutPathSourceArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_natural_size()->::TSP::Size::MergeFrom(
          from._internal_natural_size());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_tail_position()->::TSP::Point::MergeFrom(
          from._internal_tail_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.tail_size_ = from._impl_.tail_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.corner_radius_ = from._impl_.corner_radius_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.center_tail_ = from._impl_.center_tail_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CalloutPathSourceArchive::CopyFrom(const CalloutPathSourceArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.CalloutPathSourceArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CalloutPathSourceArchive::IsInitialized() const {
  if (_internal_has_natural_size()) {
    if (!_impl_.natural_size_->IsInitialized()) return false;
  }
  if (_internal_has_tail_position()) {
    if (!_impl_.tail_position_->IsInitialized()) return false;
  }
  return true;
}

void CalloutPathSourceArchive::InternalSwap(CalloutPathSourceArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CalloutPathSourceArchive, _impl_.center_tail_)
      + sizeof(CalloutPathSourceArchive::_impl_.center_tail_)
      - PROTOBUF_FIELD_OFFSET(CalloutPathSourceArchive, _impl_.natural_size_)>(
          reinterpret_cast<char*>(&_impl_.natural_size_),
          reinterpret_cast<char*>(&other->_impl_.natural_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CalloutPathSourceArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[5]);
}

// ===================================================================

class ConnectionLinePathSourceArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionLinePathSourceArchive>()._impl_._has_bits_);
  static const ::TSD::BezierPathSourceArchive& super(const ConnectionLinePathSourceArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_outset_from(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_outset_to(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::BezierPathSourceArchive&
ConnectionLinePathSourceArchive::_Internal::super(const ConnectionLinePathSourceArchive* msg) {
  return *msg->_impl_.super_;
}
ConnectionLinePathSourceArchive::ConnectionLinePathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ConnectionLinePathSourceArchive)
}
ConnectionLinePathSourceArchive::ConnectionLinePathSourceArchive(const ConnectionLinePathSourceArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConnectionLinePathSourceArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.outset_from_){}
    , decltype(_impl_.outset_to_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::BezierPathSourceArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.outset_to_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.outset_to_));
  // @@protoc_insertion_point(copy_constructor:TSD.ConnectionLinePathSourceArchive)
}

inline void ConnectionLinePathSourceArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.outset_from_){0}
    , decltype(_impl_.outset_to_){0}
  };
}

ConnectionLinePathSourceArchive::~ConnectionLinePathSourceArchive() {
  // @@protoc_insertion_point(destructor:TSD.ConnectionLinePathSourceArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionLinePathSourceArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ConnectionLinePathSourceArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionLinePathSourceArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ConnectionLinePathSourceArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.outset_to_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.outset_to_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConnectionLinePathSourceArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.BezierPathSourceArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ConnectionLinePathSourceArchive.ConnectionLinePathSourceType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float outset_from = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_outset_from(&has_bits);
          _impl_.outset_from_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float outset_to = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_outset_to(&has_bits);
          _impl_.outset_to_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectionLinePathSourceArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ConnectionLinePathSourceArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.BezierPathSourceArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ConnectionLinePathSourceArchive.ConnectionLinePathSourceType type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional float outset_from = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_outset_from(), target);
  }

  // optional float outset_to = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_outset_to(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ConnectionLinePathSourceArchive)
  return target;
}

size_t ConnectionLinePathSourceArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ConnectionLinePathSourceArchive)
  size_t total_size = 0;

  // required .TSD.BezierPathSourceArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .TSD.ConnectionLinePathSourceArchive.ConnectionLinePathSourceType type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional float outset_from = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float outset_to = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConnectionLinePathSourceArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConnectionLinePathSourceArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConnectionLinePathSourceArchive::GetClassData() const { return &_class_data_; }


void ConnectionLinePathSourceArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConnectionLinePathSourceArchive*>(&to_msg);
  auto& from = static_cast<const ConnectionLinePathSourceArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ConnectionLinePathSourceArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::BezierPathSourceArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.outset_from_ = from._impl_.outset_from_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.outset_to_ = from._impl_.outset_to_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConnectionLinePathSourceArchive::CopyFrom(const ConnectionLinePathSourceArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ConnectionLinePathSourceArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionLinePathSourceArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ConnectionLinePathSourceArchive::InternalSwap(ConnectionLinePathSourceArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionLinePathSourceArchive, _impl_.outset_to_)
      + sizeof(ConnectionLinePathSourceArchive::_impl_.outset_to_)
      - PROTOBUF_FIELD_OFFSET(ConnectionLinePathSourceArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConnectionLinePathSourceArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[6]);
}

// ===================================================================

class EditableBezierPathSourceArchive_Node::_Internal {
 public:
  using HasBits = decltype(std::declval<EditableBezierPathSourceArchive_Node>()._impl_._has_bits_);
  static const ::TSP::Point& incontrolpoint(const EditableBezierPathSourceArchive_Node* msg);
  static void set_has_incontrolpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Point& nodepoint(const EditableBezierPathSourceArchive_Node* msg);
  static void set_has_nodepoint(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Point& outcontrolpoint(const EditableBezierPathSourceArchive_Node* msg);
  static void set_has_outcontrolpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TSP::Point&
EditableBezierPathSourceArchive_Node::_Internal::incontrolpoint(const EditableBezierPathSourceArchive_Node* msg) {
  return *msg->_impl_.incontrolpoint_;
}
const ::TSP::Point&
EditableBezierPathSourceArchive_Node::_Internal::nodepoint(const EditableBezierPathSourceArchive_Node* msg) {
  return *msg->_impl_.nodepoint_;
}
const ::TSP::Point&
EditableBezierPathSourceArchive_Node::_Internal::outcontrolpoint(const EditableBezierPathSourceArchive_Node* msg) {
  return *msg->_impl_.outcontrolpoint_;
}
void EditableBezierPathSourceArchive_Node::clear_incontrolpoint() {
  if (_impl_.incontrolpoint_ != nullptr) _impl_.incontrolpoint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void EditableBezierPathSourceArchive_Node::clear_nodepoint() {
  if (_impl_.nodepoint_ != nullptr) _impl_.nodepoint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void EditableBezierPathSourceArchive_Node::clear_outcontrolpoint() {
  if (_impl_.outcontrolpoint_ != nullptr) _impl_.outcontrolpoint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
EditableBezierPathSourceArchive_Node::EditableBezierPathSourceArchive_Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.EditableBezierPathSourceArchive.Node)
}
EditableBezierPathSourceArchive_Node::EditableBezierPathSourceArchive_Node(const EditableBezierPathSourceArchive_Node& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EditableBezierPathSourceArchive_Node* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.incontrolpoint_){nullptr}
    , decltype(_impl_.nodepoint_){nullptr}
    , decltype(_impl_.outcontrolpoint_){nullptr}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_incontrolpoint()) {
    _this->_impl_.incontrolpoint_ = new ::TSP::Point(*from._impl_.incontrolpoint_);
  }
  if (from._internal_has_nodepoint()) {
    _this->_impl_.nodepoint_ = new ::TSP::Point(*from._impl_.nodepoint_);
  }
  if (from._internal_has_outcontrolpoint()) {
    _this->_impl_.outcontrolpoint_ = new ::TSP::Point(*from._impl_.outcontrolpoint_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:TSD.EditableBezierPathSourceArchive.Node)
}

inline void EditableBezierPathSourceArchive_Node::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.incontrolpoint_){nullptr}
    , decltype(_impl_.nodepoint_){nullptr}
    , decltype(_impl_.outcontrolpoint_){nullptr}
    , decltype(_impl_.type_){1}
  };
}

EditableBezierPathSourceArchive_Node::~EditableBezierPathSourceArchive_Node() {
  // @@protoc_insertion_point(destructor:TSD.EditableBezierPathSourceArchive.Node)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EditableBezierPathSourceArchive_Node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.incontrolpoint_;
  if (this != internal_default_instance()) delete _impl_.nodepoint_;
  if (this != internal_default_instance()) delete _impl_.outcontrolpoint_;
}

void EditableBezierPathSourceArchive_Node::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EditableBezierPathSourceArchive_Node::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.EditableBezierPathSourceArchive.Node)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.incontrolpoint_ != nullptr);
      _impl_.incontrolpoint_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.nodepoint_ != nullptr);
      _impl_.nodepoint_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.outcontrolpoint_ != nullptr);
      _impl_.outcontrolpoint_->Clear();
    }
    _impl_.type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EditableBezierPathSourceArchive_Node::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.Point inControlPoint = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_incontrolpoint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Point nodePoint = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_nodepoint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Point outControlPoint = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_outcontrolpoint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSD.EditableBezierPathSourceArchive.NodeType type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::EditableBezierPathSourceArchive_NodeType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::EditableBezierPathSourceArchive_NodeType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EditableBezierPathSourceArchive_Node::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.EditableBezierPathSourceArchive.Node)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.Point inControlPoint = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::incontrolpoint(this),
        _Internal::incontrolpoint(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Point nodePoint = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::nodepoint(this),
        _Internal::nodepoint(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Point outControlPoint = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::outcontrolpoint(this),
        _Internal::outcontrolpoint(this).GetCachedSize(), target, stream);
  }

  // required .TSD.EditableBezierPathSourceArchive.NodeType type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.EditableBezierPathSourceArchive.Node)
  return target;
}

size_t EditableBezierPathSourceArchive_Node::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSD.EditableBezierPathSourceArchive.Node)
  size_t total_size = 0;

  if (_internal_has_incontrolpoint()) {
    // required .TSP.Point inControlPoint = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.incontrolpoint_);
  }

  if (_internal_has_nodepoint()) {
    // required .TSP.Point nodePoint = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nodepoint_);
  }

  if (_internal_has_outcontrolpoint()) {
    // required .TSP.Point outControlPoint = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.outcontrolpoint_);
  }

  if (_internal_has_type()) {
    // required .TSD.EditableBezierPathSourceArchive.NodeType type = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t EditableBezierPathSourceArchive_Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.EditableBezierPathSourceArchive.Node)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TSP.Point inControlPoint = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.incontrolpoint_);

    // required .TSP.Point nodePoint = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nodepoint_);

    // required .TSP.Point outControlPoint = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.outcontrolpoint_);

    // required .TSD.EditableBezierPathSourceArchive.NodeType type = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EditableBezierPathSourceArchive_Node::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EditableBezierPathSourceArchive_Node::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EditableBezierPathSourceArchive_Node::GetClassData() const { return &_class_data_; }


void EditableBezierPathSourceArchive_Node::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EditableBezierPathSourceArchive_Node*>(&to_msg);
  auto& from = static_cast<const EditableBezierPathSourceArchive_Node&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.EditableBezierPathSourceArchive.Node)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_incontrolpoint()->::TSP::Point::MergeFrom(
          from._internal_incontrolpoint());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_nodepoint()->::TSP::Point::MergeFrom(
          from._internal_nodepoint());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_outcontrolpoint()->::TSP::Point::MergeFrom(
          from._internal_outcontrolpoint());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EditableBezierPathSourceArchive_Node::CopyFrom(const EditableBezierPathSourceArchive_Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.EditableBezierPathSourceArchive.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EditableBezierPathSourceArchive_Node::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_incontrolpoint()) {
    if (!_impl_.incontrolpoint_->IsInitialized()) return false;
  }
  if (_internal_has_nodepoint()) {
    if (!_impl_.nodepoint_->IsInitialized()) return false;
  }
  if (_internal_has_outcontrolpoint()) {
    if (!_impl_.outcontrolpoint_->IsInitialized()) return false;
  }
  return true;
}

void EditableBezierPathSourceArchive_Node::InternalSwap(EditableBezierPathSourceArchive_Node* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EditableBezierPathSourceArchive_Node, _impl_.outcontrolpoint_)
      + sizeof(EditableBezierPathSourceArchive_Node::_impl_.outcontrolpoint_)
      - PROTOBUF_FIELD_OFFSET(EditableBezierPathSourceArchive_Node, _impl_.incontrolpoint_)>(
          reinterpret_cast<char*>(&_impl_.incontrolpoint_),
          reinterpret_cast<char*>(&other->_impl_.incontrolpoint_));
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EditableBezierPathSourceArchive_Node::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[7]);
}

// ===================================================================

class EditableBezierPathSourceArchive_Subpath::_Internal {
 public:
  using HasBits = decltype(std::declval<EditableBezierPathSourceArchive_Subpath>()._impl_._has_bits_);
  static void set_has_closed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

EditableBezierPathSourceArchive_Subpath::EditableBezierPathSourceArchive_Subpath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.EditableBezierPathSourceArchive.Subpath)
}
EditableBezierPathSourceArchive_Subpath::EditableBezierPathSourceArchive_Subpath(const EditableBezierPathSourceArchive_Subpath& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EditableBezierPathSourceArchive_Subpath* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nodes_){from._impl_.nodes_}
    , decltype(_impl_.closed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.closed_ = from._impl_.closed_;
  // @@protoc_insertion_point(copy_constructor:TSD.EditableBezierPathSourceArchive.Subpath)
}

inline void EditableBezierPathSourceArchive_Subpath::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nodes_){arena}
    , decltype(_impl_.closed_){false}
  };
}

EditableBezierPathSourceArchive_Subpath::~EditableBezierPathSourceArchive_Subpath() {
  // @@protoc_insertion_point(destructor:TSD.EditableBezierPathSourceArchive.Subpath)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EditableBezierPathSourceArchive_Subpath::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodes_.~RepeatedPtrField();
}

void EditableBezierPathSourceArchive_Subpath::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EditableBezierPathSourceArchive_Subpath::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.EditableBezierPathSourceArchive.Subpath)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodes_.Clear();
  _impl_.closed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EditableBezierPathSourceArchive_Subpath::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSD.EditableBezierPathSourceArchive.Node nodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required bool closed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_closed(&has_bits);
          _impl_.closed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EditableBezierPathSourceArchive_Subpath::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.EditableBezierPathSourceArchive.Subpath)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSD.EditableBezierPathSourceArchive.Node nodes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // required bool closed = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_closed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.EditableBezierPathSourceArchive.Subpath)
  return target;
}

size_t EditableBezierPathSourceArchive_Subpath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.EditableBezierPathSourceArchive.Subpath)
  size_t total_size = 0;

  // required bool closed = 2;
  if (_internal_has_closed()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSD.EditableBezierPathSourceArchive.Node nodes = 1;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->_impl_.nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EditableBezierPathSourceArchive_Subpath::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EditableBezierPathSourceArchive_Subpath::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EditableBezierPathSourceArchive_Subpath::GetClassData() const { return &_class_data_; }


void EditableBezierPathSourceArchive_Subpath::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EditableBezierPathSourceArchive_Subpath*>(&to_msg);
  auto& from = static_cast<const EditableBezierPathSourceArchive_Subpath&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.EditableBezierPathSourceArchive.Subpath)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  if (from._internal_has_closed()) {
    _this->_internal_set_closed(from._internal_closed());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EditableBezierPathSourceArchive_Subpath::CopyFrom(const EditableBezierPathSourceArchive_Subpath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.EditableBezierPathSourceArchive.Subpath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EditableBezierPathSourceArchive_Subpath::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.nodes_))
    return false;
  return true;
}

void EditableBezierPathSourceArchive_Subpath::InternalSwap(EditableBezierPathSourceArchive_Subpath* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
  swap(_impl_.closed_, other->_impl_.closed_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EditableBezierPathSourceArchive_Subpath::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[8]);
}

// ===================================================================

class EditableBezierPathSourceArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<EditableBezierPathSourceArchive>()._impl_._has_bits_);
  static const ::TSP::Size& naturalsize(const EditableBezierPathSourceArchive* msg);
  static void set_has_naturalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::Size&
EditableBezierPathSourceArchive::_Internal::naturalsize(const EditableBezierPathSourceArchive* msg) {
  return *msg->_impl_.naturalsize_;
}
void EditableBezierPathSourceArchive::clear_naturalsize() {
  if (_impl_.naturalsize_ != nullptr) _impl_.naturalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EditableBezierPathSourceArchive::EditableBezierPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.EditableBezierPathSourceArchive)
}
EditableBezierPathSourceArchive::EditableBezierPathSourceArchive(const EditableBezierPathSourceArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EditableBezierPathSourceArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subpaths_){from._impl_.subpaths_}
    , decltype(_impl_.naturalsize_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_naturalsize()) {
    _this->_impl_.naturalsize_ = new ::TSP::Size(*from._impl_.naturalsize_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.EditableBezierPathSourceArchive)
}

inline void EditableBezierPathSourceArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subpaths_){arena}
    , decltype(_impl_.naturalsize_){nullptr}
  };
}

EditableBezierPathSourceArchive::~EditableBezierPathSourceArchive() {
  // @@protoc_insertion_point(destructor:TSD.EditableBezierPathSourceArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EditableBezierPathSourceArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subpaths_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.naturalsize_;
}

void EditableBezierPathSourceArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EditableBezierPathSourceArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.EditableBezierPathSourceArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subpaths_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.naturalsize_ != nullptr);
    _impl_.naturalsize_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EditableBezierPathSourceArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSD.EditableBezierPathSourceArchive.Subpath subpaths = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_subpaths(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size naturalSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_naturalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EditableBezierPathSourceArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.EditableBezierPathSourceArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSD.EditableBezierPathSourceArchive.Subpath subpaths = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_subpaths_size()); i < n; i++) {
    const auto& repfield = this->_internal_subpaths(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Size naturalSize = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::naturalsize(this),
        _Internal::naturalsize(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.EditableBezierPathSourceArchive)
  return target;
}

size_t EditableBezierPathSourceArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.EditableBezierPathSourceArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSD.EditableBezierPathSourceArchive.Subpath subpaths = 1;
  total_size += 1UL * this->_internal_subpaths_size();
  for (const auto& msg : this->_impl_.subpaths_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TSP.Size naturalSize = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.naturalsize_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EditableBezierPathSourceArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EditableBezierPathSourceArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EditableBezierPathSourceArchive::GetClassData() const { return &_class_data_; }


void EditableBezierPathSourceArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EditableBezierPathSourceArchive*>(&to_msg);
  auto& from = static_cast<const EditableBezierPathSourceArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.EditableBezierPathSourceArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.subpaths_.MergeFrom(from._impl_.subpaths_);
  if (from._internal_has_naturalsize()) {
    _this->_internal_mutable_naturalsize()->::TSP::Size::MergeFrom(
        from._internal_naturalsize());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EditableBezierPathSourceArchive::CopyFrom(const EditableBezierPathSourceArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.EditableBezierPathSourceArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EditableBezierPathSourceArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.subpaths_))
    return false;
  if (_internal_has_naturalsize()) {
    if (!_impl_.naturalsize_->IsInitialized()) return false;
  }
  return true;
}

void EditableBezierPathSourceArchive::InternalSwap(EditableBezierPathSourceArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.subpaths_.InternalSwap(&other->_impl_.subpaths_);
  swap(_impl_.naturalsize_, other->_impl_.naturalsize_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EditableBezierPathSourceArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[9]);
}

// ===================================================================

class PathSourceArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PathSourceArchive>()._impl_._has_bits_);
  static void set_has_horizontalflip(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_verticalflip(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::TSD::PointPathSourceArchive& point_path_source(const PathSourceArchive* msg);
  static void set_has_point_path_source(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::ScalarPathSourceArchive& scalar_path_source(const PathSourceArchive* msg);
  static void set_has_scalar_path_source(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSD::BezierPathSourceArchive& bezier_path_source(const PathSourceArchive* msg);
  static void set_has_bezier_path_source(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSD::CalloutPathSourceArchive& callout_path_source(const PathSourceArchive* msg);
  static void set_has_callout_path_source(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSD::ConnectionLinePathSourceArchive& connection_line_path_source(const PathSourceArchive* msg);
  static void set_has_connection_line_path_source(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSD::EditableBezierPathSourceArchive& editable_bezier_path_source(const PathSourceArchive* msg);
  static void set_has_editable_bezier_path_source(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_localizationkey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_userdefinedname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSD::PointPathSourceArchive&
PathSourceArchive::_Internal::point_path_source(const PathSourceArchive* msg) {
  return *msg->_impl_.point_path_source_;
}
const ::TSD::ScalarPathSourceArchive&
PathSourceArchive::_Internal::scalar_path_source(const PathSourceArchive* msg) {
  return *msg->_impl_.scalar_path_source_;
}
const ::TSD::BezierPathSourceArchive&
PathSourceArchive::_Internal::bezier_path_source(const PathSourceArchive* msg) {
  return *msg->_impl_.bezier_path_source_;
}
const ::TSD::CalloutPathSourceArchive&
PathSourceArchive::_Internal::callout_path_source(const PathSourceArchive* msg) {
  return *msg->_impl_.callout_path_source_;
}
const ::TSD::ConnectionLinePathSourceArchive&
PathSourceArchive::_Internal::connection_line_path_source(const PathSourceArchive* msg) {
  return *msg->_impl_.connection_line_path_source_;
}
const ::TSD::EditableBezierPathSourceArchive&
PathSourceArchive::_Internal::editable_bezier_path_source(const PathSourceArchive* msg) {
  return *msg->_impl_.editable_bezier_path_source_;
}
PathSourceArchive::PathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.PathSourceArchive)
}
PathSourceArchive::PathSourceArchive(const PathSourceArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PathSourceArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.localizationkey_){}
    , decltype(_impl_.userdefinedname_){}
    , decltype(_impl_.point_path_source_){nullptr}
    , decltype(_impl_.scalar_path_source_){nullptr}
    , decltype(_impl_.bezier_path_source_){nullptr}
    , decltype(_impl_.callout_path_source_){nullptr}
    , decltype(_impl_.connection_line_path_source_){nullptr}
    , decltype(_impl_.editable_bezier_path_source_){nullptr}
    , decltype(_impl_.horizontalflip_){}
    , decltype(_impl_.verticalflip_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.localizationkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.localizationkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_localizationkey()) {
    _this->_impl_.localizationkey_.Set(from._internal_localizationkey(), 
      _this->GetArenaForAllocation());
  }
  _impl_.userdefinedname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userdefinedname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_userdefinedname()) {
    _this->_impl_.userdefinedname_.Set(from._internal_userdefinedname(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_point_path_source()) {
    _this->_impl_.point_path_source_ = new ::TSD::PointPathSourceArchive(*from._impl_.point_path_source_);
  }
  if (from._internal_has_scalar_path_source()) {
    _this->_impl_.scalar_path_source_ = new ::TSD::ScalarPathSourceArchive(*from._impl_.scalar_path_source_);
  }
  if (from._internal_has_bezier_path_source()) {
    _this->_impl_.bezier_path_source_ = new ::TSD::BezierPathSourceArchive(*from._impl_.bezier_path_source_);
  }
  if (from._internal_has_callout_path_source()) {
    _this->_impl_.callout_path_source_ = new ::TSD::CalloutPathSourceArchive(*from._impl_.callout_path_source_);
  }
  if (from._internal_has_connection_line_path_source()) {
    _this->_impl_.connection_line_path_source_ = new ::TSD::ConnectionLinePathSourceArchive(*from._impl_.connection_line_path_source_);
  }
  if (from._internal_has_editable_bezier_path_source()) {
    _this->_impl_.editable_bezier_path_source_ = new ::TSD::EditableBezierPathSourceArchive(*from._impl_.editable_bezier_path_source_);
  }
  ::memcpy(&_impl_.horizontalflip_, &from._impl_.horizontalflip_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.verticalflip_) -
    reinterpret_cast<char*>(&_impl_.horizontalflip_)) + sizeof(_impl_.verticalflip_));
  // @@protoc_insertion_point(copy_constructor:TSD.PathSourceArchive)
}

inline void PathSourceArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.localizationkey_){}
    , decltype(_impl_.userdefinedname_){}
    , decltype(_impl_.point_path_source_){nullptr}
    , decltype(_impl_.scalar_path_source_){nullptr}
    , decltype(_impl_.bezier_path_source_){nullptr}
    , decltype(_impl_.callout_path_source_){nullptr}
    , decltype(_impl_.connection_line_path_source_){nullptr}
    , decltype(_impl_.editable_bezier_path_source_){nullptr}
    , decltype(_impl_.horizontalflip_){false}
    , decltype(_impl_.verticalflip_){false}
  };
  _impl_.localizationkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.localizationkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.userdefinedname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.userdefinedname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PathSourceArchive::~PathSourceArchive() {
  // @@protoc_insertion_point(destructor:TSD.PathSourceArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PathSourceArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.localizationkey_.Destroy();
  _impl_.userdefinedname_.Destroy();
  if (this != internal_default_instance()) delete _impl_.point_path_source_;
  if (this != internal_default_instance()) delete _impl_.scalar_path_source_;
  if (this != internal_default_instance()) delete _impl_.bezier_path_source_;
  if (this != internal_default_instance()) delete _impl_.callout_path_source_;
  if (this != internal_default_instance()) delete _impl_.connection_line_path_source_;
  if (this != internal_default_instance()) delete _impl_.editable_bezier_path_source_;
}

void PathSourceArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PathSourceArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.PathSourceArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.localizationkey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.userdefinedname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.point_path_source_ != nullptr);
      _impl_.point_path_source_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.scalar_path_source_ != nullptr);
      _impl_.scalar_path_source_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.bezier_path_source_ != nullptr);
      _impl_.bezier_path_source_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.callout_path_source_ != nullptr);
      _impl_.callout_path_source_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.connection_line_path_source_ != nullptr);
      _impl_.connection_line_path_source_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.editable_bezier_path_source_ != nullptr);
      _impl_.editable_bezier_path_source_->Clear();
    }
  }
  ::memset(&_impl_.horizontalflip_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.verticalflip_) -
      reinterpret_cast<char*>(&_impl_.horizontalflip_)) + sizeof(_impl_.verticalflip_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PathSourceArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool horizontalFlip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_horizontalflip(&has_bits);
          _impl_.horizontalflip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool verticalFlip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_verticalflip(&has_bits);
          _impl_.verticalflip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.PointPathSourceArchive point_path_source = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_point_path_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ScalarPathSourceArchive scalar_path_source = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_scalar_path_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.BezierPathSourceArchive bezier_path_source = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_bezier_path_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.CalloutPathSourceArchive callout_path_source = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_callout_path_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ConnectionLinePathSourceArchive connection_line_path_source = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_connection_line_path_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.EditableBezierPathSourceArchive editable_bezier_path_source = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_editable_bezier_path_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string localizationKey = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_localizationkey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.PathSourceArchive.localizationKey");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string userDefinedName = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_userdefinedname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.PathSourceArchive.userDefinedName");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PathSourceArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.PathSourceArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool horizontalFlip = 1;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_horizontalflip(), target);
  }

  // optional bool verticalFlip = 2;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_verticalflip(), target);
  }

  // optional .TSD.PointPathSourceArchive point_path_source = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::point_path_source(this),
        _Internal::point_path_source(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ScalarPathSourceArchive scalar_path_source = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::scalar_path_source(this),
        _Internal::scalar_path_source(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.BezierPathSourceArchive bezier_path_source = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::bezier_path_source(this),
        _Internal::bezier_path_source(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.CalloutPathSourceArchive callout_path_source = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::callout_path_source(this),
        _Internal::callout_path_source(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ConnectionLinePathSourceArchive connection_line_path_source = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::connection_line_path_source(this),
        _Internal::connection_line_path_source(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.EditableBezierPathSourceArchive editable_bezier_path_source = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::editable_bezier_path_source(this),
        _Internal::editable_bezier_path_source(this).GetCachedSize(), target, stream);
  }

  // optional string localizationKey = 9;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_localizationkey().data(), static_cast<int>(this->_internal_localizationkey().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.PathSourceArchive.localizationKey");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_localizationkey(), target);
  }

  // optional string userDefinedName = 10;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_userdefinedname().data(), static_cast<int>(this->_internal_userdefinedname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.PathSourceArchive.userDefinedName");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_userdefinedname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.PathSourceArchive)
  return target;
}

size_t PathSourceArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.PathSourceArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string localizationKey = 9;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_localizationkey());
    }

    // optional string userDefinedName = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_userdefinedname());
    }

    // optional .TSD.PointPathSourceArchive point_path_source = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.point_path_source_);
    }

    // optional .TSD.ScalarPathSourceArchive scalar_path_source = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scalar_path_source_);
    }

    // optional .TSD.BezierPathSourceArchive bezier_path_source = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.bezier_path_source_);
    }

    // optional .TSD.CalloutPathSourceArchive callout_path_source = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.callout_path_source_);
    }

    // optional .TSD.ConnectionLinePathSourceArchive connection_line_path_source = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.connection_line_path_source_);
    }

    // optional .TSD.EditableBezierPathSourceArchive editable_bezier_path_source = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.editable_bezier_path_source_);
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool horizontalFlip = 1;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool verticalFlip = 2;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PathSourceArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PathSourceArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PathSourceArchive::GetClassData() const { return &_class_data_; }


void PathSourceArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PathSourceArchive*>(&to_msg);
  auto& from = static_cast<const PathSourceArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.PathSourceArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_localizationkey(from._internal_localizationkey());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_userdefinedname(from._internal_userdefinedname());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_point_path_source()->::TSD::PointPathSourceArchive::MergeFrom(
          from._internal_point_path_source());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_scalar_path_source()->::TSD::ScalarPathSourceArchive::MergeFrom(
          from._internal_scalar_path_source());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_bezier_path_source()->::TSD::BezierPathSourceArchive::MergeFrom(
          from._internal_bezier_path_source());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_callout_path_source()->::TSD::CalloutPathSourceArchive::MergeFrom(
          from._internal_callout_path_source());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_connection_line_path_source()->::TSD::ConnectionLinePathSourceArchive::MergeFrom(
          from._internal_connection_line_path_source());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_editable_bezier_path_source()->::TSD::EditableBezierPathSourceArchive::MergeFrom(
          from._internal_editable_bezier_path_source());
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.horizontalflip_ = from._impl_.horizontalflip_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.verticalflip_ = from._impl_.verticalflip_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PathSourceArchive::CopyFrom(const PathSourceArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.PathSourceArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PathSourceArchive::IsInitialized() const {
  if (_internal_has_point_path_source()) {
    if (!_impl_.point_path_source_->IsInitialized()) return false;
  }
  if (_internal_has_scalar_path_source()) {
    if (!_impl_.scalar_path_source_->IsInitialized()) return false;
  }
  if (_internal_has_bezier_path_source()) {
    if (!_impl_.bezier_path_source_->IsInitialized()) return false;
  }
  if (_internal_has_callout_path_source()) {
    if (!_impl_.callout_path_source_->IsInitialized()) return false;
  }
  if (_internal_has_connection_line_path_source()) {
    if (!_impl_.connection_line_path_source_->IsInitialized()) return false;
  }
  if (_internal_has_editable_bezier_path_source()) {
    if (!_impl_.editable_bezier_path_source_->IsInitialized()) return false;
  }
  return true;
}

void PathSourceArchive::InternalSwap(PathSourceArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.localizationkey_, lhs_arena,
      &other->_impl_.localizationkey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.userdefinedname_, lhs_arena,
      &other->_impl_.userdefinedname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PathSourceArchive, _impl_.verticalflip_)
      + sizeof(PathSourceArchive::_impl_.verticalflip_)
      - PROTOBUF_FIELD_OFFSET(PathSourceArchive, _impl_.point_path_source_)>(
          reinterpret_cast<char*>(&_impl_.point_path_source_),
          reinterpret_cast<char*>(&other->_impl_.point_path_source_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PathSourceArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[10]);
}

// ===================================================================

class AngleGradientArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<AngleGradientArchive>()._impl_._has_bits_);
  static void set_has_gradientangle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AngleGradientArchive::AngleGradientArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.AngleGradientArchive)
}
AngleGradientArchive::AngleGradientArchive(const AngleGradientArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AngleGradientArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gradientangle_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.gradientangle_ = from._impl_.gradientangle_;
  // @@protoc_insertion_point(copy_constructor:TSD.AngleGradientArchive)
}

inline void AngleGradientArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gradientangle_){0}
  };
}

AngleGradientArchive::~AngleGradientArchive() {
  // @@protoc_insertion_point(destructor:TSD.AngleGradientArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AngleGradientArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AngleGradientArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AngleGradientArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.AngleGradientArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.gradientangle_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AngleGradientArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float gradientangle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_gradientangle(&has_bits);
          _impl_.gradientangle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AngleGradientArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.AngleGradientArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float gradientangle = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_gradientangle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.AngleGradientArchive)
  return target;
}

size_t AngleGradientArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.AngleGradientArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float gradientangle = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AngleGradientArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AngleGradientArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AngleGradientArchive::GetClassData() const { return &_class_data_; }


void AngleGradientArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AngleGradientArchive*>(&to_msg);
  auto& from = static_cast<const AngleGradientArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.AngleGradientArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_gradientangle()) {
    _this->_internal_set_gradientangle(from._internal_gradientangle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AngleGradientArchive::CopyFrom(const AngleGradientArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.AngleGradientArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AngleGradientArchive::IsInitialized() const {
  return true;
}

void AngleGradientArchive::InternalSwap(AngleGradientArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.gradientangle_, other->_impl_.gradientangle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AngleGradientArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[11]);
}

// ===================================================================

class TransformGradientArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<TransformGradientArchive>()._impl_._has_bits_);
  static const ::TSP::Point& start(const TransformGradientArchive* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Point& end(const TransformGradientArchive* msg);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Size& basenaturalsize(const TransformGradientArchive* msg);
  static void set_has_basenaturalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSP::Point&
TransformGradientArchive::_Internal::start(const TransformGradientArchive* msg) {
  return *msg->_impl_.start_;
}
const ::TSP::Point&
TransformGradientArchive::_Internal::end(const TransformGradientArchive* msg) {
  return *msg->_impl_.end_;
}
const ::TSP::Size&
TransformGradientArchive::_Internal::basenaturalsize(const TransformGradientArchive* msg) {
  return *msg->_impl_.basenaturalsize_;
}
void TransformGradientArchive::clear_start() {
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TransformGradientArchive::clear_end() {
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TransformGradientArchive::clear_basenaturalsize() {
  if (_impl_.basenaturalsize_ != nullptr) _impl_.basenaturalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
TransformGradientArchive::TransformGradientArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.TransformGradientArchive)
}
TransformGradientArchive::TransformGradientArchive(const TransformGradientArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransformGradientArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , decltype(_impl_.basenaturalsize_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_start()) {
    _this->_impl_.start_ = new ::TSP::Point(*from._impl_.start_);
  }
  if (from._internal_has_end()) {
    _this->_impl_.end_ = new ::TSP::Point(*from._impl_.end_);
  }
  if (from._internal_has_basenaturalsize()) {
    _this->_impl_.basenaturalsize_ = new ::TSP::Size(*from._impl_.basenaturalsize_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.TransformGradientArchive)
}

inline void TransformGradientArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , decltype(_impl_.basenaturalsize_){nullptr}
  };
}

TransformGradientArchive::~TransformGradientArchive() {
  // @@protoc_insertion_point(destructor:TSD.TransformGradientArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransformGradientArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.end_;
  if (this != internal_default_instance()) delete _impl_.basenaturalsize_;
}

void TransformGradientArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransformGradientArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.TransformGradientArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.start_ != nullptr);
      _impl_.start_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.end_ != nullptr);
      _impl_.end_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.basenaturalsize_ != nullptr);
      _impl_.basenaturalsize_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransformGradientArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Point start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Point end = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size baseNaturalSize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_basenaturalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TransformGradientArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.TransformGradientArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Point start = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Point end = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::end(this),
        _Internal::end(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size baseNaturalSize = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::basenaturalsize(this),
        _Internal::basenaturalsize(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.TransformGradientArchive)
  return target;
}

size_t TransformGradientArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.TransformGradientArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSP.Point start = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.start_);
    }

    // optional .TSP.Point end = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.end_);
    }

    // optional .TSP.Size baseNaturalSize = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.basenaturalsize_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransformGradientArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransformGradientArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransformGradientArchive::GetClassData() const { return &_class_data_; }


void TransformGradientArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransformGradientArchive*>(&to_msg);
  auto& from = static_cast<const TransformGradientArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.TransformGradientArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_start()->::TSP::Point::MergeFrom(
          from._internal_start());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_end()->::TSP::Point::MergeFrom(
          from._internal_end());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_basenaturalsize()->::TSP::Size::MergeFrom(
          from._internal_basenaturalsize());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransformGradientArchive::CopyFrom(const TransformGradientArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.TransformGradientArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransformGradientArchive::IsInitialized() const {
  if (_internal_has_start()) {
    if (!_impl_.start_->IsInitialized()) return false;
  }
  if (_internal_has_end()) {
    if (!_impl_.end_->IsInitialized()) return false;
  }
  if (_internal_has_basenaturalsize()) {
    if (!_impl_.basenaturalsize_->IsInitialized()) return false;
  }
  return true;
}

void TransformGradientArchive::InternalSwap(TransformGradientArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TransformGradientArchive, _impl_.basenaturalsize_)
      + sizeof(TransformGradientArchive::_impl_.basenaturalsize_)
      - PROTOBUF_FIELD_OFFSET(TransformGradientArchive, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TransformGradientArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[12]);
}

// ===================================================================

class GradientArchive_GradientStop::_Internal {
 public:
  using HasBits = decltype(std::declval<GradientArchive_GradientStop>()._impl_._has_bits_);
  static const ::TSP::Color& color(const GradientArchive_GradientStop* msg);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fraction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_inflection(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSP::Color&
GradientArchive_GradientStop::_Internal::color(const GradientArchive_GradientStop* msg) {
  return *msg->_impl_.color_;
}
void GradientArchive_GradientStop::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
GradientArchive_GradientStop::GradientArchive_GradientStop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.GradientArchive.GradientStop)
}
GradientArchive_GradientStop::GradientArchive_GradientStop(const GradientArchive_GradientStop& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GradientArchive_GradientStop* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.fraction_){}
    , decltype(_impl_.inflection_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::TSP::Color(*from._impl_.color_);
  }
  ::memcpy(&_impl_.fraction_, &from._impl_.fraction_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.inflection_) -
    reinterpret_cast<char*>(&_impl_.fraction_)) + sizeof(_impl_.inflection_));
  // @@protoc_insertion_point(copy_constructor:TSD.GradientArchive.GradientStop)
}

inline void GradientArchive_GradientStop::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.fraction_){0}
    , decltype(_impl_.inflection_){0}
  };
}

GradientArchive_GradientStop::~GradientArchive_GradientStop() {
  // @@protoc_insertion_point(destructor:TSD.GradientArchive.GradientStop)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GradientArchive_GradientStop::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.color_;
}

void GradientArchive_GradientStop::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GradientArchive_GradientStop::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.GradientArchive.GradientStop)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.color_ != nullptr);
    _impl_.color_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.fraction_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.inflection_) -
        reinterpret_cast<char*>(&_impl_.fraction_)) + sizeof(_impl_.inflection_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GradientArchive_GradientStop::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Color color = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float fraction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_fraction(&has_bits);
          _impl_.fraction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float inflection = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_inflection(&has_bits);
          _impl_.inflection_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GradientArchive_GradientStop::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.GradientArchive.GradientStop)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Color color = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  // optional float fraction = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_fraction(), target);
  }

  // optional float inflection = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_inflection(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.GradientArchive.GradientStop)
  return target;
}

size_t GradientArchive_GradientStop::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.GradientArchive.GradientStop)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSP.Color color = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.color_);
    }

    // optional float fraction = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float inflection = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GradientArchive_GradientStop::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GradientArchive_GradientStop::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GradientArchive_GradientStop::GetClassData() const { return &_class_data_; }


void GradientArchive_GradientStop::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GradientArchive_GradientStop*>(&to_msg);
  auto& from = static_cast<const GradientArchive_GradientStop&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.GradientArchive.GradientStop)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_color()->::TSP::Color::MergeFrom(
          from._internal_color());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.fraction_ = from._impl_.fraction_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.inflection_ = from._impl_.inflection_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GradientArchive_GradientStop::CopyFrom(const GradientArchive_GradientStop& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.GradientArchive.GradientStop)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GradientArchive_GradientStop::IsInitialized() const {
  if (_internal_has_color()) {
    if (!_impl_.color_->IsInitialized()) return false;
  }
  return true;
}

void GradientArchive_GradientStop::InternalSwap(GradientArchive_GradientStop* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GradientArchive_GradientStop, _impl_.inflection_)
      + sizeof(GradientArchive_GradientStop::_impl_.inflection_)
      - PROTOBUF_FIELD_OFFSET(GradientArchive_GradientStop, _impl_.color_)>(
          reinterpret_cast<char*>(&_impl_.color_),
          reinterpret_cast<char*>(&other->_impl_.color_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GradientArchive_GradientStop::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[13]);
}

// ===================================================================

class GradientArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<GradientArchive>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_advancedgradient(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSD::AngleGradientArchive& anglegradient(const GradientArchive* msg);
  static void set_has_anglegradient(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::TransformGradientArchive& transformgradient(const GradientArchive* msg);
  static void set_has_transformgradient(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSD::AngleGradientArchive&
GradientArchive::_Internal::anglegradient(const GradientArchive* msg) {
  return *msg->_impl_.anglegradient_;
}
const ::TSD::TransformGradientArchive&
GradientArchive::_Internal::transformgradient(const GradientArchive* msg) {
  return *msg->_impl_.transformgradient_;
}
GradientArchive::GradientArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.GradientArchive)
}
GradientArchive::GradientArchive(const GradientArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GradientArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stops_){from._impl_.stops_}
    , decltype(_impl_.anglegradient_){nullptr}
    , decltype(_impl_.transformgradient_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.opacity_){}
    , decltype(_impl_.advancedgradient_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_anglegradient()) {
    _this->_impl_.anglegradient_ = new ::TSD::AngleGradientArchive(*from._impl_.anglegradient_);
  }
  if (from._internal_has_transformgradient()) {
    _this->_impl_.transformgradient_ = new ::TSD::TransformGradientArchive(*from._impl_.transformgradient_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.advancedgradient_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.advancedgradient_));
  // @@protoc_insertion_point(copy_constructor:TSD.GradientArchive)
}

inline void GradientArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stops_){arena}
    , decltype(_impl_.anglegradient_){nullptr}
    , decltype(_impl_.transformgradient_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.opacity_){0}
    , decltype(_impl_.advancedgradient_){false}
  };
}

GradientArchive::~GradientArchive() {
  // @@protoc_insertion_point(destructor:TSD.GradientArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GradientArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stops_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.anglegradient_;
  if (this != internal_default_instance()) delete _impl_.transformgradient_;
}

void GradientArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GradientArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.GradientArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stops_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.anglegradient_ != nullptr);
      _impl_.anglegradient_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.transformgradient_ != nullptr);
      _impl_.transformgradient_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.advancedgradient_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.advancedgradient_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GradientArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.GradientArchive.GradientType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::GradientArchive_GradientType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::GradientArchive_GradientType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .TSD.GradientArchive.GradientStop stops = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stops(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional float opacity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_opacity(&has_bits);
          _impl_.opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool advancedGradient = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_advancedgradient(&has_bits);
          _impl_.advancedgradient_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.AngleGradientArchive anglegradient = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_anglegradient(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.TransformGradientArchive transformgradient = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_transformgradient(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GradientArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.GradientArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.GradientArchive.GradientType type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // repeated .TSD.GradientArchive.GradientStop stops = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stops_size()); i < n; i++) {
    const auto& repfield = this->_internal_stops(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional float opacity = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_opacity(), target);
  }

  // optional bool advancedGradient = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_advancedgradient(), target);
  }

  // optional .TSD.AngleGradientArchive anglegradient = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::anglegradient(this),
        _Internal::anglegradient(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.TransformGradientArchive transformgradient = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::transformgradient(this),
        _Internal::transformgradient(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.GradientArchive)
  return target;
}

size_t GradientArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.GradientArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSD.GradientArchive.GradientStop stops = 2;
  total_size += 1UL * this->_internal_stops_size();
  for (const auto& msg : this->_impl_.stops_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSD.AngleGradientArchive anglegradient = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.anglegradient_);
    }

    // optional .TSD.TransformGradientArchive transformgradient = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.transformgradient_);
    }

    // optional .TSD.GradientArchive.GradientType type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional float opacity = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional bool advancedGradient = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GradientArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GradientArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GradientArchive::GetClassData() const { return &_class_data_; }


void GradientArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GradientArchive*>(&to_msg);
  auto& from = static_cast<const GradientArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.GradientArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.stops_.MergeFrom(from._impl_.stops_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_anglegradient()->::TSD::AngleGradientArchive::MergeFrom(
          from._internal_anglegradient());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_transformgradient()->::TSD::TransformGradientArchive::MergeFrom(
          from._internal_transformgradient());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.opacity_ = from._impl_.opacity_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.advancedgradient_ = from._impl_.advancedgradient_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GradientArchive::CopyFrom(const GradientArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.GradientArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GradientArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.stops_))
    return false;
  if (_internal_has_transformgradient()) {
    if (!_impl_.transformgradient_->IsInitialized()) return false;
  }
  return true;
}

void GradientArchive::InternalSwap(GradientArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.stops_.InternalSwap(&other->_impl_.stops_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GradientArchive, _impl_.advancedgradient_)
      + sizeof(GradientArchive::_impl_.advancedgradient_)
      - PROTOBUF_FIELD_OFFSET(GradientArchive, _impl_.anglegradient_)>(
          reinterpret_cast<char*>(&_impl_.anglegradient_),
          reinterpret_cast<char*>(&other->_impl_.anglegradient_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GradientArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[14]);
}

// ===================================================================

class ImageFillArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ImageFillArchive>()._impl_._has_bits_);
  static const ::TSP::DataReference& imagedata(const ImageFillArchive* msg);
  static void set_has_imagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_technique(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::TSP::Color& tint(const ImageFillArchive* msg);
  static void set_has_tint(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Size& fillsize(const ImageFillArchive* msg);
  static void set_has_fillsize(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::DataReference& originalimagedata(const ImageFillArchive* msg);
  static void set_has_originalimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_interpretsuntaggedimagedataasgeneric(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::TSP::Color& referencecolor(const ImageFillArchive* msg);
  static void set_has_referencecolor(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSP::Reference& database_imagedata(const ImageFillArchive* msg);
  static void set_has_database_imagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& database_originalimagedata(const ImageFillArchive* msg);
  static void set_has_database_originalimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::TSP::DataReference&
ImageFillArchive::_Internal::imagedata(const ImageFillArchive* msg) {
  return *msg->_impl_.imagedata_;
}
const ::TSP::Color&
ImageFillArchive::_Internal::tint(const ImageFillArchive* msg) {
  return *msg->_impl_.tint_;
}
const ::TSP::Size&
ImageFillArchive::_Internal::fillsize(const ImageFillArchive* msg) {
  return *msg->_impl_.fillsize_;
}
const ::TSP::DataReference&
ImageFillArchive::_Internal::originalimagedata(const ImageFillArchive* msg) {
  return *msg->_impl_.originalimagedata_;
}
const ::TSP::Color&
ImageFillArchive::_Internal::referencecolor(const ImageFillArchive* msg) {
  return *msg->_impl_.referencecolor_;
}
const ::TSP::Reference&
ImageFillArchive::_Internal::database_imagedata(const ImageFillArchive* msg) {
  return *msg->_impl_.database_imagedata_;
}
const ::TSP::Reference&
ImageFillArchive::_Internal::database_originalimagedata(const ImageFillArchive* msg) {
  return *msg->_impl_.database_originalimagedata_;
}
void ImageFillArchive::clear_imagedata() {
  if (_impl_.imagedata_ != nullptr) _impl_.imagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void ImageFillArchive::clear_tint() {
  if (_impl_.tint_ != nullptr) _impl_.tint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ImageFillArchive::clear_fillsize() {
  if (_impl_.fillsize_ != nullptr) _impl_.fillsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ImageFillArchive::clear_originalimagedata() {
  if (_impl_.originalimagedata_ != nullptr) _impl_.originalimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void ImageFillArchive::clear_referencecolor() {
  if (_impl_.referencecolor_ != nullptr) _impl_.referencecolor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void ImageFillArchive::clear_database_imagedata() {
  if (_impl_.database_imagedata_ != nullptr) _impl_.database_imagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ImageFillArchive::clear_database_originalimagedata() {
  if (_impl_.database_originalimagedata_ != nullptr) _impl_.database_originalimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
ImageFillArchive::ImageFillArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ImageFillArchive)
}
ImageFillArchive::ImageFillArchive(const ImageFillArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ImageFillArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.database_imagedata_){nullptr}
    , decltype(_impl_.tint_){nullptr}
    , decltype(_impl_.fillsize_){nullptr}
    , decltype(_impl_.database_originalimagedata_){nullptr}
    , decltype(_impl_.imagedata_){nullptr}
    , decltype(_impl_.originalimagedata_){nullptr}
    , decltype(_impl_.referencecolor_){nullptr}
    , decltype(_impl_.technique_){}
    , decltype(_impl_.interpretsuntaggedimagedataasgeneric_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_database_imagedata()) {
    _this->_impl_.database_imagedata_ = new ::TSP::Reference(*from._impl_.database_imagedata_);
  }
  if (from._internal_has_tint()) {
    _this->_impl_.tint_ = new ::TSP::Color(*from._impl_.tint_);
  }
  if (from._internal_has_fillsize()) {
    _this->_impl_.fillsize_ = new ::TSP::Size(*from._impl_.fillsize_);
  }
  if (from._internal_has_database_originalimagedata()) {
    _this->_impl_.database_originalimagedata_ = new ::TSP::Reference(*from._impl_.database_originalimagedata_);
  }
  if (from._internal_has_imagedata()) {
    _this->_impl_.imagedata_ = new ::TSP::DataReference(*from._impl_.imagedata_);
  }
  if (from._internal_has_originalimagedata()) {
    _this->_impl_.originalimagedata_ = new ::TSP::DataReference(*from._impl_.originalimagedata_);
  }
  if (from._internal_has_referencecolor()) {
    _this->_impl_.referencecolor_ = new ::TSP::Color(*from._impl_.referencecolor_);
  }
  ::memcpy(&_impl_.technique_, &from._impl_.technique_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.interpretsuntaggedimagedataasgeneric_) -
    reinterpret_cast<char*>(&_impl_.technique_)) + sizeof(_impl_.interpretsuntaggedimagedataasgeneric_));
  // @@protoc_insertion_point(copy_constructor:TSD.ImageFillArchive)
}

inline void ImageFillArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.database_imagedata_){nullptr}
    , decltype(_impl_.tint_){nullptr}
    , decltype(_impl_.fillsize_){nullptr}
    , decltype(_impl_.database_originalimagedata_){nullptr}
    , decltype(_impl_.imagedata_){nullptr}
    , decltype(_impl_.originalimagedata_){nullptr}
    , decltype(_impl_.referencecolor_){nullptr}
    , decltype(_impl_.technique_){0}
    , decltype(_impl_.interpretsuntaggedimagedataasgeneric_){false}
  };
}

ImageFillArchive::~ImageFillArchive() {
  // @@protoc_insertion_point(destructor:TSD.ImageFillArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImageFillArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.database_imagedata_;
  if (this != internal_default_instance()) delete _impl_.tint_;
  if (this != internal_default_instance()) delete _impl_.fillsize_;
  if (this != internal_default_instance()) delete _impl_.database_originalimagedata_;
  if (this != internal_default_instance()) delete _impl_.imagedata_;
  if (this != internal_default_instance()) delete _impl_.originalimagedata_;
  if (this != internal_default_instance()) delete _impl_.referencecolor_;
}

void ImageFillArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImageFillArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ImageFillArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.database_imagedata_ != nullptr);
      _impl_.database_imagedata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.tint_ != nullptr);
      _impl_.tint_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.fillsize_ != nullptr);
      _impl_.fillsize_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.database_originalimagedata_ != nullptr);
      _impl_.database_originalimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.imagedata_ != nullptr);
      _impl_.imagedata_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.originalimagedata_ != nullptr);
      _impl_.originalimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.referencecolor_ != nullptr);
      _impl_.referencecolor_->Clear();
    }
  }
  _impl_.technique_ = 0;
  _impl_.interpretsuntaggedimagedataasgeneric_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImageFillArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference database_imagedata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_imagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ImageFillArchive.ImageFillTechnique technique = 2 [default = NaturalSize];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::ImageFillArchive_ImageFillTechnique_IsValid(val))) {
            _internal_set_technique(static_cast<::TSD::ImageFillArchive_ImageFillTechnique>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Color tint = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size fillsize = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_fillsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_originalimagedata = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_originalimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference imagedata = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_imagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference originalimagedata = 7 [deprecated = true];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_originalimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool interpretsUntaggedImageDataAsGeneric = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_interpretsuntaggedimagedataasgeneric(&has_bits);
          _impl_.interpretsuntaggedimagedataasgeneric_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Color referencecolor = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_referencecolor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageFillArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ImageFillArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference database_imagedata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::database_imagedata(this),
        _Internal::database_imagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ImageFillArchive.ImageFillTechnique technique = 2 [default = NaturalSize];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_technique(), target);
  }

  // optional .TSP.Color tint = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::tint(this),
        _Internal::tint(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size fillsize = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::fillsize(this),
        _Internal::fillsize(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference database_originalimagedata = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::database_originalimagedata(this),
        _Internal::database_originalimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference imagedata = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::imagedata(this),
        _Internal::imagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference originalimagedata = 7 [deprecated = true];
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::originalimagedata(this),
        _Internal::originalimagedata(this).GetCachedSize(), target, stream);
  }

  // optional bool interpretsUntaggedImageDataAsGeneric = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_interpretsuntaggedimagedataasgeneric(), target);
  }

  // optional .TSP.Color referencecolor = 9;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::referencecolor(this),
        _Internal::referencecolor(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ImageFillArchive)
  return target;
}

size_t ImageFillArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ImageFillArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSP.Reference database_imagedata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_imagedata_);
    }

    // optional .TSP.Color tint = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tint_);
    }

    // optional .TSP.Size fillsize = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fillsize_);
    }

    // optional .TSP.Reference database_originalimagedata = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_originalimagedata_);
    }

    // optional .TSP.DataReference imagedata = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.imagedata_);
    }

    // optional .TSP.DataReference originalimagedata = 7 [deprecated = true];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.originalimagedata_);
    }

    // optional .TSP.Color referencecolor = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.referencecolor_);
    }

    // optional .TSD.ImageFillArchive.ImageFillTechnique technique = 2 [default = NaturalSize];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_technique());
    }

  }
  // optional bool interpretsUntaggedImageDataAsGeneric = 8;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImageFillArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ImageFillArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImageFillArchive::GetClassData() const { return &_class_data_; }


void ImageFillArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ImageFillArchive*>(&to_msg);
  auto& from = static_cast<const ImageFillArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ImageFillArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_database_imagedata()->::TSP::Reference::MergeFrom(
          from._internal_database_imagedata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_tint()->::TSP::Color::MergeFrom(
          from._internal_tint());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_fillsize()->::TSP::Size::MergeFrom(
          from._internal_fillsize());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_database_originalimagedata()->::TSP::Reference::MergeFrom(
          from._internal_database_originalimagedata());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_imagedata()->::TSP::DataReference::MergeFrom(
          from._internal_imagedata());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_originalimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_originalimagedata());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_referencecolor()->::TSP::Color::MergeFrom(
          from._internal_referencecolor());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.technique_ = from._impl_.technique_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_interpretsuntaggedimagedataasgeneric(from._internal_interpretsuntaggedimagedataasgeneric());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImageFillArchive::CopyFrom(const ImageFillArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ImageFillArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageFillArchive::IsInitialized() const {
  if (_internal_has_database_imagedata()) {
    if (!_impl_.database_imagedata_->IsInitialized()) return false;
  }
  if (_internal_has_tint()) {
    if (!_impl_.tint_->IsInitialized()) return false;
  }
  if (_internal_has_fillsize()) {
    if (!_impl_.fillsize_->IsInitialized()) return false;
  }
  if (_internal_has_database_originalimagedata()) {
    if (!_impl_.database_originalimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_imagedata()) {
    if (!_impl_.imagedata_->IsInitialized()) return false;
  }
  if (_internal_has_originalimagedata()) {
    if (!_impl_.originalimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_referencecolor()) {
    if (!_impl_.referencecolor_->IsInitialized()) return false;
  }
  return true;
}

void ImageFillArchive::InternalSwap(ImageFillArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImageFillArchive, _impl_.interpretsuntaggedimagedataasgeneric_)
      + sizeof(ImageFillArchive::_impl_.interpretsuntaggedimagedataasgeneric_)
      - PROTOBUF_FIELD_OFFSET(ImageFillArchive, _impl_.database_imagedata_)>(
          reinterpret_cast<char*>(&_impl_.database_imagedata_),
          reinterpret_cast<char*>(&other->_impl_.database_imagedata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ImageFillArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[15]);
}

// ===================================================================

class FillArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FillArchive>()._impl_._has_bits_);
  static const ::TSP::Color& color(const FillArchive* msg);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::GradientArchive& gradient(const FillArchive* msg);
  static void set_has_gradient(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::ImageFillArchive& image(const FillArchive* msg);
  static void set_has_image(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSP::Color&
FillArchive::_Internal::color(const FillArchive* msg) {
  return *msg->_impl_.color_;
}
const ::TSD::GradientArchive&
FillArchive::_Internal::gradient(const FillArchive* msg) {
  return *msg->_impl_.gradient_;
}
const ::TSD::ImageFillArchive&
FillArchive::_Internal::image(const FillArchive* msg) {
  return *msg->_impl_.image_;
}
void FillArchive::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
FillArchive::FillArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.FillArchive)
}
FillArchive::FillArchive(const FillArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FillArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.gradient_){nullptr}
    , decltype(_impl_.image_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::TSP::Color(*from._impl_.color_);
  }
  if (from._internal_has_gradient()) {
    _this->_impl_.gradient_ = new ::TSD::GradientArchive(*from._impl_.gradient_);
  }
  if (from._internal_has_image()) {
    _this->_impl_.image_ = new ::TSD::ImageFillArchive(*from._impl_.image_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.FillArchive)
}

inline void FillArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.gradient_){nullptr}
    , decltype(_impl_.image_){nullptr}
  };
}

FillArchive::~FillArchive() {
  // @@protoc_insertion_point(destructor:TSD.FillArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FillArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  if (this != internal_default_instance()) delete _impl_.color_;
  if (this != internal_default_instance()) delete _impl_.gradient_;
  if (this != internal_default_instance()) delete _impl_.image_;
}

void FillArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FillArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.FillArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.color_ != nullptr);
      _impl_.color_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.gradient_ != nullptr);
      _impl_.gradient_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.image_ != nullptr);
      _impl_.image_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FillArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Color color = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.GradientArchive gradient = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_gradient(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ImageFillArchive image = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_image(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((800u <= tag)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FillArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.FillArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Color color = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.GradientArchive gradient = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::gradient(this),
        _Internal::gradient(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ImageFillArchive image = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::image(this),
        _Internal::image(this).GetCachedSize(), target, stream);
  }

  // Extension range [100, 536870912)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 100, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.FillArchive)
  return target;
}

size_t FillArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.FillArchive)
  size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSP.Color color = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.color_);
    }

    // optional .TSD.GradientArchive gradient = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.gradient_);
    }

    // optional .TSD.ImageFillArchive image = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.image_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FillArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FillArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FillArchive::GetClassData() const { return &_class_data_; }


void FillArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FillArchive*>(&to_msg);
  auto& from = static_cast<const FillArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.FillArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_color()->::TSP::Color::MergeFrom(
          from._internal_color());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_gradient()->::TSD::GradientArchive::MergeFrom(
          from._internal_gradient());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_image()->::TSD::ImageFillArchive::MergeFrom(
          from._internal_image());
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FillArchive::CopyFrom(const FillArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.FillArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FillArchive::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized()) {
    return false;
  }

  if (_internal_has_color()) {
    if (!_impl_.color_->IsInitialized()) return false;
  }
  if (_internal_has_gradient()) {
    if (!_impl_.gradient_->IsInitialized()) return false;
  }
  if (_internal_has_image()) {
    if (!_impl_.image_->IsInitialized()) return false;
  }
  return true;
}

void FillArchive::InternalSwap(FillArchive* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FillArchive, _impl_.image_)
      + sizeof(FillArchive::_impl_.image_)
      - PROTOBUF_FIELD_OFFSET(FillArchive, _impl_.color_)>(
          reinterpret_cast<char*>(&_impl_.color_),
          reinterpret_cast<char*>(&other->_impl_.color_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FillArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[16]);
}

// ===================================================================

class StrokePatternArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StrokePatternArchive>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_phase(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

StrokePatternArchive::StrokePatternArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.StrokePatternArchive)
}
StrokePatternArchive::StrokePatternArchive(const StrokePatternArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StrokePatternArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pattern_){from._impl_.pattern_}
    , decltype(_impl_.type_){}
    , decltype(_impl_.phase_){}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.count_));
  // @@protoc_insertion_point(copy_constructor:TSD.StrokePatternArchive)
}

inline void StrokePatternArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pattern_){arena}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.phase_){0}
    , decltype(_impl_.count_){0u}
  };
}

StrokePatternArchive::~StrokePatternArchive() {
  // @@protoc_insertion_point(destructor:TSD.StrokePatternArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StrokePatternArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pattern_.~RepeatedField();
}

void StrokePatternArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StrokePatternArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.StrokePatternArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pattern_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.count_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StrokePatternArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.StrokePatternArchive.StrokePatternType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::StrokePatternArchive_StrokePatternType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::StrokePatternArchive_StrokePatternType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float phase = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_phase(&has_bits);
          _impl_.phase_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float pattern = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_pattern(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<37>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_pattern(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StrokePatternArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.StrokePatternArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.StrokePatternArchive.StrokePatternType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional float phase = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_phase(), target);
  }

  // optional uint32 count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_count(), target);
  }

  // repeated float pattern = 4;
  for (int i = 0, n = this->_internal_pattern_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_pattern(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.StrokePatternArchive)
  return target;
}

size_t StrokePatternArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.StrokePatternArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float pattern = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_pattern_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_pattern_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSD.StrokePatternArchive.StrokePatternType type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional float phase = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StrokePatternArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StrokePatternArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StrokePatternArchive::GetClassData() const { return &_class_data_; }


void StrokePatternArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StrokePatternArchive*>(&to_msg);
  auto& from = static_cast<const StrokePatternArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.StrokePatternArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.pattern_.MergeFrom(from._impl_.pattern_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.phase_ = from._impl_.phase_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StrokePatternArchive::CopyFrom(const StrokePatternArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.StrokePatternArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StrokePatternArchive::IsInitialized() const {
  return true;
}

void StrokePatternArchive::InternalSwap(StrokePatternArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.pattern_.InternalSwap(&other->_impl_.pattern_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StrokePatternArchive, _impl_.count_)
      + sizeof(StrokePatternArchive::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(StrokePatternArchive, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StrokePatternArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[17]);
}

// ===================================================================

class StrokeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StrokeArchive>()._impl_._has_bits_);
  static const ::TSP::Color& color(const StrokeArchive* msg);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_cap(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_join(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_miter_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::TSD::StrokePatternArchive& pattern(const StrokeArchive* msg);
  static void set_has_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::SmartStrokeArchive& smart_stroke(const StrokeArchive* msg);
  static void set_has_smart_stroke(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::FrameArchive& frame(const StrokeArchive* msg);
  static void set_has_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSD::PatternedStrokeArchive& patterned_stroke(const StrokeArchive* msg);
  static void set_has_patterned_stroke(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::TSP::Color&
StrokeArchive::_Internal::color(const StrokeArchive* msg) {
  return *msg->_impl_.color_;
}
const ::TSD::StrokePatternArchive&
StrokeArchive::_Internal::pattern(const StrokeArchive* msg) {
  return *msg->_impl_.pattern_;
}
const ::TSD::SmartStrokeArchive&
StrokeArchive::_Internal::smart_stroke(const StrokeArchive* msg) {
  return *msg->_impl_.smart_stroke_;
}
const ::TSD::FrameArchive&
StrokeArchive::_Internal::frame(const StrokeArchive* msg) {
  return *msg->_impl_.frame_;
}
const ::TSD::PatternedStrokeArchive&
StrokeArchive::_Internal::patterned_stroke(const StrokeArchive* msg) {
  return *msg->_impl_.patterned_stroke_;
}
void StrokeArchive::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
StrokeArchive::StrokeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.StrokeArchive)
}
StrokeArchive::StrokeArchive(const StrokeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StrokeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.pattern_){nullptr}
    , decltype(_impl_.smart_stroke_){nullptr}
    , decltype(_impl_.frame_){nullptr}
    , decltype(_impl_.patterned_stroke_){nullptr}
    , decltype(_impl_.width_){}
    , decltype(_impl_.cap_){}
    , decltype(_impl_.join_){}
    , decltype(_impl_.miter_limit_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::TSP::Color(*from._impl_.color_);
  }
  if (from._internal_has_pattern()) {
    _this->_impl_.pattern_ = new ::TSD::StrokePatternArchive(*from._impl_.pattern_);
  }
  if (from._internal_has_smart_stroke()) {
    _this->_impl_.smart_stroke_ = new ::TSD::SmartStrokeArchive(*from._impl_.smart_stroke_);
  }
  if (from._internal_has_frame()) {
    _this->_impl_.frame_ = new ::TSD::FrameArchive(*from._impl_.frame_);
  }
  if (from._internal_has_patterned_stroke()) {
    _this->_impl_.patterned_stroke_ = new ::TSD::PatternedStrokeArchive(*from._impl_.patterned_stroke_);
  }
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.miter_limit_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.miter_limit_));
  // @@protoc_insertion_point(copy_constructor:TSD.StrokeArchive)
}

inline void StrokeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.pattern_){nullptr}
    , decltype(_impl_.smart_stroke_){nullptr}
    , decltype(_impl_.frame_){nullptr}
    , decltype(_impl_.patterned_stroke_){nullptr}
    , decltype(_impl_.width_){0}
    , decltype(_impl_.cap_){0}
    , decltype(_impl_.join_){0}
    , decltype(_impl_.miter_limit_){0}
  };
}

StrokeArchive::~StrokeArchive() {
  // @@protoc_insertion_point(destructor:TSD.StrokeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StrokeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.color_;
  if (this != internal_default_instance()) delete _impl_.pattern_;
  if (this != internal_default_instance()) delete _impl_.smart_stroke_;
  if (this != internal_default_instance()) delete _impl_.frame_;
  if (this != internal_default_instance()) delete _impl_.patterned_stroke_;
}

void StrokeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StrokeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.StrokeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.color_ != nullptr);
      _impl_.color_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.pattern_ != nullptr);
      _impl_.pattern_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.smart_stroke_ != nullptr);
      _impl_.smart_stroke_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.frame_ != nullptr);
      _impl_.frame_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.patterned_stroke_ != nullptr);
      _impl_.patterned_stroke_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.join_) -
        reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.join_));
  }
  _impl_.miter_limit_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StrokeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Color color = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.StrokeArchive.LineCap cap = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::StrokeArchive_LineCap_IsValid(val))) {
            _internal_set_cap(static_cast<::TSD::StrokeArchive_LineCap>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.LineJoin join = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::LineJoin_IsValid(val))) {
            _internal_set_join(static_cast<::TSD::LineJoin>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float miter_limit = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_miter_limit(&has_bits);
          _impl_.miter_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.StrokePatternArchive pattern = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_pattern(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.SmartStrokeArchive smart_stroke = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_smart_stroke(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.FrameArchive frame = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_frame(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.PatternedStrokeArchive patterned_stroke = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_patterned_stroke(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StrokeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.StrokeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Color color = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  // optional float width = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_width(), target);
  }

  // optional .TSD.StrokeArchive.LineCap cap = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_cap(), target);
  }

  // optional .TSD.LineJoin join = 4;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_join(), target);
  }

  // optional float miter_limit = 5;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_miter_limit(), target);
  }

  // optional .TSD.StrokePatternArchive pattern = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::pattern(this),
        _Internal::pattern(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.SmartStrokeArchive smart_stroke = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::smart_stroke(this),
        _Internal::smart_stroke(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.FrameArchive frame = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::frame(this),
        _Internal::frame(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.PatternedStrokeArchive patterned_stroke = 9;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::patterned_stroke(this),
        _Internal::patterned_stroke(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.StrokeArchive)
  return target;
}

size_t StrokeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.StrokeArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSP.Color color = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.color_);
    }

    // optional .TSD.StrokePatternArchive pattern = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pattern_);
    }

    // optional .TSD.SmartStrokeArchive smart_stroke = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.smart_stroke_);
    }

    // optional .TSD.FrameArchive frame = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.frame_);
    }

    // optional .TSD.PatternedStrokeArchive patterned_stroke = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.patterned_stroke_);
    }

    // optional float width = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional .TSD.StrokeArchive.LineCap cap = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_cap());
    }

    // optional .TSD.LineJoin join = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_join());
    }

  }
  // optional float miter_limit = 5;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StrokeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StrokeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StrokeArchive::GetClassData() const { return &_class_data_; }


void StrokeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StrokeArchive*>(&to_msg);
  auto& from = static_cast<const StrokeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.StrokeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_color()->::TSP::Color::MergeFrom(
          from._internal_color());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_pattern()->::TSD::StrokePatternArchive::MergeFrom(
          from._internal_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_smart_stroke()->::TSD::SmartStrokeArchive::MergeFrom(
          from._internal_smart_stroke());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_frame()->::TSD::FrameArchive::MergeFrom(
          from._internal_frame());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_patterned_stroke()->::TSD::PatternedStrokeArchive::MergeFrom(
          from._internal_patterned_stroke());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.cap_ = from._impl_.cap_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.join_ = from._impl_.join_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_miter_limit(from._internal_miter_limit());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StrokeArchive::CopyFrom(const StrokeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.StrokeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StrokeArchive::IsInitialized() const {
  if (_internal_has_color()) {
    if (!_impl_.color_->IsInitialized()) return false;
  }
  if (_internal_has_smart_stroke()) {
    if (!_impl_.smart_stroke_->IsInitialized()) return false;
  }
  return true;
}

void StrokeArchive::InternalSwap(StrokeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StrokeArchive, _impl_.miter_limit_)
      + sizeof(StrokeArchive::_impl_.miter_limit_)
      - PROTOBUF_FIELD_OFFSET(StrokeArchive, _impl_.color_)>(
          reinterpret_cast<char*>(&_impl_.color_),
          reinterpret_cast<char*>(&other->_impl_.color_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StrokeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[18]);
}

// ===================================================================

class SmartStrokeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SmartStrokeArchive>()._impl_._has_bits_);
  static void set_has_stroke_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_random_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::ReferenceDictionary& parametervalues(const SmartStrokeArchive* msg);
  static void set_has_parametervalues(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pattern_offset_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSP::ReferenceDictionary&
SmartStrokeArchive::_Internal::parametervalues(const SmartStrokeArchive* msg) {
  return *msg->_impl_.parametervalues_;
}
void SmartStrokeArchive::clear_parametervalues() {
  if (_impl_.parametervalues_ != nullptr) _impl_.parametervalues_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
SmartStrokeArchive::SmartStrokeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.SmartStrokeArchive)
}
SmartStrokeArchive::SmartStrokeArchive(const SmartStrokeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SmartStrokeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stroke_name_){}
    , decltype(_impl_.parametervalues_){nullptr}
    , decltype(_impl_.pattern_offset_distance_){}
    , decltype(_impl_.random_seed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stroke_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stroke_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stroke_name()) {
    _this->_impl_.stroke_name_.Set(from._internal_stroke_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_parametervalues()) {
    _this->_impl_.parametervalues_ = new ::TSP::ReferenceDictionary(*from._impl_.parametervalues_);
  }
  ::memcpy(&_impl_.pattern_offset_distance_, &from._impl_.pattern_offset_distance_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.random_seed_) -
    reinterpret_cast<char*>(&_impl_.pattern_offset_distance_)) + sizeof(_impl_.random_seed_));
  // @@protoc_insertion_point(copy_constructor:TSD.SmartStrokeArchive)
}

inline void SmartStrokeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stroke_name_){}
    , decltype(_impl_.parametervalues_){nullptr}
    , decltype(_impl_.pattern_offset_distance_){0}
    , decltype(_impl_.random_seed_){0u}
  };
  _impl_.stroke_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stroke_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SmartStrokeArchive::~SmartStrokeArchive() {
  // @@protoc_insertion_point(destructor:TSD.SmartStrokeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SmartStrokeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stroke_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.parametervalues_;
}

void SmartStrokeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SmartStrokeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.SmartStrokeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.stroke_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.parametervalues_ != nullptr);
      _impl_.parametervalues_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.pattern_offset_distance_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.random_seed_) -
        reinterpret_cast<char*>(&_impl_.pattern_offset_distance_)) + sizeof(_impl_.random_seed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SmartStrokeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string stroke_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_stroke_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.SmartStrokeArchive.stroke_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 random_seed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_random_seed(&has_bits);
          _impl_.random_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.ReferenceDictionary parameterValues = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_parametervalues(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double pattern_offset_distance = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_pattern_offset_distance(&has_bits);
          _impl_.pattern_offset_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SmartStrokeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.SmartStrokeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string stroke_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_stroke_name().data(), static_cast<int>(this->_internal_stroke_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.SmartStrokeArchive.stroke_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_stroke_name(), target);
  }

  // optional uint32 random_seed = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_random_seed(), target);
  }

  // optional .TSP.ReferenceDictionary parameterValues = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::parametervalues(this),
        _Internal::parametervalues(this).GetCachedSize(), target, stream);
  }

  // optional double pattern_offset_distance = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_pattern_offset_distance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.SmartStrokeArchive)
  return target;
}

size_t SmartStrokeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.SmartStrokeArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string stroke_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_stroke_name());
    }

    // optional .TSP.ReferenceDictionary parameterValues = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.parametervalues_);
    }

    // optional double pattern_offset_distance = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional uint32 random_seed = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_random_seed());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SmartStrokeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SmartStrokeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SmartStrokeArchive::GetClassData() const { return &_class_data_; }


void SmartStrokeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SmartStrokeArchive*>(&to_msg);
  auto& from = static_cast<const SmartStrokeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.SmartStrokeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stroke_name(from._internal_stroke_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_parametervalues()->::TSP::ReferenceDictionary::MergeFrom(
          from._internal_parametervalues());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pattern_offset_distance_ = from._impl_.pattern_offset_distance_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.random_seed_ = from._impl_.random_seed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SmartStrokeArchive::CopyFrom(const SmartStrokeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.SmartStrokeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SmartStrokeArchive::IsInitialized() const {
  if (_internal_has_parametervalues()) {
    if (!_impl_.parametervalues_->IsInitialized()) return false;
  }
  return true;
}

void SmartStrokeArchive::InternalSwap(SmartStrokeArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stroke_name_, lhs_arena,
      &other->_impl_.stroke_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SmartStrokeArchive, _impl_.random_seed_)
      + sizeof(SmartStrokeArchive::_impl_.random_seed_)
      - PROTOBUF_FIELD_OFFSET(SmartStrokeArchive, _impl_.parametervalues_)>(
          reinterpret_cast<char*>(&_impl_.parametervalues_),
          reinterpret_cast<char*>(&other->_impl_.parametervalues_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SmartStrokeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[19]);
}

// ===================================================================

class FrameArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FrameArchive>()._impl_._has_bits_);
  static void set_has_framename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_assetscale(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FrameArchive::FrameArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.FrameArchive)
}
FrameArchive::FrameArchive(const FrameArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FrameArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.framename_){}
    , decltype(_impl_.assetscale_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.framename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.framename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_framename()) {
    _this->_impl_.framename_.Set(from._internal_framename(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.assetscale_ = from._impl_.assetscale_;
  // @@protoc_insertion_point(copy_constructor:TSD.FrameArchive)
}

inline void FrameArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.framename_){}
    , decltype(_impl_.assetscale_){0}
  };
  _impl_.framename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.framename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FrameArchive::~FrameArchive() {
  // @@protoc_insertion_point(destructor:TSD.FrameArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FrameArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.framename_.Destroy();
}

void FrameArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FrameArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.FrameArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.framename_.ClearNonDefaultToEmpty();
  }
  _impl_.assetscale_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FrameArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string frameName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_framename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.FrameArchive.frameName");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional float assetScale = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_assetscale(&has_bits);
          _impl_.assetscale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FrameArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.FrameArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string frameName = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_framename().data(), static_cast<int>(this->_internal_framename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.FrameArchive.frameName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_framename(), target);
  }

  // optional float assetScale = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_assetscale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.FrameArchive)
  return target;
}

size_t FrameArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.FrameArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string frameName = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_framename());
    }

    // optional float assetScale = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FrameArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FrameArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FrameArchive::GetClassData() const { return &_class_data_; }


void FrameArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FrameArchive*>(&to_msg);
  auto& from = static_cast<const FrameArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.FrameArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_framename(from._internal_framename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.assetscale_ = from._impl_.assetscale_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FrameArchive::CopyFrom(const FrameArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.FrameArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameArchive::IsInitialized() const {
  return true;
}

void FrameArchive::InternalSwap(FrameArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.framename_, lhs_arena,
      &other->_impl_.framename_, rhs_arena
  );
  swap(_impl_.assetscale_, other->_impl_.assetscale_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FrameArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[20]);
}

// ===================================================================

class PatternedStrokeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PatternedStrokeArchive>()._impl_._has_bits_);
  static void set_has_pattern_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PatternedStrokeArchive::PatternedStrokeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.PatternedStrokeArchive)
}
PatternedStrokeArchive::PatternedStrokeArchive(const PatternedStrokeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PatternedStrokeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pattern_name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pattern_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pattern_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pattern_name()) {
    _this->_impl_.pattern_name_.Set(from._internal_pattern_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:TSD.PatternedStrokeArchive)
}

inline void PatternedStrokeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pattern_name_){}
  };
  _impl_.pattern_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pattern_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PatternedStrokeArchive::~PatternedStrokeArchive() {
  // @@protoc_insertion_point(destructor:TSD.PatternedStrokeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PatternedStrokeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pattern_name_.Destroy();
}

void PatternedStrokeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PatternedStrokeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.PatternedStrokeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.pattern_name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PatternedStrokeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string pattern_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_pattern_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.PatternedStrokeArchive.pattern_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PatternedStrokeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.PatternedStrokeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string pattern_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_pattern_name().data(), static_cast<int>(this->_internal_pattern_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.PatternedStrokeArchive.pattern_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_pattern_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.PatternedStrokeArchive)
  return target;
}

size_t PatternedStrokeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.PatternedStrokeArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string pattern_name = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_pattern_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PatternedStrokeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PatternedStrokeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PatternedStrokeArchive::GetClassData() const { return &_class_data_; }


void PatternedStrokeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PatternedStrokeArchive*>(&to_msg);
  auto& from = static_cast<const PatternedStrokeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.PatternedStrokeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pattern_name()) {
    _this->_internal_set_pattern_name(from._internal_pattern_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PatternedStrokeArchive::CopyFrom(const PatternedStrokeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.PatternedStrokeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PatternedStrokeArchive::IsInitialized() const {
  return true;
}

void PatternedStrokeArchive::InternalSwap(PatternedStrokeArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pattern_name_, lhs_arena,
      &other->_impl_.pattern_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PatternedStrokeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[21]);
}

// ===================================================================

class LineEndArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<LineEndArchive>()._impl_._has_bits_);
  static const ::TSP::Path& path(const LineEndArchive* msg);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_line_join(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Point& end_point(const LineEndArchive* msg);
  static void set_has_end_point(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_filled(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::Path&
LineEndArchive::_Internal::path(const LineEndArchive* msg) {
  return *msg->_impl_.path_;
}
const ::TSP::Point&
LineEndArchive::_Internal::end_point(const LineEndArchive* msg) {
  return *msg->_impl_.end_point_;
}
void LineEndArchive::clear_path() {
  if (_impl_.path_ != nullptr) _impl_.path_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void LineEndArchive::clear_end_point() {
  if (_impl_.end_point_ != nullptr) _impl_.end_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
LineEndArchive::LineEndArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.LineEndArchive)
}
LineEndArchive::LineEndArchive(const LineEndArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LineEndArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.identifier_){}
    , decltype(_impl_.path_){nullptr}
    , decltype(_impl_.end_point_){nullptr}
    , decltype(_impl_.line_join_){}
    , decltype(_impl_.is_filled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    _this->_impl_.identifier_.Set(from._internal_identifier(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_path()) {
    _this->_impl_.path_ = new ::TSP::Path(*from._impl_.path_);
  }
  if (from._internal_has_end_point()) {
    _this->_impl_.end_point_ = new ::TSP::Point(*from._impl_.end_point_);
  }
  ::memcpy(&_impl_.line_join_, &from._impl_.line_join_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_filled_) -
    reinterpret_cast<char*>(&_impl_.line_join_)) + sizeof(_impl_.is_filled_));
  // @@protoc_insertion_point(copy_constructor:TSD.LineEndArchive)
}

inline void LineEndArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.identifier_){}
    , decltype(_impl_.path_){nullptr}
    , decltype(_impl_.end_point_){nullptr}
    , decltype(_impl_.line_join_){0}
    , decltype(_impl_.is_filled_){false}
  };
  _impl_.identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LineEndArchive::~LineEndArchive() {
  // @@protoc_insertion_point(destructor:TSD.LineEndArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LineEndArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.identifier_.Destroy();
  if (this != internal_default_instance()) delete _impl_.path_;
  if (this != internal_default_instance()) delete _impl_.end_point_;
}

void LineEndArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LineEndArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.LineEndArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.path_ != nullptr);
      _impl_.path_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.end_point_ != nullptr);
      _impl_.end_point_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.line_join_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_filled_) -
        reinterpret_cast<char*>(&_impl_.line_join_)) + sizeof(_impl_.is_filled_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LineEndArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Path path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.LineJoin line_join = 2 [default = MiterJoin];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::LineJoin_IsValid(val))) {
            _internal_set_line_join(static_cast<::TSD::LineJoin>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Point end_point = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_end_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_filled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_filled(&has_bits);
          _impl_.is_filled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string identifier = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.LineEndArchive.identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LineEndArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.LineEndArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Path path = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::path(this),
        _Internal::path(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.LineJoin line_join = 2 [default = MiterJoin];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_line_join(), target);
  }

  // optional .TSP.Point end_point = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::end_point(this),
        _Internal::end_point(this).GetCachedSize(), target, stream);
  }

  // optional bool is_filled = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_filled(), target);
  }

  // optional string identifier = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_identifier().data(), static_cast<int>(this->_internal_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.LineEndArchive.identifier");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.LineEndArchive)
  return target;
}

size_t LineEndArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.LineEndArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string identifier = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional .TSP.Path path = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.path_);
    }

    // optional .TSP.Point end_point = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.end_point_);
    }

    // optional .TSD.LineJoin line_join = 2 [default = MiterJoin];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_line_join());
    }

    // optional bool is_filled = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LineEndArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LineEndArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LineEndArchive::GetClassData() const { return &_class_data_; }


void LineEndArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LineEndArchive*>(&to_msg);
  auto& from = static_cast<const LineEndArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.LineEndArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_path()->::TSP::Path::MergeFrom(
          from._internal_path());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_end_point()->::TSP::Point::MergeFrom(
          from._internal_end_point());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.line_join_ = from._impl_.line_join_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.is_filled_ = from._impl_.is_filled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LineEndArchive::CopyFrom(const LineEndArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.LineEndArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LineEndArchive::IsInitialized() const {
  if (_internal_has_path()) {
    if (!_impl_.path_->IsInitialized()) return false;
  }
  if (_internal_has_end_point()) {
    if (!_impl_.end_point_->IsInitialized()) return false;
  }
  return true;
}

void LineEndArchive::InternalSwap(LineEndArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.identifier_, lhs_arena,
      &other->_impl_.identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LineEndArchive, _impl_.is_filled_)
      + sizeof(LineEndArchive::_impl_.is_filled_)
      - PROTOBUF_FIELD_OFFSET(LineEndArchive, _impl_.path_)>(
          reinterpret_cast<char*>(&_impl_.path_),
          reinterpret_cast<char*>(&other->_impl_.path_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LineEndArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[22]);
}

// ===================================================================

class ShadowArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShadowArchive>()._impl_._has_bits_);
  static const ::TSP::Color& color(const ShadowArchive* msg);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_is_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSD::DropShadowArchive& dropshadow(const ShadowArchive* msg);
  static void set_has_dropshadow(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::ContactShadowArchive& contactshadow(const ShadowArchive* msg);
  static void set_has_contactshadow(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::CurvedShadowArchive& curvedshadow(const ShadowArchive* msg);
  static void set_has_curvedshadow(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::TSP::Color&
ShadowArchive::_Internal::color(const ShadowArchive* msg) {
  return *msg->_impl_.color_;
}
const ::TSD::DropShadowArchive&
ShadowArchive::_Internal::dropshadow(const ShadowArchive* msg) {
  return *msg->_impl_.dropshadow_;
}
const ::TSD::ContactShadowArchive&
ShadowArchive::_Internal::contactshadow(const ShadowArchive* msg) {
  return *msg->_impl_.contactshadow_;
}
const ::TSD::CurvedShadowArchive&
ShadowArchive::_Internal::curvedshadow(const ShadowArchive* msg) {
  return *msg->_impl_.curvedshadow_;
}
void ShadowArchive::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ShadowArchive::ShadowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ShadowArchive)
}
ShadowArchive::ShadowArchive(const ShadowArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShadowArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.dropshadow_){nullptr}
    , decltype(_impl_.contactshadow_){nullptr}
    , decltype(_impl_.curvedshadow_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.is_enabled_){}
    , decltype(_impl_.angle_){}
    , decltype(_impl_.offset_){}
    , decltype(_impl_.radius_){}
    , decltype(_impl_.opacity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::TSP::Color(*from._impl_.color_);
  }
  if (from._internal_has_dropshadow()) {
    _this->_impl_.dropshadow_ = new ::TSD::DropShadowArchive(*from._impl_.dropshadow_);
  }
  if (from._internal_has_contactshadow()) {
    _this->_impl_.contactshadow_ = new ::TSD::ContactShadowArchive(*from._impl_.contactshadow_);
  }
  if (from._internal_has_curvedshadow()) {
    _this->_impl_.curvedshadow_ = new ::TSD::CurvedShadowArchive(*from._impl_.curvedshadow_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.opacity_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.opacity_));
  // @@protoc_insertion_point(copy_constructor:TSD.ShadowArchive)
}

inline void ShadowArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.dropshadow_){nullptr}
    , decltype(_impl_.contactshadow_){nullptr}
    , decltype(_impl_.curvedshadow_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.is_enabled_){true}
    , decltype(_impl_.angle_){315}
    , decltype(_impl_.offset_){5}
    , decltype(_impl_.radius_){1}
    , decltype(_impl_.opacity_){1}
  };
}

ShadowArchive::~ShadowArchive() {
  // @@protoc_insertion_point(destructor:TSD.ShadowArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShadowArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.color_;
  if (this != internal_default_instance()) delete _impl_.dropshadow_;
  if (this != internal_default_instance()) delete _impl_.contactshadow_;
  if (this != internal_default_instance()) delete _impl_.curvedshadow_;
}

void ShadowArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShadowArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ShadowArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.color_ != nullptr);
      _impl_.color_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.dropshadow_ != nullptr);
      _impl_.dropshadow_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.contactshadow_ != nullptr);
      _impl_.contactshadow_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.curvedshadow_ != nullptr);
      _impl_.curvedshadow_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    _impl_.type_ = 0;
    _impl_.is_enabled_ = true;
    _impl_.angle_ = 315;
    _impl_.offset_ = 5;
  }
  if (cached_has_bits & 0x00000300u) {
    _impl_.radius_ = 1;
    _impl_.opacity_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShadowArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Color color = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float angle = 2 [default = 315];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_angle(&has_bits);
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float offset = 3 [default = 5];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 radius = 4 [default = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_radius(&has_bits);
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float opacity = 5 [default = 1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_opacity(&has_bits);
          _impl_.opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_enabled = 6 [default = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_enabled(&has_bits);
          _impl_.is_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ShadowArchive.ShadowType type = 7 [default = TSDDropShadow];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::ShadowArchive_ShadowType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::ShadowArchive_ShadowType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.DropShadowArchive dropShadow = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_dropshadow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ContactShadowArchive contactShadow = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_contactshadow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.CurvedShadowArchive curvedShadow = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_curvedshadow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShadowArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ShadowArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Color color = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  // optional float angle = 2 [default = 315];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_angle(), target);
  }

  // optional float offset = 3 [default = 5];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_offset(), target);
  }

  // optional int32 radius = 4 [default = 1];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_radius(), target);
  }

  // optional float opacity = 5 [default = 1];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_opacity(), target);
  }

  // optional bool is_enabled = 6 [default = true];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_enabled(), target);
  }

  // optional .TSD.ShadowArchive.ShadowType type = 7 [default = TSDDropShadow];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_type(), target);
  }

  // optional .TSD.DropShadowArchive dropShadow = 8;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::dropshadow(this),
        _Internal::dropshadow(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ContactShadowArchive contactShadow = 9;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::contactshadow(this),
        _Internal::contactshadow(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.CurvedShadowArchive curvedShadow = 10;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::curvedshadow(this),
        _Internal::curvedshadow(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ShadowArchive)
  return target;
}

size_t ShadowArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ShadowArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSP.Color color = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.color_);
    }

    // optional .TSD.DropShadowArchive dropShadow = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dropshadow_);
    }

    // optional .TSD.ContactShadowArchive contactShadow = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.contactshadow_);
    }

    // optional .TSD.CurvedShadowArchive curvedShadow = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.curvedshadow_);
    }

    // optional .TSD.ShadowArchive.ShadowType type = 7 [default = TSDDropShadow];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional bool is_enabled = 6 [default = true];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional float angle = 2 [default = 315];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float offset = 3 [default = 5];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 radius = 4 [default = 1];
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_radius());
    }

    // optional float opacity = 5 [default = 1];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShadowArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShadowArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShadowArchive::GetClassData() const { return &_class_data_; }


void ShadowArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShadowArchive*>(&to_msg);
  auto& from = static_cast<const ShadowArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ShadowArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_color()->::TSP::Color::MergeFrom(
          from._internal_color());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_dropshadow()->::TSD::DropShadowArchive::MergeFrom(
          from._internal_dropshadow());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_contactshadow()->::TSD::ContactShadowArchive::MergeFrom(
          from._internal_contactshadow());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_curvedshadow()->::TSD::CurvedShadowArchive::MergeFrom(
          from._internal_curvedshadow());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.is_enabled_ = from._impl_.is_enabled_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.angle_ = from._impl_.angle_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.radius_ = from._impl_.radius_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.opacity_ = from._impl_.opacity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShadowArchive::CopyFrom(const ShadowArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ShadowArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShadowArchive::IsInitialized() const {
  if (_internal_has_color()) {
    if (!_impl_.color_->IsInitialized()) return false;
  }
  return true;
}

void ShadowArchive::InternalSwap(ShadowArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShadowArchive, _impl_.type_)
      + sizeof(ShadowArchive::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(ShadowArchive, _impl_.color_)>(
          reinterpret_cast<char*>(&_impl_.color_),
          reinterpret_cast<char*>(&other->_impl_.color_));
  swap(_impl_.is_enabled_, other->_impl_.is_enabled_);
  swap(_impl_.angle_, other->_impl_.angle_);
  swap(_impl_.offset_, other->_impl_.offset_);
  swap(_impl_.radius_, other->_impl_.radius_);
  swap(_impl_.opacity_, other->_impl_.opacity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShadowArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[23]);
}

// ===================================================================

class DropShadowArchive::_Internal {
 public:
};

DropShadowArchive::DropShadowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:TSD.DropShadowArchive)
}
DropShadowArchive::DropShadowArchive(const DropShadowArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  DropShadowArchive* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSD.DropShadowArchive)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DropShadowArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DropShadowArchive::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata DropShadowArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[24]);
}

// ===================================================================

class ContactShadowArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ContactShadowArchive>()._impl_._has_bits_);
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ContactShadowArchive::ContactShadowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ContactShadowArchive)
}
ContactShadowArchive::ContactShadowArchive(const ContactShadowArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContactShadowArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.offset_){}
    , decltype(_impl_.height_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.offset_, &from._impl_.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) -
    reinterpret_cast<char*>(&_impl_.offset_)) + sizeof(_impl_.height_));
  // @@protoc_insertion_point(copy_constructor:TSD.ContactShadowArchive)
}

inline void ContactShadowArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.offset_){0}
    , decltype(_impl_.height_){0.2f}
  };
}

ContactShadowArchive::~ContactShadowArchive() {
  // @@protoc_insertion_point(destructor:TSD.ContactShadowArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContactShadowArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ContactShadowArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContactShadowArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ContactShadowArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.offset_ = 0;
    _impl_.height_ = 0.2f;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContactShadowArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float height = 2 [default = 0.2];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float offset = 4 [default = 0];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContactShadowArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ContactShadowArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float height = 2 [default = 0.2];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_height(), target);
  }

  // optional float offset = 4 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ContactShadowArchive)
  return target;
}

size_t ContactShadowArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ContactShadowArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float offset = 4 [default = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float height = 2 [default = 0.2];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContactShadowArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContactShadowArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContactShadowArchive::GetClassData() const { return &_class_data_; }


void ContactShadowArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContactShadowArchive*>(&to_msg);
  auto& from = static_cast<const ContactShadowArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ContactShadowArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContactShadowArchive::CopyFrom(const ContactShadowArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ContactShadowArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContactShadowArchive::IsInitialized() const {
  return true;
}

void ContactShadowArchive::InternalSwap(ContactShadowArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.offset_, other->_impl_.offset_);
  swap(_impl_.height_, other->_impl_.height_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContactShadowArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[25]);
}

// ===================================================================

class CurvedShadowArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CurvedShadowArchive>()._impl_._has_bits_);
  static void set_has_curve(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CurvedShadowArchive::CurvedShadowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.CurvedShadowArchive)
}
CurvedShadowArchive::CurvedShadowArchive(const CurvedShadowArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CurvedShadowArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.curve_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.curve_ = from._impl_.curve_;
  // @@protoc_insertion_point(copy_constructor:TSD.CurvedShadowArchive)
}

inline void CurvedShadowArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.curve_){0.6f}
  };
}

CurvedShadowArchive::~CurvedShadowArchive() {
  // @@protoc_insertion_point(destructor:TSD.CurvedShadowArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CurvedShadowArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CurvedShadowArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CurvedShadowArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.CurvedShadowArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.curve_ = 0.6f;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CurvedShadowArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float curve = 1 [default = 0.6];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_curve(&has_bits);
          _impl_.curve_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CurvedShadowArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.CurvedShadowArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float curve = 1 [default = 0.6];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_curve(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.CurvedShadowArchive)
  return target;
}

size_t CurvedShadowArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.CurvedShadowArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float curve = 1 [default = 0.6];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CurvedShadowArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CurvedShadowArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CurvedShadowArchive::GetClassData() const { return &_class_data_; }


void CurvedShadowArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CurvedShadowArchive*>(&to_msg);
  auto& from = static_cast<const CurvedShadowArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.CurvedShadowArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_curve()) {
    _this->_internal_set_curve(from._internal_curve());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CurvedShadowArchive::CopyFrom(const CurvedShadowArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.CurvedShadowArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CurvedShadowArchive::IsInitialized() const {
  return true;
}

void CurvedShadowArchive::InternalSwap(CurvedShadowArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.curve_, other->_impl_.curve_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CurvedShadowArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[26]);
}

// ===================================================================

class ReflectionArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ReflectionArchive>()._impl_._has_bits_);
  static void set_has_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ReflectionArchive::ReflectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ReflectionArchive)
}
ReflectionArchive::ReflectionArchive(const ReflectionArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReflectionArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.opacity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.opacity_ = from._impl_.opacity_;
  // @@protoc_insertion_point(copy_constructor:TSD.ReflectionArchive)
}

inline void ReflectionArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.opacity_){0.5f}
  };
}

ReflectionArchive::~ReflectionArchive() {
  // @@protoc_insertion_point(destructor:TSD.ReflectionArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReflectionArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReflectionArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReflectionArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ReflectionArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.opacity_ = 0.5f;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReflectionArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float opacity = 1 [default = 0.5];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_opacity(&has_bits);
          _impl_.opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReflectionArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ReflectionArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float opacity = 1 [default = 0.5];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_opacity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ReflectionArchive)
  return target;
}

size_t ReflectionArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ReflectionArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float opacity = 1 [default = 0.5];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReflectionArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReflectionArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReflectionArchive::GetClassData() const { return &_class_data_; }


void ReflectionArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReflectionArchive*>(&to_msg);
  auto& from = static_cast<const ReflectionArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ReflectionArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_opacity()) {
    _this->_internal_set_opacity(from._internal_opacity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReflectionArchive::CopyFrom(const ReflectionArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ReflectionArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReflectionArchive::IsInitialized() const {
  return true;
}

void ReflectionArchive::InternalSwap(ReflectionArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.opacity_, other->_impl_.opacity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReflectionArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[27]);
}

// ===================================================================

class ImageAdjustmentsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ImageAdjustmentsArchive>()._impl_._has_bits_);
  static void set_has_exposure(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_saturation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_contrast(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_highlights(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_shadows(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_sharpness(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_denoise(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_temperature(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_tint(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_bottom_level(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_top_level(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_gamma(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_enhance(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_represents_sage_adjustments(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

ImageAdjustmentsArchive::ImageAdjustmentsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ImageAdjustmentsArchive)
}
ImageAdjustmentsArchive::ImageAdjustmentsArchive(const ImageAdjustmentsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ImageAdjustmentsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.exposure_){}
    , decltype(_impl_.saturation_){}
    , decltype(_impl_.contrast_){}
    , decltype(_impl_.highlights_){}
    , decltype(_impl_.shadows_){}
    , decltype(_impl_.sharpness_){}
    , decltype(_impl_.denoise_){}
    , decltype(_impl_.temperature_){}
    , decltype(_impl_.tint_){}
    , decltype(_impl_.bottom_level_){}
    , decltype(_impl_.gamma_){}
    , decltype(_impl_.enhance_){}
    , decltype(_impl_.represents_sage_adjustments_){}
    , decltype(_impl_.top_level_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.exposure_, &from._impl_.exposure_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.top_level_) -
    reinterpret_cast<char*>(&_impl_.exposure_)) + sizeof(_impl_.top_level_));
  // @@protoc_insertion_point(copy_constructor:TSD.ImageAdjustmentsArchive)
}

inline void ImageAdjustmentsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.exposure_){0}
    , decltype(_impl_.saturation_){0}
    , decltype(_impl_.contrast_){0}
    , decltype(_impl_.highlights_){0}
    , decltype(_impl_.shadows_){0}
    , decltype(_impl_.sharpness_){0}
    , decltype(_impl_.denoise_){0}
    , decltype(_impl_.temperature_){0}
    , decltype(_impl_.tint_){0}
    , decltype(_impl_.bottom_level_){0}
    , decltype(_impl_.gamma_){0}
    , decltype(_impl_.enhance_){false}
    , decltype(_impl_.represents_sage_adjustments_){false}
    , decltype(_impl_.top_level_){1}
  };
}

ImageAdjustmentsArchive::~ImageAdjustmentsArchive() {
  // @@protoc_insertion_point(destructor:TSD.ImageAdjustmentsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImageAdjustmentsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ImageAdjustmentsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImageAdjustmentsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ImageAdjustmentsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.exposure_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.temperature_) -
        reinterpret_cast<char*>(&_impl_.exposure_)) + sizeof(_impl_.temperature_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.tint_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.represents_sage_adjustments_) -
        reinterpret_cast<char*>(&_impl_.tint_)) + sizeof(_impl_.represents_sage_adjustments_));
    _impl_.top_level_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImageAdjustmentsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float exposure = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_exposure(&has_bits);
          _impl_.exposure_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float saturation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_saturation(&has_bits);
          _impl_.saturation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float contrast = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_contrast(&has_bits);
          _impl_.contrast_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float highlights = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_highlights(&has_bits);
          _impl_.highlights_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float shadows = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_shadows(&has_bits);
          _impl_.shadows_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float sharpness = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_sharpness(&has_bits);
          _impl_.sharpness_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float denoise = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_denoise(&has_bits);
          _impl_.denoise_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float temperature = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_temperature(&has_bits);
          _impl_.temperature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float tint = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_tint(&has_bits);
          _impl_.tint_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float bottom_level = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_bottom_level(&has_bits);
          _impl_.bottom_level_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float top_level = 11 [default = 1];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_top_level(&has_bits);
          _impl_.top_level_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float gamma = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_gamma(&has_bits);
          _impl_.gamma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool enhance = 13 [default = false];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_enhance(&has_bits);
          _impl_.enhance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool represents_sage_adjustments = 14 [default = false];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_represents_sage_adjustments(&has_bits);
          _impl_.represents_sage_adjustments_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageAdjustmentsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ImageAdjustmentsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float exposure = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_exposure(), target);
  }

  // optional float saturation = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_saturation(), target);
  }

  // optional float contrast = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_contrast(), target);
  }

  // optional float highlights = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_highlights(), target);
  }

  // optional float shadows = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_shadows(), target);
  }

  // optional float sharpness = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_sharpness(), target);
  }

  // optional float denoise = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_denoise(), target);
  }

  // optional float temperature = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_temperature(), target);
  }

  // optional float tint = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_tint(), target);
  }

  // optional float bottom_level = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_bottom_level(), target);
  }

  // optional float top_level = 11 [default = 1];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_top_level(), target);
  }

  // optional float gamma = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_gamma(), target);
  }

  // optional bool enhance = 13 [default = false];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_enhance(), target);
  }

  // optional bool represents_sage_adjustments = 14 [default = false];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_represents_sage_adjustments(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ImageAdjustmentsArchive)
  return target;
}

size_t ImageAdjustmentsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ImageAdjustmentsArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float exposure = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float saturation = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float contrast = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float highlights = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float shadows = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float sharpness = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float denoise = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float temperature = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional float tint = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float bottom_level = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float gamma = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional bool enhance = 13 [default = false];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool represents_sage_adjustments = 14 [default = false];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional float top_level = 11 [default = 1];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImageAdjustmentsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ImageAdjustmentsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImageAdjustmentsArchive::GetClassData() const { return &_class_data_; }


void ImageAdjustmentsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ImageAdjustmentsArchive*>(&to_msg);
  auto& from = static_cast<const ImageAdjustmentsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ImageAdjustmentsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.exposure_ = from._impl_.exposure_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.saturation_ = from._impl_.saturation_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.contrast_ = from._impl_.contrast_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.highlights_ = from._impl_.highlights_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.shadows_ = from._impl_.shadows_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.sharpness_ = from._impl_.sharpness_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.denoise_ = from._impl_.denoise_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.temperature_ = from._impl_.temperature_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.tint_ = from._impl_.tint_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.bottom_level_ = from._impl_.bottom_level_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.gamma_ = from._impl_.gamma_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.enhance_ = from._impl_.enhance_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.represents_sage_adjustments_ = from._impl_.represents_sage_adjustments_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.top_level_ = from._impl_.top_level_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImageAdjustmentsArchive::CopyFrom(const ImageAdjustmentsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ImageAdjustmentsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageAdjustmentsArchive::IsInitialized() const {
  return true;
}

void ImageAdjustmentsArchive::InternalSwap(ImageAdjustmentsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImageAdjustmentsArchive, _impl_.represents_sage_adjustments_)
      + sizeof(ImageAdjustmentsArchive::_impl_.represents_sage_adjustments_)
      - PROTOBUF_FIELD_OFFSET(ImageAdjustmentsArchive, _impl_.exposure_)>(
          reinterpret_cast<char*>(&_impl_.exposure_),
          reinterpret_cast<char*>(&other->_impl_.exposure_));
  swap(_impl_.top_level_, other->_impl_.top_level_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ImageAdjustmentsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[28]);
}

// ===================================================================

class ShapeStylePropertiesArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapeStylePropertiesArchive>()._impl_._has_bits_);
  static const ::TSD::FillArchive& fill(const ShapeStylePropertiesArchive* msg);
  static void set_has_fill(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::StrokeArchive& stroke(const ShapeStylePropertiesArchive* msg);
  static void set_has_stroke(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSD::ShadowArchive& shadow(const ShapeStylePropertiesArchive* msg);
  static void set_has_shadow(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::ReflectionArchive& reflection(const ShapeStylePropertiesArchive* msg);
  static void set_has_reflection(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSD::LineEndArchive& head_line_end(const ShapeStylePropertiesArchive* msg);
  static void set_has_head_line_end(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSD::LineEndArchive& tail_line_end(const ShapeStylePropertiesArchive* msg);
  static void set_has_tail_line_end(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::TSD::FillArchive&
ShapeStylePropertiesArchive::_Internal::fill(const ShapeStylePropertiesArchive* msg) {
  return *msg->_impl_.fill_;
}
const ::TSD::StrokeArchive&
ShapeStylePropertiesArchive::_Internal::stroke(const ShapeStylePropertiesArchive* msg) {
  return *msg->_impl_.stroke_;
}
const ::TSD::ShadowArchive&
ShapeStylePropertiesArchive::_Internal::shadow(const ShapeStylePropertiesArchive* msg) {
  return *msg->_impl_.shadow_;
}
const ::TSD::ReflectionArchive&
ShapeStylePropertiesArchive::_Internal::reflection(const ShapeStylePropertiesArchive* msg) {
  return *msg->_impl_.reflection_;
}
const ::TSD::LineEndArchive&
ShapeStylePropertiesArchive::_Internal::head_line_end(const ShapeStylePropertiesArchive* msg) {
  return *msg->_impl_.head_line_end_;
}
const ::TSD::LineEndArchive&
ShapeStylePropertiesArchive::_Internal::tail_line_end(const ShapeStylePropertiesArchive* msg) {
  return *msg->_impl_.tail_line_end_;
}
ShapeStylePropertiesArchive::ShapeStylePropertiesArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ShapeStylePropertiesArchive)
}
ShapeStylePropertiesArchive::ShapeStylePropertiesArchive(const ShapeStylePropertiesArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapeStylePropertiesArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fill_){nullptr}
    , decltype(_impl_.stroke_){nullptr}
    , decltype(_impl_.shadow_){nullptr}
    , decltype(_impl_.reflection_){nullptr}
    , decltype(_impl_.head_line_end_){nullptr}
    , decltype(_impl_.tail_line_end_){nullptr}
    , decltype(_impl_.opacity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_fill()) {
    _this->_impl_.fill_ = new ::TSD::FillArchive(*from._impl_.fill_);
  }
  if (from._internal_has_stroke()) {
    _this->_impl_.stroke_ = new ::TSD::StrokeArchive(*from._impl_.stroke_);
  }
  if (from._internal_has_shadow()) {
    _this->_impl_.shadow_ = new ::TSD::ShadowArchive(*from._impl_.shadow_);
  }
  if (from._internal_has_reflection()) {
    _this->_impl_.reflection_ = new ::TSD::ReflectionArchive(*from._impl_.reflection_);
  }
  if (from._internal_has_head_line_end()) {
    _this->_impl_.head_line_end_ = new ::TSD::LineEndArchive(*from._impl_.head_line_end_);
  }
  if (from._internal_has_tail_line_end()) {
    _this->_impl_.tail_line_end_ = new ::TSD::LineEndArchive(*from._impl_.tail_line_end_);
  }
  _this->_impl_.opacity_ = from._impl_.opacity_;
  // @@protoc_insertion_point(copy_constructor:TSD.ShapeStylePropertiesArchive)
}

inline void ShapeStylePropertiesArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fill_){nullptr}
    , decltype(_impl_.stroke_){nullptr}
    , decltype(_impl_.shadow_){nullptr}
    , decltype(_impl_.reflection_){nullptr}
    , decltype(_impl_.head_line_end_){nullptr}
    , decltype(_impl_.tail_line_end_){nullptr}
    , decltype(_impl_.opacity_){0}
  };
}

ShapeStylePropertiesArchive::~ShapeStylePropertiesArchive() {
  // @@protoc_insertion_point(destructor:TSD.ShapeStylePropertiesArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeStylePropertiesArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.fill_;
  if (this != internal_default_instance()) delete _impl_.stroke_;
  if (this != internal_default_instance()) delete _impl_.shadow_;
  if (this != internal_default_instance()) delete _impl_.reflection_;
  if (this != internal_default_instance()) delete _impl_.head_line_end_;
  if (this != internal_default_instance()) delete _impl_.tail_line_end_;
}

void ShapeStylePropertiesArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapeStylePropertiesArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ShapeStylePropertiesArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.fill_ != nullptr);
      _impl_.fill_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.stroke_ != nullptr);
      _impl_.stroke_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.shadow_ != nullptr);
      _impl_.shadow_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.reflection_ != nullptr);
      _impl_.reflection_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.head_line_end_ != nullptr);
      _impl_.head_line_end_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.tail_line_end_ != nullptr);
      _impl_.tail_line_end_->Clear();
    }
  }
  _impl_.opacity_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapeStylePropertiesArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.FillArchive fill = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_fill(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.StrokeArchive stroke = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_stroke(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float opacity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_opacity(&has_bits);
          _impl_.opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ShadowArchive shadow = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_shadow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ReflectionArchive reflection = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_reflection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.LineEndArchive head_line_end = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_head_line_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.LineEndArchive tail_line_end = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_tail_line_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeStylePropertiesArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ShapeStylePropertiesArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.FillArchive fill = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::fill(this),
        _Internal::fill(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.StrokeArchive stroke = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::stroke(this),
        _Internal::stroke(this).GetCachedSize(), target, stream);
  }

  // optional float opacity = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_opacity(), target);
  }

  // optional .TSD.ShadowArchive shadow = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::shadow(this),
        _Internal::shadow(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ReflectionArchive reflection = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::reflection(this),
        _Internal::reflection(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.LineEndArchive head_line_end = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::head_line_end(this),
        _Internal::head_line_end(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.LineEndArchive tail_line_end = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::tail_line_end(this),
        _Internal::tail_line_end(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ShapeStylePropertiesArchive)
  return target;
}

size_t ShapeStylePropertiesArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ShapeStylePropertiesArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .TSD.FillArchive fill = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fill_);
    }

    // optional .TSD.StrokeArchive stroke = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stroke_);
    }

    // optional .TSD.ShadowArchive shadow = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shadow_);
    }

    // optional .TSD.ReflectionArchive reflection = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.reflection_);
    }

    // optional .TSD.LineEndArchive head_line_end = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.head_line_end_);
    }

    // optional .TSD.LineEndArchive tail_line_end = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tail_line_end_);
    }

    // optional float opacity = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapeStylePropertiesArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapeStylePropertiesArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapeStylePropertiesArchive::GetClassData() const { return &_class_data_; }


void ShapeStylePropertiesArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapeStylePropertiesArchive*>(&to_msg);
  auto& from = static_cast<const ShapeStylePropertiesArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ShapeStylePropertiesArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_fill()->::TSD::FillArchive::MergeFrom(
          from._internal_fill());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_stroke()->::TSD::StrokeArchive::MergeFrom(
          from._internal_stroke());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_shadow()->::TSD::ShadowArchive::MergeFrom(
          from._internal_shadow());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_reflection()->::TSD::ReflectionArchive::MergeFrom(
          from._internal_reflection());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_head_line_end()->::TSD::LineEndArchive::MergeFrom(
          from._internal_head_line_end());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_tail_line_end()->::TSD::LineEndArchive::MergeFrom(
          from._internal_tail_line_end());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.opacity_ = from._impl_.opacity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapeStylePropertiesArchive::CopyFrom(const ShapeStylePropertiesArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ShapeStylePropertiesArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeStylePropertiesArchive::IsInitialized() const {
  if (_internal_has_fill()) {
    if (!_impl_.fill_->IsInitialized()) return false;
  }
  if (_internal_has_stroke()) {
    if (!_impl_.stroke_->IsInitialized()) return false;
  }
  if (_internal_has_shadow()) {
    if (!_impl_.shadow_->IsInitialized()) return false;
  }
  if (_internal_has_head_line_end()) {
    if (!_impl_.head_line_end_->IsInitialized()) return false;
  }
  if (_internal_has_tail_line_end()) {
    if (!_impl_.tail_line_end_->IsInitialized()) return false;
  }
  return true;
}

void ShapeStylePropertiesArchive::InternalSwap(ShapeStylePropertiesArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShapeStylePropertiesArchive, _impl_.opacity_)
      + sizeof(ShapeStylePropertiesArchive::_impl_.opacity_)
      - PROTOBUF_FIELD_OFFSET(ShapeStylePropertiesArchive, _impl_.fill_)>(
          reinterpret_cast<char*>(&_impl_.fill_),
          reinterpret_cast<char*>(&other->_impl_.fill_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapeStylePropertiesArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[29]);
}

// ===================================================================

class ShapeStyleArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapeStyleArchive>()._impl_._has_bits_);
  static const ::TSS::StyleArchive& super(const ShapeStyleArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_override_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::ShapeStylePropertiesArchive& shape_properties(const ShapeStyleArchive* msg);
  static void set_has_shape_properties(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSS::StyleArchive&
ShapeStyleArchive::_Internal::super(const ShapeStyleArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSD::ShapeStylePropertiesArchive&
ShapeStyleArchive::_Internal::shape_properties(const ShapeStyleArchive* msg) {
  return *msg->_impl_.shape_properties_;
}
void ShapeStyleArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ShapeStyleArchive::ShapeStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ShapeStyleArchive)
}
ShapeStyleArchive::ShapeStyleArchive(const ShapeStyleArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapeStyleArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.shape_properties_){nullptr}
    , decltype(_impl_.override_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSS::StyleArchive(*from._impl_.super_);
  }
  if (from._internal_has_shape_properties()) {
    _this->_impl_.shape_properties_ = new ::TSD::ShapeStylePropertiesArchive(*from._impl_.shape_properties_);
  }
  _this->_impl_.override_count_ = from._impl_.override_count_;
  // @@protoc_insertion_point(copy_constructor:TSD.ShapeStyleArchive)
}

inline void ShapeStyleArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.shape_properties_){nullptr}
    , decltype(_impl_.override_count_){0u}
  };
}

ShapeStyleArchive::~ShapeStyleArchive() {
  // @@protoc_insertion_point(destructor:TSD.ShapeStyleArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeStyleArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.shape_properties_;
}

void ShapeStyleArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapeStyleArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ShapeStyleArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.shape_properties_ != nullptr);
      _impl_.shape_properties_->Clear();
    }
  }
  _impl_.override_count_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapeStyleArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSS.StyleArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 override_count = 10 [default = 0];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_override_count(&has_bits);
          _impl_.override_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ShapeStylePropertiesArchive shape_properties = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_shape_properties(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeStyleArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ShapeStyleArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSS.StyleArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 override_count = 10 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_override_count(), target);
  }

  // optional .TSD.ShapeStylePropertiesArchive shape_properties = 11;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::shape_properties(this),
        _Internal::shape_properties(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ShapeStyleArchive)
  return target;
}

size_t ShapeStyleArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ShapeStyleArchive)
  size_t total_size = 0;

  // required .TSS.StyleArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSD.ShapeStylePropertiesArchive shape_properties = 11;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shape_properties_);
    }

    // optional uint32 override_count = 10 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_override_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapeStyleArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapeStyleArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapeStyleArchive::GetClassData() const { return &_class_data_; }


void ShapeStyleArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapeStyleArchive*>(&to_msg);
  auto& from = static_cast<const ShapeStyleArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ShapeStyleArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSS::StyleArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_shape_properties()->::TSD::ShapeStylePropertiesArchive::MergeFrom(
          from._internal_shape_properties());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.override_count_ = from._impl_.override_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapeStyleArchive::CopyFrom(const ShapeStyleArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ShapeStyleArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeStyleArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_shape_properties()) {
    if (!_impl_.shape_properties_->IsInitialized()) return false;
  }
  return true;
}

void ShapeStyleArchive::InternalSwap(ShapeStyleArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShapeStyleArchive, _impl_.override_count_)
      + sizeof(ShapeStyleArchive::_impl_.override_count_)
      - PROTOBUF_FIELD_OFFSET(ShapeStyleArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapeStyleArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[30]);
}

// ===================================================================

class MediaStylePropertiesArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MediaStylePropertiesArchive>()._impl_._has_bits_);
  static const ::TSD::StrokeArchive& stroke(const MediaStylePropertiesArchive* msg);
  static void set_has_stroke(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSD::ShadowArchive& shadow(const MediaStylePropertiesArchive* msg);
  static void set_has_shadow(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::ReflectionArchive& reflection(const MediaStylePropertiesArchive* msg);
  static void set_has_reflection(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSD::StrokeArchive&
MediaStylePropertiesArchive::_Internal::stroke(const MediaStylePropertiesArchive* msg) {
  return *msg->_impl_.stroke_;
}
const ::TSD::ShadowArchive&
MediaStylePropertiesArchive::_Internal::shadow(const MediaStylePropertiesArchive* msg) {
  return *msg->_impl_.shadow_;
}
const ::TSD::ReflectionArchive&
MediaStylePropertiesArchive::_Internal::reflection(const MediaStylePropertiesArchive* msg) {
  return *msg->_impl_.reflection_;
}
MediaStylePropertiesArchive::MediaStylePropertiesArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.MediaStylePropertiesArchive)
}
MediaStylePropertiesArchive::MediaStylePropertiesArchive(const MediaStylePropertiesArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MediaStylePropertiesArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stroke_){nullptr}
    , decltype(_impl_.shadow_){nullptr}
    , decltype(_impl_.reflection_){nullptr}
    , decltype(_impl_.opacity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stroke()) {
    _this->_impl_.stroke_ = new ::TSD::StrokeArchive(*from._impl_.stroke_);
  }
  if (from._internal_has_shadow()) {
    _this->_impl_.shadow_ = new ::TSD::ShadowArchive(*from._impl_.shadow_);
  }
  if (from._internal_has_reflection()) {
    _this->_impl_.reflection_ = new ::TSD::ReflectionArchive(*from._impl_.reflection_);
  }
  _this->_impl_.opacity_ = from._impl_.opacity_;
  // @@protoc_insertion_point(copy_constructor:TSD.MediaStylePropertiesArchive)
}

inline void MediaStylePropertiesArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stroke_){nullptr}
    , decltype(_impl_.shadow_){nullptr}
    , decltype(_impl_.reflection_){nullptr}
    , decltype(_impl_.opacity_){0}
  };
}

MediaStylePropertiesArchive::~MediaStylePropertiesArchive() {
  // @@protoc_insertion_point(destructor:TSD.MediaStylePropertiesArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MediaStylePropertiesArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stroke_;
  if (this != internal_default_instance()) delete _impl_.shadow_;
  if (this != internal_default_instance()) delete _impl_.reflection_;
}

void MediaStylePropertiesArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MediaStylePropertiesArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.MediaStylePropertiesArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.stroke_ != nullptr);
      _impl_.stroke_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.shadow_ != nullptr);
      _impl_.shadow_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.reflection_ != nullptr);
      _impl_.reflection_->Clear();
    }
  }
  _impl_.opacity_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MediaStylePropertiesArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.StrokeArchive stroke = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stroke(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float opacity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_opacity(&has_bits);
          _impl_.opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ShadowArchive shadow = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_shadow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ReflectionArchive reflection = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_reflection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MediaStylePropertiesArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.MediaStylePropertiesArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.StrokeArchive stroke = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stroke(this),
        _Internal::stroke(this).GetCachedSize(), target, stream);
  }

  // optional float opacity = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_opacity(), target);
  }

  // optional .TSD.ShadowArchive shadow = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::shadow(this),
        _Internal::shadow(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ReflectionArchive reflection = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::reflection(this),
        _Internal::reflection(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.MediaStylePropertiesArchive)
  return target;
}

size_t MediaStylePropertiesArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.MediaStylePropertiesArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .TSD.StrokeArchive stroke = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stroke_);
    }

    // optional .TSD.ShadowArchive shadow = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shadow_);
    }

    // optional .TSD.ReflectionArchive reflection = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.reflection_);
    }

    // optional float opacity = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MediaStylePropertiesArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MediaStylePropertiesArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MediaStylePropertiesArchive::GetClassData() const { return &_class_data_; }


void MediaStylePropertiesArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MediaStylePropertiesArchive*>(&to_msg);
  auto& from = static_cast<const MediaStylePropertiesArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.MediaStylePropertiesArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_stroke()->::TSD::StrokeArchive::MergeFrom(
          from._internal_stroke());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_shadow()->::TSD::ShadowArchive::MergeFrom(
          from._internal_shadow());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_reflection()->::TSD::ReflectionArchive::MergeFrom(
          from._internal_reflection());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.opacity_ = from._impl_.opacity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MediaStylePropertiesArchive::CopyFrom(const MediaStylePropertiesArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.MediaStylePropertiesArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MediaStylePropertiesArchive::IsInitialized() const {
  if (_internal_has_stroke()) {
    if (!_impl_.stroke_->IsInitialized()) return false;
  }
  if (_internal_has_shadow()) {
    if (!_impl_.shadow_->IsInitialized()) return false;
  }
  return true;
}

void MediaStylePropertiesArchive::InternalSwap(MediaStylePropertiesArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MediaStylePropertiesArchive, _impl_.opacity_)
      + sizeof(MediaStylePropertiesArchive::_impl_.opacity_)
      - PROTOBUF_FIELD_OFFSET(MediaStylePropertiesArchive, _impl_.stroke_)>(
          reinterpret_cast<char*>(&_impl_.stroke_),
          reinterpret_cast<char*>(&other->_impl_.stroke_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MediaStylePropertiesArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[31]);
}

// ===================================================================

class MediaStyleArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MediaStyleArchive>()._impl_._has_bits_);
  static const ::TSS::StyleArchive& super(const MediaStyleArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_override_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::MediaStylePropertiesArchive& media_properties(const MediaStyleArchive* msg);
  static void set_has_media_properties(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSS::StyleArchive&
MediaStyleArchive::_Internal::super(const MediaStyleArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSD::MediaStylePropertiesArchive&
MediaStyleArchive::_Internal::media_properties(const MediaStyleArchive* msg) {
  return *msg->_impl_.media_properties_;
}
void MediaStyleArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
MediaStyleArchive::MediaStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.MediaStyleArchive)
}
MediaStyleArchive::MediaStyleArchive(const MediaStyleArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MediaStyleArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.media_properties_){nullptr}
    , decltype(_impl_.override_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSS::StyleArchive(*from._impl_.super_);
  }
  if (from._internal_has_media_properties()) {
    _this->_impl_.media_properties_ = new ::TSD::MediaStylePropertiesArchive(*from._impl_.media_properties_);
  }
  _this->_impl_.override_count_ = from._impl_.override_count_;
  // @@protoc_insertion_point(copy_constructor:TSD.MediaStyleArchive)
}

inline void MediaStyleArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.media_properties_){nullptr}
    , decltype(_impl_.override_count_){0u}
  };
}

MediaStyleArchive::~MediaStyleArchive() {
  // @@protoc_insertion_point(destructor:TSD.MediaStyleArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MediaStyleArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.media_properties_;
}

void MediaStyleArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MediaStyleArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.MediaStyleArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.media_properties_ != nullptr);
      _impl_.media_properties_->Clear();
    }
  }
  _impl_.override_count_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MediaStyleArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSS.StyleArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 override_count = 10 [default = 0];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_override_count(&has_bits);
          _impl_.override_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.MediaStylePropertiesArchive media_properties = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_media_properties(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MediaStyleArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.MediaStyleArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSS.StyleArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 override_count = 10 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_override_count(), target);
  }

  // optional .TSD.MediaStylePropertiesArchive media_properties = 11;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::media_properties(this),
        _Internal::media_properties(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.MediaStyleArchive)
  return target;
}

size_t MediaStyleArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.MediaStyleArchive)
  size_t total_size = 0;

  // required .TSS.StyleArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSD.MediaStylePropertiesArchive media_properties = 11;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.media_properties_);
    }

    // optional uint32 override_count = 10 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_override_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MediaStyleArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MediaStyleArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MediaStyleArchive::GetClassData() const { return &_class_data_; }


void MediaStyleArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MediaStyleArchive*>(&to_msg);
  auto& from = static_cast<const MediaStyleArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.MediaStyleArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSS::StyleArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_media_properties()->::TSD::MediaStylePropertiesArchive::MergeFrom(
          from._internal_media_properties());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.override_count_ = from._impl_.override_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MediaStyleArchive::CopyFrom(const MediaStyleArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.MediaStyleArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MediaStyleArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_media_properties()) {
    if (!_impl_.media_properties_->IsInitialized()) return false;
  }
  return true;
}

void MediaStyleArchive::InternalSwap(MediaStyleArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MediaStyleArchive, _impl_.override_count_)
      + sizeof(MediaStyleArchive::_impl_.override_count_)
      - PROTOBUF_FIELD_OFFSET(MediaStyleArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MediaStyleArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[32]);
}

// ===================================================================

class ThemePresetsArchive::_Internal {
 public:
};

void ThemePresetsArchive::clear_line_style_presets() {
  _impl_.line_style_presets_.Clear();
}
void ThemePresetsArchive::clear_shape_style_presets() {
  _impl_.shape_style_presets_.Clear();
}
void ThemePresetsArchive::clear_textbox_style_presets() {
  _impl_.textbox_style_presets_.Clear();
}
void ThemePresetsArchive::clear_image_style_presets() {
  _impl_.image_style_presets_.Clear();
}
void ThemePresetsArchive::clear_movie_style_presets() {
  _impl_.movie_style_presets_.Clear();
}
void ThemePresetsArchive::clear_drawing_line_style_presets() {
  _impl_.drawing_line_style_presets_.Clear();
}
ThemePresetsArchive::ThemePresetsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ThemePresetsArchive)
}
ThemePresetsArchive::ThemePresetsArchive(const ThemePresetsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ThemePresetsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.gradient_fill_presets_){from._impl_.gradient_fill_presets_}
    , decltype(_impl_.image_fill_presets_){from._impl_.image_fill_presets_}
    , decltype(_impl_.shadow_presets_){from._impl_.shadow_presets_}
    , decltype(_impl_.line_style_presets_){from._impl_.line_style_presets_}
    , decltype(_impl_.shape_style_presets_){from._impl_.shape_style_presets_}
    , decltype(_impl_.textbox_style_presets_){from._impl_.textbox_style_presets_}
    , decltype(_impl_.image_style_presets_){from._impl_.image_style_presets_}
    , decltype(_impl_.movie_style_presets_){from._impl_.movie_style_presets_}
    , decltype(_impl_.drawing_line_style_presets_){from._impl_.drawing_line_style_presets_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSD.ThemePresetsArchive)
}

inline void ThemePresetsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.gradient_fill_presets_){arena}
    , decltype(_impl_.image_fill_presets_){arena}
    , decltype(_impl_.shadow_presets_){arena}
    , decltype(_impl_.line_style_presets_){arena}
    , decltype(_impl_.shape_style_presets_){arena}
    , decltype(_impl_.textbox_style_presets_){arena}
    , decltype(_impl_.image_style_presets_){arena}
    , decltype(_impl_.movie_style_presets_){arena}
    , decltype(_impl_.drawing_line_style_presets_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ThemePresetsArchive::~ThemePresetsArchive() {
  // @@protoc_insertion_point(destructor:TSD.ThemePresetsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThemePresetsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gradient_fill_presets_.~RepeatedPtrField();
  _impl_.image_fill_presets_.~RepeatedPtrField();
  _impl_.shadow_presets_.~RepeatedPtrField();
  _impl_.line_style_presets_.~RepeatedPtrField();
  _impl_.shape_style_presets_.~RepeatedPtrField();
  _impl_.textbox_style_presets_.~RepeatedPtrField();
  _impl_.image_style_presets_.~RepeatedPtrField();
  _impl_.movie_style_presets_.~RepeatedPtrField();
  _impl_.drawing_line_style_presets_.~RepeatedPtrField();
}

void ThemePresetsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThemePresetsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ThemePresetsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.gradient_fill_presets_.Clear();
  _impl_.image_fill_presets_.Clear();
  _impl_.shadow_presets_.Clear();
  _impl_.line_style_presets_.Clear();
  _impl_.shape_style_presets_.Clear();
  _impl_.textbox_style_presets_.Clear();
  _impl_.image_style_presets_.Clear();
  _impl_.movie_style_presets_.Clear();
  _impl_.drawing_line_style_presets_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ThemePresetsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSD.FillArchive gradient_fill_presets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_gradient_fill_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSD.FillArchive image_fill_presets = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_image_fill_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSD.ShadowArchive shadow_presets = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shadow_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference line_style_presets = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_line_style_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference shape_style_presets = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shape_style_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference textbox_style_presets = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_textbox_style_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference image_style_presets = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_image_style_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference movie_style_presets = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_movie_style_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference drawing_line_style_presets = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_drawing_line_style_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThemePresetsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ThemePresetsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSD.FillArchive gradient_fill_presets = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_gradient_fill_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_gradient_fill_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSD.FillArchive image_fill_presets = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_image_fill_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_image_fill_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSD.ShadowArchive shadow_presets = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shadow_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_shadow_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference line_style_presets = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_line_style_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_line_style_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference shape_style_presets = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shape_style_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_shape_style_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference textbox_style_presets = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_textbox_style_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_textbox_style_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference image_style_presets = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_image_style_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_image_style_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference movie_style_presets = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_movie_style_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_movie_style_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference drawing_line_style_presets = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_drawing_line_style_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_drawing_line_style_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ThemePresetsArchive)
  return target;
}

size_t ThemePresetsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ThemePresetsArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSD.FillArchive gradient_fill_presets = 1;
  total_size += 1UL * this->_internal_gradient_fill_presets_size();
  for (const auto& msg : this->_impl_.gradient_fill_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSD.FillArchive image_fill_presets = 2;
  total_size += 1UL * this->_internal_image_fill_presets_size();
  for (const auto& msg : this->_impl_.image_fill_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSD.ShadowArchive shadow_presets = 3;
  total_size += 1UL * this->_internal_shadow_presets_size();
  for (const auto& msg : this->_impl_.shadow_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference line_style_presets = 4;
  total_size += 1UL * this->_internal_line_style_presets_size();
  for (const auto& msg : this->_impl_.line_style_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference shape_style_presets = 5;
  total_size += 1UL * this->_internal_shape_style_presets_size();
  for (const auto& msg : this->_impl_.shape_style_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference textbox_style_presets = 6;
  total_size += 1UL * this->_internal_textbox_style_presets_size();
  for (const auto& msg : this->_impl_.textbox_style_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference image_style_presets = 7;
  total_size += 1UL * this->_internal_image_style_presets_size();
  for (const auto& msg : this->_impl_.image_style_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference movie_style_presets = 8;
  total_size += 1UL * this->_internal_movie_style_presets_size();
  for (const auto& msg : this->_impl_.movie_style_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference drawing_line_style_presets = 9;
  total_size += 1UL * this->_internal_drawing_line_style_presets_size();
  for (const auto& msg : this->_impl_.drawing_line_style_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ThemePresetsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ThemePresetsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ThemePresetsArchive::GetClassData() const { return &_class_data_; }


void ThemePresetsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ThemePresetsArchive*>(&to_msg);
  auto& from = static_cast<const ThemePresetsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ThemePresetsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.gradient_fill_presets_.MergeFrom(from._impl_.gradient_fill_presets_);
  _this->_impl_.image_fill_presets_.MergeFrom(from._impl_.image_fill_presets_);
  _this->_impl_.shadow_presets_.MergeFrom(from._impl_.shadow_presets_);
  _this->_impl_.line_style_presets_.MergeFrom(from._impl_.line_style_presets_);
  _this->_impl_.shape_style_presets_.MergeFrom(from._impl_.shape_style_presets_);
  _this->_impl_.textbox_style_presets_.MergeFrom(from._impl_.textbox_style_presets_);
  _this->_impl_.image_style_presets_.MergeFrom(from._impl_.image_style_presets_);
  _this->_impl_.movie_style_presets_.MergeFrom(from._impl_.movie_style_presets_);
  _this->_impl_.drawing_line_style_presets_.MergeFrom(from._impl_.drawing_line_style_presets_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ThemePresetsArchive::CopyFrom(const ThemePresetsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ThemePresetsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThemePresetsArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.gradient_fill_presets_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.image_fill_presets_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.shadow_presets_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.line_style_presets_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.shape_style_presets_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.textbox_style_presets_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.image_style_presets_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.movie_style_presets_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.drawing_line_style_presets_))
    return false;
  return true;
}

void ThemePresetsArchive::InternalSwap(ThemePresetsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.gradient_fill_presets_.InternalSwap(&other->_impl_.gradient_fill_presets_);
  _impl_.image_fill_presets_.InternalSwap(&other->_impl_.image_fill_presets_);
  _impl_.shadow_presets_.InternalSwap(&other->_impl_.shadow_presets_);
  _impl_.line_style_presets_.InternalSwap(&other->_impl_.line_style_presets_);
  _impl_.shape_style_presets_.InternalSwap(&other->_impl_.shape_style_presets_);
  _impl_.textbox_style_presets_.InternalSwap(&other->_impl_.textbox_style_presets_);
  _impl_.image_style_presets_.InternalSwap(&other->_impl_.image_style_presets_);
  _impl_.movie_style_presets_.InternalSwap(&other->_impl_.movie_style_presets_);
  _impl_.drawing_line_style_presets_.InternalSwap(&other->_impl_.drawing_line_style_presets_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ThemePresetsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[33]);
}

// ===================================================================

class ThemeReplaceFillPresetCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ThemeReplaceFillPresetCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ThemeReplaceFillPresetCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& theme(const ThemeReplaceFillPresetCommandArchive* msg);
  static void set_has_theme(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::FillArchive& fill(const ThemeReplaceFillPresetCommandArchive* msg);
  static void set_has_fill(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::FillArchive& old_fill(const ThemeReplaceFillPresetCommandArchive* msg);
  static void set_has_old_fill(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::TSK::CommandArchive&
ThemeReplaceFillPresetCommandArchive::_Internal::super(const ThemeReplaceFillPresetCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ThemeReplaceFillPresetCommandArchive::_Internal::theme(const ThemeReplaceFillPresetCommandArchive* msg) {
  return *msg->_impl_.theme_;
}
const ::TSD::FillArchive&
ThemeReplaceFillPresetCommandArchive::_Internal::fill(const ThemeReplaceFillPresetCommandArchive* msg) {
  return *msg->_impl_.fill_;
}
const ::TSD::FillArchive&
ThemeReplaceFillPresetCommandArchive::_Internal::old_fill(const ThemeReplaceFillPresetCommandArchive* msg) {
  return *msg->_impl_.old_fill_;
}
void ThemeReplaceFillPresetCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ThemeReplaceFillPresetCommandArchive::clear_theme() {
  if (_impl_.theme_ != nullptr) _impl_.theme_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ThemeReplaceFillPresetCommandArchive::ThemeReplaceFillPresetCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ThemeReplaceFillPresetCommandArchive)
}
ThemeReplaceFillPresetCommandArchive::ThemeReplaceFillPresetCommandArchive(const ThemeReplaceFillPresetCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ThemeReplaceFillPresetCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.theme_){nullptr}
    , decltype(_impl_.fill_){nullptr}
    , decltype(_impl_.old_fill_){nullptr}
    , decltype(_impl_.index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_theme()) {
    _this->_impl_.theme_ = new ::TSP::Reference(*from._impl_.theme_);
  }
  if (from._internal_has_fill()) {
    _this->_impl_.fill_ = new ::TSD::FillArchive(*from._impl_.fill_);
  }
  if (from._internal_has_old_fill()) {
    _this->_impl_.old_fill_ = new ::TSD::FillArchive(*from._impl_.old_fill_);
  }
  _this->_impl_.index_ = from._impl_.index_;
  // @@protoc_insertion_point(copy_constructor:TSD.ThemeReplaceFillPresetCommandArchive)
}

inline void ThemeReplaceFillPresetCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.theme_){nullptr}
    , decltype(_impl_.fill_){nullptr}
    , decltype(_impl_.old_fill_){nullptr}
    , decltype(_impl_.index_){0u}
  };
}

ThemeReplaceFillPresetCommandArchive::~ThemeReplaceFillPresetCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.ThemeReplaceFillPresetCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThemeReplaceFillPresetCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.theme_;
  if (this != internal_default_instance()) delete _impl_.fill_;
  if (this != internal_default_instance()) delete _impl_.old_fill_;
}

void ThemeReplaceFillPresetCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThemeReplaceFillPresetCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ThemeReplaceFillPresetCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.theme_ != nullptr);
      _impl_.theme_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.fill_ != nullptr);
      _impl_.fill_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.old_fill_ != nullptr);
      _impl_.old_fill_->Clear();
    }
  }
  _impl_.index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ThemeReplaceFillPresetCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference theme = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_theme(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSD.FillArchive fill = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_fill(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSD.FillArchive old_fill = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_fill(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThemeReplaceFillPresetCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ThemeReplaceFillPresetCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference theme = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::theme(this),
        _Internal::theme(this).GetCachedSize(), target, stream);
  }

  // required .TSD.FillArchive fill = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::fill(this),
        _Internal::fill(this).GetCachedSize(), target, stream);
  }

  // required .TSD.FillArchive old_fill = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::old_fill(this),
        _Internal::old_fill(this).GetCachedSize(), target, stream);
  }

  // required uint32 index = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ThemeReplaceFillPresetCommandArchive)
  return target;
}

size_t ThemeReplaceFillPresetCommandArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSD.ThemeReplaceFillPresetCommandArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_theme()) {
    // required .TSP.Reference theme = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.theme_);
  }

  if (_internal_has_fill()) {
    // required .TSD.FillArchive fill = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fill_);
  }

  if (_internal_has_old_fill()) {
    // required .TSD.FillArchive old_fill = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.old_fill_);
  }

  if (_internal_has_index()) {
    // required uint32 index = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
  }

  return total_size;
}
size_t ThemeReplaceFillPresetCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ThemeReplaceFillPresetCommandArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSP.Reference theme = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.theme_);

    // required .TSD.FillArchive fill = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fill_);

    // required .TSD.FillArchive old_fill = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.old_fill_);

    // required uint32 index = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ThemeReplaceFillPresetCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ThemeReplaceFillPresetCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ThemeReplaceFillPresetCommandArchive::GetClassData() const { return &_class_data_; }


void ThemeReplaceFillPresetCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ThemeReplaceFillPresetCommandArchive*>(&to_msg);
  auto& from = static_cast<const ThemeReplaceFillPresetCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ThemeReplaceFillPresetCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_theme()->::TSP::Reference::MergeFrom(
          from._internal_theme());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_fill()->::TSD::FillArchive::MergeFrom(
          from._internal_fill());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_old_fill()->::TSD::FillArchive::MergeFrom(
          from._internal_old_fill());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ThemeReplaceFillPresetCommandArchive::CopyFrom(const ThemeReplaceFillPresetCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ThemeReplaceFillPresetCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThemeReplaceFillPresetCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_theme()) {
    if (!_impl_.theme_->IsInitialized()) return false;
  }
  if (_internal_has_fill()) {
    if (!_impl_.fill_->IsInitialized()) return false;
  }
  if (_internal_has_old_fill()) {
    if (!_impl_.old_fill_->IsInitialized()) return false;
  }
  return true;
}

void ThemeReplaceFillPresetCommandArchive::InternalSwap(ThemeReplaceFillPresetCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ThemeReplaceFillPresetCommandArchive, _impl_.index_)
      + sizeof(ThemeReplaceFillPresetCommandArchive::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(ThemeReplaceFillPresetCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ThemeReplaceFillPresetCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[34]);
}

// ===================================================================

class DrawableArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DrawableArchive>()._impl_._has_bits_);
  static const ::TSD::GeometryArchive& geometry(const DrawableArchive* msg);
  static void set_has_geometry(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& parent(const DrawableArchive* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSD::ExteriorTextWrapArchive& exterior_text_wrap(const DrawableArchive* msg);
  static void set_has_exterior_text_wrap(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_hyperlink_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_locked(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::TSP::Reference& comment(const DrawableArchive* msg);
  static void set_has_comment(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_aspect_ratio_locked(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_accessibility_description(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& title(const DrawableArchive* msg);
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSP::Reference& caption(const DrawableArchive* msg);
  static void set_has_caption(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_title_hidden(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_caption_hidden(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

const ::TSD::GeometryArchive&
DrawableArchive::_Internal::geometry(const DrawableArchive* msg) {
  return *msg->_impl_.geometry_;
}
const ::TSP::Reference&
DrawableArchive::_Internal::parent(const DrawableArchive* msg) {
  return *msg->_impl_.parent_;
}
const ::TSD::ExteriorTextWrapArchive&
DrawableArchive::_Internal::exterior_text_wrap(const DrawableArchive* msg) {
  return *msg->_impl_.exterior_text_wrap_;
}
const ::TSP::Reference&
DrawableArchive::_Internal::comment(const DrawableArchive* msg) {
  return *msg->_impl_.comment_;
}
const ::TSP::Reference&
DrawableArchive::_Internal::title(const DrawableArchive* msg) {
  return *msg->_impl_.title_;
}
const ::TSP::Reference&
DrawableArchive::_Internal::caption(const DrawableArchive* msg) {
  return *msg->_impl_.caption_;
}
void DrawableArchive::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void DrawableArchive::clear_comment() {
  if (_impl_.comment_ != nullptr) _impl_.comment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void DrawableArchive::clear_pencil_annotations() {
  _impl_.pencil_annotations_.Clear();
}
void DrawableArchive::clear_title() {
  if (_impl_.title_ != nullptr) _impl_.title_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void DrawableArchive::clear_caption() {
  if (_impl_.caption_ != nullptr) _impl_.caption_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
DrawableArchive::DrawableArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.DrawableArchive)
}
DrawableArchive::DrawableArchive(const DrawableArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DrawableArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pencil_annotations_){from._impl_.pencil_annotations_}
    , decltype(_impl_.hyperlink_url_){}
    , decltype(_impl_.accessibility_description_){}
    , decltype(_impl_.geometry_){nullptr}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.exterior_text_wrap_){nullptr}
    , decltype(_impl_.comment_){nullptr}
    , decltype(_impl_.title_){nullptr}
    , decltype(_impl_.caption_){nullptr}
    , decltype(_impl_.locked_){}
    , decltype(_impl_.aspect_ratio_locked_){}
    , decltype(_impl_.title_hidden_){}
    , decltype(_impl_.caption_hidden_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hyperlink_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hyperlink_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hyperlink_url()) {
    _this->_impl_.hyperlink_url_.Set(from._internal_hyperlink_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.accessibility_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.accessibility_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_accessibility_description()) {
    _this->_impl_.accessibility_description_.Set(from._internal_accessibility_description(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_geometry()) {
    _this->_impl_.geometry_ = new ::TSD::GeometryArchive(*from._impl_.geometry_);
  }
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::TSP::Reference(*from._impl_.parent_);
  }
  if (from._internal_has_exterior_text_wrap()) {
    _this->_impl_.exterior_text_wrap_ = new ::TSD::ExteriorTextWrapArchive(*from._impl_.exterior_text_wrap_);
  }
  if (from._internal_has_comment()) {
    _this->_impl_.comment_ = new ::TSP::Reference(*from._impl_.comment_);
  }
  if (from._internal_has_title()) {
    _this->_impl_.title_ = new ::TSP::Reference(*from._impl_.title_);
  }
  if (from._internal_has_caption()) {
    _this->_impl_.caption_ = new ::TSP::Reference(*from._impl_.caption_);
  }
  ::memcpy(&_impl_.locked_, &from._impl_.locked_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.caption_hidden_) -
    reinterpret_cast<char*>(&_impl_.locked_)) + sizeof(_impl_.caption_hidden_));
  // @@protoc_insertion_point(copy_constructor:TSD.DrawableArchive)
}

inline void DrawableArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pencil_annotations_){arena}
    , decltype(_impl_.hyperlink_url_){}
    , decltype(_impl_.accessibility_description_){}
    , decltype(_impl_.geometry_){nullptr}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.exterior_text_wrap_){nullptr}
    , decltype(_impl_.comment_){nullptr}
    , decltype(_impl_.title_){nullptr}
    , decltype(_impl_.caption_){nullptr}
    , decltype(_impl_.locked_){false}
    , decltype(_impl_.aspect_ratio_locked_){false}
    , decltype(_impl_.title_hidden_){false}
    , decltype(_impl_.caption_hidden_){false}
  };
  _impl_.hyperlink_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hyperlink_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.accessibility_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.accessibility_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DrawableArchive::~DrawableArchive() {
  // @@protoc_insertion_point(destructor:TSD.DrawableArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DrawableArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pencil_annotations_.~RepeatedPtrField();
  _impl_.hyperlink_url_.Destroy();
  _impl_.accessibility_description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.geometry_;
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (this != internal_default_instance()) delete _impl_.exterior_text_wrap_;
  if (this != internal_default_instance()) delete _impl_.comment_;
  if (this != internal_default_instance()) delete _impl_.title_;
  if (this != internal_default_instance()) delete _impl_.caption_;
}

void DrawableArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DrawableArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.DrawableArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pencil_annotations_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.hyperlink_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.accessibility_description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.geometry_ != nullptr);
      _impl_.geometry_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.parent_ != nullptr);
      _impl_.parent_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.exterior_text_wrap_ != nullptr);
      _impl_.exterior_text_wrap_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.comment_ != nullptr);
      _impl_.comment_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.title_ != nullptr);
      _impl_.title_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.caption_ != nullptr);
      _impl_.caption_->Clear();
    }
  }
  ::memset(&_impl_.locked_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.caption_hidden_) -
      reinterpret_cast<char*>(&_impl_.locked_)) + sizeof(_impl_.caption_hidden_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DrawableArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.GeometryArchive geometry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_geometry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference parent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_exterior_text_wrap(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string hyperlink_url = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_hyperlink_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.DrawableArchive.hyperlink_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool locked = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_locked(&has_bits);
          _impl_.locked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference comment = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_comment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool aspect_ratio_locked = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_aspect_ratio_locked(&has_bits);
          _impl_.aspect_ratio_locked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string accessibility_description = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_accessibility_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.DrawableArchive.accessibility_description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference pencil_annotations = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pencil_annotations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference title = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_title(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference caption = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_caption(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool title_hidden = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_title_hidden(&has_bits);
          _impl_.title_hidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool caption_hidden = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_caption_hidden(&has_bits);
          _impl_.caption_hidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DrawableArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.DrawableArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.GeometryArchive geometry = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::geometry(this),
        _Internal::geometry(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference parent = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::exterior_text_wrap(this),
        _Internal::exterior_text_wrap(this).GetCachedSize(), target, stream);
  }

  // optional string hyperlink_url = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hyperlink_url().data(), static_cast<int>(this->_internal_hyperlink_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.DrawableArchive.hyperlink_url");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_hyperlink_url(), target);
  }

  // optional bool locked = 5;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_locked(), target);
  }

  // optional .TSP.Reference comment = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::comment(this),
        _Internal::comment(this).GetCachedSize(), target, stream);
  }

  // optional bool aspect_ratio_locked = 7;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_aspect_ratio_locked(), target);
  }

  // optional string accessibility_description = 8;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_accessibility_description().data(), static_cast<int>(this->_internal_accessibility_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.DrawableArchive.accessibility_description");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_accessibility_description(), target);
  }

  // repeated .TSP.Reference pencil_annotations = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pencil_annotations_size()); i < n; i++) {
    const auto& repfield = this->_internal_pencil_annotations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference title = 10;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::title(this),
        _Internal::title(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference caption = 11;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::caption(this),
        _Internal::caption(this).GetCachedSize(), target, stream);
  }

  // optional bool title_hidden = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_title_hidden(), target);
  }

  // optional bool caption_hidden = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_caption_hidden(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.DrawableArchive)
  return target;
}

size_t DrawableArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.DrawableArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference pencil_annotations = 9;
  total_size += 1UL * this->_internal_pencil_annotations_size();
  for (const auto& msg : this->_impl_.pencil_annotations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string hyperlink_url = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hyperlink_url());
    }

    // optional string accessibility_description = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_accessibility_description());
    }

    // optional .TSD.GeometryArchive geometry = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.geometry_);
    }

    // optional .TSP.Reference parent = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.parent_);
    }

    // optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.exterior_text_wrap_);
    }

    // optional .TSP.Reference comment = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.comment_);
    }

    // optional .TSP.Reference title = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.title_);
    }

    // optional .TSP.Reference caption = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.caption_);
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional bool locked = 5;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool aspect_ratio_locked = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool title_hidden = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool caption_hidden = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DrawableArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DrawableArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DrawableArchive::GetClassData() const { return &_class_data_; }


void DrawableArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DrawableArchive*>(&to_msg);
  auto& from = static_cast<const DrawableArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.DrawableArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.pencil_annotations_.MergeFrom(from._impl_.pencil_annotations_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_hyperlink_url(from._internal_hyperlink_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_accessibility_description(from._internal_accessibility_description());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_geometry()->::TSD::GeometryArchive::MergeFrom(
          from._internal_geometry());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_parent()->::TSP::Reference::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_exterior_text_wrap()->::TSD::ExteriorTextWrapArchive::MergeFrom(
          from._internal_exterior_text_wrap());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_comment()->::TSP::Reference::MergeFrom(
          from._internal_comment());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_title()->::TSP::Reference::MergeFrom(
          from._internal_title());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_caption()->::TSP::Reference::MergeFrom(
          from._internal_caption());
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.locked_ = from._impl_.locked_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.aspect_ratio_locked_ = from._impl_.aspect_ratio_locked_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.title_hidden_ = from._impl_.title_hidden_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.caption_hidden_ = from._impl_.caption_hidden_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DrawableArchive::CopyFrom(const DrawableArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.DrawableArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawableArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.pencil_annotations_))
    return false;
  if (_internal_has_geometry()) {
    if (!_impl_.geometry_->IsInitialized()) return false;
  }
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  if (_internal_has_comment()) {
    if (!_impl_.comment_->IsInitialized()) return false;
  }
  if (_internal_has_title()) {
    if (!_impl_.title_->IsInitialized()) return false;
  }
  if (_internal_has_caption()) {
    if (!_impl_.caption_->IsInitialized()) return false;
  }
  return true;
}

void DrawableArchive::InternalSwap(DrawableArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.pencil_annotations_.InternalSwap(&other->_impl_.pencil_annotations_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hyperlink_url_, lhs_arena,
      &other->_impl_.hyperlink_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.accessibility_description_, lhs_arena,
      &other->_impl_.accessibility_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DrawableArchive, _impl_.caption_hidden_)
      + sizeof(DrawableArchive::_impl_.caption_hidden_)
      - PROTOBUF_FIELD_OFFSET(DrawableArchive, _impl_.geometry_)>(
          reinterpret_cast<char*>(&_impl_.geometry_),
          reinterpret_cast<char*>(&other->_impl_.geometry_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DrawableArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[35]);
}

// ===================================================================

class ContainerArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ContainerArchive>()._impl_._has_bits_);
  static const ::TSD::GeometryArchive& geometry(const ContainerArchive* msg);
  static void set_has_geometry(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& parent(const ContainerArchive* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSD::GeometryArchive&
ContainerArchive::_Internal::geometry(const ContainerArchive* msg) {
  return *msg->_impl_.geometry_;
}
const ::TSP::Reference&
ContainerArchive::_Internal::parent(const ContainerArchive* msg) {
  return *msg->_impl_.parent_;
}
void ContainerArchive::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ContainerArchive::clear_children() {
  _impl_.children_.Clear();
}
ContainerArchive::ContainerArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ContainerArchive)
}
ContainerArchive::ContainerArchive(const ContainerArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainerArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){from._impl_.children_}
    , decltype(_impl_.geometry_){nullptr}
    , decltype(_impl_.parent_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_geometry()) {
    _this->_impl_.geometry_ = new ::TSD::GeometryArchive(*from._impl_.geometry_);
  }
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::TSP::Reference(*from._impl_.parent_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ContainerArchive)
}

inline void ContainerArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){arena}
    , decltype(_impl_.geometry_){nullptr}
    , decltype(_impl_.parent_){nullptr}
  };
}

ContainerArchive::~ContainerArchive() {
  // @@protoc_insertion_point(destructor:TSD.ContainerArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContainerArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.children_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.geometry_;
  if (this != internal_default_instance()) delete _impl_.parent_;
}

void ContainerArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainerArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ContainerArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.children_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.geometry_ != nullptr);
      _impl_.geometry_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.parent_ != nullptr);
      _impl_.parent_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainerArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.GeometryArchive geometry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_geometry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference parent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference children = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_children(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainerArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ContainerArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.GeometryArchive geometry = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::geometry(this),
        _Internal::geometry(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference parent = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference children = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_children_size()); i < n; i++) {
    const auto& repfield = this->_internal_children(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ContainerArchive)
  return target;
}

size_t ContainerArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ContainerArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference children = 3;
  total_size += 1UL * this->_internal_children_size();
  for (const auto& msg : this->_impl_.children_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSD.GeometryArchive geometry = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.geometry_);
    }

    // optional .TSP.Reference parent = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.parent_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainerArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainerArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainerArchive::GetClassData() const { return &_class_data_; }


void ContainerArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainerArchive*>(&to_msg);
  auto& from = static_cast<const ContainerArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ContainerArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.children_.MergeFrom(from._impl_.children_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_geometry()->::TSD::GeometryArchive::MergeFrom(
          from._internal_geometry());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_parent()->::TSP::Reference::MergeFrom(
          from._internal_parent());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainerArchive::CopyFrom(const ContainerArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ContainerArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.children_))
    return false;
  if (_internal_has_geometry()) {
    if (!_impl_.geometry_->IsInitialized()) return false;
  }
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  return true;
}

void ContainerArchive::InternalSwap(ContainerArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.children_.InternalSwap(&other->_impl_.children_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContainerArchive, _impl_.parent_)
      + sizeof(ContainerArchive::_impl_.parent_)
      - PROTOBUF_FIELD_OFFSET(ContainerArchive, _impl_.geometry_)>(
          reinterpret_cast<char*>(&_impl_.geometry_),
          reinterpret_cast<char*>(&other->_impl_.geometry_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainerArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[36]);
}

// ===================================================================

class GroupArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupArchive>()._impl_._has_bits_);
  static const ::TSD::DrawableArchive& super(const GroupArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& fake_shape_for_empty_group(const GroupArchive* msg);
  static void set_has_fake_shape_for_empty_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::DrawableArchive&
GroupArchive::_Internal::super(const GroupArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
GroupArchive::_Internal::fake_shape_for_empty_group(const GroupArchive* msg) {
  return *msg->_impl_.fake_shape_for_empty_group_;
}
void GroupArchive::clear_children() {
  _impl_.children_.Clear();
}
void GroupArchive::clear_fake_shape_for_empty_group() {
  if (_impl_.fake_shape_for_empty_group_ != nullptr) _impl_.fake_shape_for_empty_group_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
GroupArchive::GroupArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.GroupArchive)
}
GroupArchive::GroupArchive(const GroupArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GroupArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){from._impl_.children_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.fake_shape_for_empty_group_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::DrawableArchive(*from._impl_.super_);
  }
  if (from._internal_has_fake_shape_for_empty_group()) {
    _this->_impl_.fake_shape_for_empty_group_ = new ::TSP::Reference(*from._impl_.fake_shape_for_empty_group_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.GroupArchive)
}

inline void GroupArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.fake_shape_for_empty_group_){nullptr}
  };
}

GroupArchive::~GroupArchive() {
  // @@protoc_insertion_point(destructor:TSD.GroupArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.children_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.fake_shape_for_empty_group_;
}

void GroupArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.GroupArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.children_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.fake_shape_for_empty_group_ != nullptr);
      _impl_.fake_shape_for_empty_group_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GroupArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.DrawableArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference children = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_children(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference fake_shape_for_empty_group = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_fake_shape_for_empty_group(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((800u <= tag)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.GroupArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.DrawableArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference children = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_children_size()); i < n; i++) {
    const auto& repfield = this->_internal_children(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference fake_shape_for_empty_group = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::fake_shape_for_empty_group(this),
        _Internal::fake_shape_for_empty_group(this).GetCachedSize(), target, stream);
  }

  // Extension range [100, 536870912)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 100, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.GroupArchive)
  return target;
}

size_t GroupArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.GroupArchive)
  size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  // required .TSD.DrawableArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference children = 2;
  total_size += 1UL * this->_internal_children_size();
  for (const auto& msg : this->_impl_.children_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TSP.Reference fake_shape_for_empty_group = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fake_shape_for_empty_group_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GroupArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GroupArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GroupArchive::GetClassData() const { return &_class_data_; }


void GroupArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GroupArchive*>(&to_msg);
  auto& from = static_cast<const GroupArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.GroupArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.children_.MergeFrom(from._impl_.children_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::DrawableArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_fake_shape_for_empty_group()->::TSP::Reference::MergeFrom(
          from._internal_fake_shape_for_empty_group());
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GroupArchive::CopyFrom(const GroupArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.GroupArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupArchive::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized()) {
    return false;
  }

  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.children_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_fake_shape_for_empty_group()) {
    if (!_impl_.fake_shape_for_empty_group_->IsInitialized()) return false;
  }
  return true;
}

void GroupArchive::InternalSwap(GroupArchive* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.children_.InternalSwap(&other->_impl_.children_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupArchive, _impl_.fake_shape_for_empty_group_)
      + sizeof(GroupArchive::_impl_.fake_shape_for_empty_group_)
      - PROTOBUF_FIELD_OFFSET(GroupArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GroupArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[37]);
}

// ===================================================================

class FreehandDrawingAnimationArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FreehandDrawingAnimationArchive>()._impl_._has_bits_);
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_should_loop(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FreehandDrawingAnimationArchive::FreehandDrawingAnimationArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.FreehandDrawingAnimationArchive)
}
FreehandDrawingAnimationArchive::FreehandDrawingAnimationArchive(const FreehandDrawingAnimationArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FreehandDrawingAnimationArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.duration_){}
    , decltype(_impl_.should_loop_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.duration_, &from._impl_.duration_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.should_loop_) -
    reinterpret_cast<char*>(&_impl_.duration_)) + sizeof(_impl_.should_loop_));
  // @@protoc_insertion_point(copy_constructor:TSD.FreehandDrawingAnimationArchive)
}

inline void FreehandDrawingAnimationArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.duration_){0}
    , decltype(_impl_.should_loop_){false}
  };
}

FreehandDrawingAnimationArchive::~FreehandDrawingAnimationArchive() {
  // @@protoc_insertion_point(destructor:TSD.FreehandDrawingAnimationArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FreehandDrawingAnimationArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FreehandDrawingAnimationArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FreehandDrawingAnimationArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.FreehandDrawingAnimationArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.duration_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.should_loop_) -
        reinterpret_cast<char*>(&_impl_.duration_)) + sizeof(_impl_.should_loop_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FreehandDrawingAnimationArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double duration = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_duration(&has_bits);
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool should_loop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_should_loop(&has_bits);
          _impl_.should_loop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FreehandDrawingAnimationArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.FreehandDrawingAnimationArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double duration = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_duration(), target);
  }

  // optional bool should_loop = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_should_loop(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.FreehandDrawingAnimationArchive)
  return target;
}

size_t FreehandDrawingAnimationArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.FreehandDrawingAnimationArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double duration = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional bool should_loop = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FreehandDrawingAnimationArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FreehandDrawingAnimationArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FreehandDrawingAnimationArchive::GetClassData() const { return &_class_data_; }


void FreehandDrawingAnimationArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FreehandDrawingAnimationArchive*>(&to_msg);
  auto& from = static_cast<const FreehandDrawingAnimationArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.FreehandDrawingAnimationArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.duration_ = from._impl_.duration_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.should_loop_ = from._impl_.should_loop_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FreehandDrawingAnimationArchive::CopyFrom(const FreehandDrawingAnimationArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.FreehandDrawingAnimationArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FreehandDrawingAnimationArchive::IsInitialized() const {
  return true;
}

void FreehandDrawingAnimationArchive::InternalSwap(FreehandDrawingAnimationArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FreehandDrawingAnimationArchive, _impl_.should_loop_)
      + sizeof(FreehandDrawingAnimationArchive::_impl_.should_loop_)
      - PROTOBUF_FIELD_OFFSET(FreehandDrawingAnimationArchive, _impl_.duration_)>(
          reinterpret_cast<char*>(&_impl_.duration_),
          reinterpret_cast<char*>(&other->_impl_.duration_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FreehandDrawingAnimationArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[38]);
}

// ===================================================================

class FreehandDrawingArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FreehandDrawingArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& spacer_shape(const FreehandDrawingArchive* msg);
  static void set_has_spacer_shape(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::FreehandDrawingAnimationArchive& animation(const FreehandDrawingArchive* msg);
  static void set_has_animation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_last_clamped_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::TSP::Reference&
FreehandDrawingArchive::_Internal::spacer_shape(const FreehandDrawingArchive* msg) {
  return *msg->_impl_.spacer_shape_;
}
const ::TSD::FreehandDrawingAnimationArchive&
FreehandDrawingArchive::_Internal::animation(const FreehandDrawingArchive* msg) {
  return *msg->_impl_.animation_;
}
void FreehandDrawingArchive::clear_spacer_shape() {
  if (_impl_.spacer_shape_ != nullptr) _impl_.spacer_shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
FreehandDrawingArchive::FreehandDrawingArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.FreehandDrawingArchive)
}
FreehandDrawingArchive::FreehandDrawingArchive(const FreehandDrawingArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FreehandDrawingArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.spacer_shape_){nullptr}
    , decltype(_impl_.animation_){nullptr}
    , decltype(_impl_.opacity_){}
    , decltype(_impl_.last_clamped_scale_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_spacer_shape()) {
    _this->_impl_.spacer_shape_ = new ::TSP::Reference(*from._impl_.spacer_shape_);
  }
  if (from._internal_has_animation()) {
    _this->_impl_.animation_ = new ::TSD::FreehandDrawingAnimationArchive(*from._impl_.animation_);
  }
  ::memcpy(&_impl_.opacity_, &from._impl_.opacity_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_clamped_scale_) -
    reinterpret_cast<char*>(&_impl_.opacity_)) + sizeof(_impl_.last_clamped_scale_));
  // @@protoc_insertion_point(copy_constructor:TSD.FreehandDrawingArchive)
}

inline void FreehandDrawingArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.spacer_shape_){nullptr}
    , decltype(_impl_.animation_){nullptr}
    , decltype(_impl_.opacity_){0}
    , decltype(_impl_.last_clamped_scale_){0}
  };
}

FreehandDrawingArchive::~FreehandDrawingArchive() {
  // @@protoc_insertion_point(destructor:TSD.FreehandDrawingArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FreehandDrawingArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.spacer_shape_;
  if (this != internal_default_instance()) delete _impl_.animation_;
}

void FreehandDrawingArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FreehandDrawingArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.FreehandDrawingArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.spacer_shape_ != nullptr);
      _impl_.spacer_shape_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.animation_ != nullptr);
      _impl_.animation_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.opacity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.last_clamped_scale_) -
        reinterpret_cast<char*>(&_impl_.opacity_)) + sizeof(_impl_.last_clamped_scale_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FreehandDrawingArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference spacer_shape = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_spacer_shape(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double opacity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_opacity(&has_bits);
          _impl_.opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.FreehandDrawingAnimationArchive animation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_animation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double last_clamped_scale = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_last_clamped_scale(&has_bits);
          _impl_.last_clamped_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FreehandDrawingArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.FreehandDrawingArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference spacer_shape = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::spacer_shape(this),
        _Internal::spacer_shape(this).GetCachedSize(), target, stream);
  }

  // optional double opacity = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_opacity(), target);
  }

  // optional .TSD.FreehandDrawingAnimationArchive animation = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::animation(this),
        _Internal::animation(this).GetCachedSize(), target, stream);
  }

  // optional double last_clamped_scale = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_last_clamped_scale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.FreehandDrawingArchive)
  return target;
}

size_t FreehandDrawingArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.FreehandDrawingArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .TSP.Reference spacer_shape = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spacer_shape_);
    }

    // optional .TSD.FreehandDrawingAnimationArchive animation = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.animation_);
    }

    // optional double opacity = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double last_clamped_scale = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FreehandDrawingArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FreehandDrawingArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FreehandDrawingArchive::GetClassData() const { return &_class_data_; }


void FreehandDrawingArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FreehandDrawingArchive*>(&to_msg);
  auto& from = static_cast<const FreehandDrawingArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.FreehandDrawingArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_spacer_shape()->::TSP::Reference::MergeFrom(
          from._internal_spacer_shape());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_animation()->::TSD::FreehandDrawingAnimationArchive::MergeFrom(
          from._internal_animation());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.opacity_ = from._impl_.opacity_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.last_clamped_scale_ = from._impl_.last_clamped_scale_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FreehandDrawingArchive::CopyFrom(const FreehandDrawingArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.FreehandDrawingArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FreehandDrawingArchive::IsInitialized() const {
  if (_internal_has_spacer_shape()) {
    if (!_impl_.spacer_shape_->IsInitialized()) return false;
  }
  return true;
}

void FreehandDrawingArchive::InternalSwap(FreehandDrawingArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FreehandDrawingArchive, _impl_.last_clamped_scale_)
      + sizeof(FreehandDrawingArchive::_impl_.last_clamped_scale_)
      - PROTOBUF_FIELD_OFFSET(FreehandDrawingArchive, _impl_.spacer_shape_)>(
          reinterpret_cast<char*>(&_impl_.spacer_shape_),
          reinterpret_cast<char*>(&other->_impl_.spacer_shape_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FreehandDrawingArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[39]);
}

// ===================================================================

class ShapeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapeArchive>()._impl_._has_bits_);
  static const ::TSD::DrawableArchive& super(const ShapeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& style(const ShapeArchive* msg);
  static void set_has_style(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::PathSourceArchive& pathsource(const ShapeArchive* msg);
  static void set_has_pathsource(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::LineEndArchive& head_line_end(const ShapeArchive* msg);
  static void set_has_head_line_end(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSD::LineEndArchive& tail_line_end(const ShapeArchive* msg);
  static void set_has_tail_line_end(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_strokepatternoffsetdistance(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::DrawableArchive&
ShapeArchive::_Internal::super(const ShapeArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ShapeArchive::_Internal::style(const ShapeArchive* msg) {
  return *msg->_impl_.style_;
}
const ::TSD::PathSourceArchive&
ShapeArchive::_Internal::pathsource(const ShapeArchive* msg) {
  return *msg->_impl_.pathsource_;
}
const ::TSD::LineEndArchive&
ShapeArchive::_Internal::head_line_end(const ShapeArchive* msg) {
  return *msg->_impl_.head_line_end_;
}
const ::TSD::LineEndArchive&
ShapeArchive::_Internal::tail_line_end(const ShapeArchive* msg) {
  return *msg->_impl_.tail_line_end_;
}
void ShapeArchive::clear_style() {
  if (_impl_.style_ != nullptr) _impl_.style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ShapeArchive::ShapeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ShapeArchive)
}
ShapeArchive::ShapeArchive(const ShapeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.style_){nullptr}
    , decltype(_impl_.pathsource_){nullptr}
    , decltype(_impl_.head_line_end_){nullptr}
    , decltype(_impl_.tail_line_end_){nullptr}
    , decltype(_impl_.strokepatternoffsetdistance_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::DrawableArchive(*from._impl_.super_);
  }
  if (from._internal_has_style()) {
    _this->_impl_.style_ = new ::TSP::Reference(*from._impl_.style_);
  }
  if (from._internal_has_pathsource()) {
    _this->_impl_.pathsource_ = new ::TSD::PathSourceArchive(*from._impl_.pathsource_);
  }
  if (from._internal_has_head_line_end()) {
    _this->_impl_.head_line_end_ = new ::TSD::LineEndArchive(*from._impl_.head_line_end_);
  }
  if (from._internal_has_tail_line_end()) {
    _this->_impl_.tail_line_end_ = new ::TSD::LineEndArchive(*from._impl_.tail_line_end_);
  }
  _this->_impl_.strokepatternoffsetdistance_ = from._impl_.strokepatternoffsetdistance_;
  // @@protoc_insertion_point(copy_constructor:TSD.ShapeArchive)
}

inline void ShapeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.style_){nullptr}
    , decltype(_impl_.pathsource_){nullptr}
    , decltype(_impl_.head_line_end_){nullptr}
    , decltype(_impl_.tail_line_end_){nullptr}
    , decltype(_impl_.strokepatternoffsetdistance_){0}
  };
}

ShapeArchive::~ShapeArchive() {
  // @@protoc_insertion_point(destructor:TSD.ShapeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.style_;
  if (this != internal_default_instance()) delete _impl_.pathsource_;
  if (this != internal_default_instance()) delete _impl_.head_line_end_;
  if (this != internal_default_instance()) delete _impl_.tail_line_end_;
}

void ShapeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ShapeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.style_ != nullptr);
      _impl_.style_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.pathsource_ != nullptr);
      _impl_.pathsource_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.head_line_end_ != nullptr);
      _impl_.head_line_end_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.tail_line_end_ != nullptr);
      _impl_.tail_line_end_->Clear();
    }
  }
  _impl_.strokepatternoffsetdistance_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.DrawableArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference style = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.PathSourceArchive pathsource = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_pathsource(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.LineEndArchive head_line_end = 4 [deprecated = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_head_line_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.LineEndArchive tail_line_end = 5 [deprecated = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_tail_line_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float strokePatternOffsetDistance = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_strokepatternoffsetdistance(&has_bits);
          _impl_.strokepatternoffsetdistance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ShapeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.DrawableArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference style = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::style(this),
        _Internal::style(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.PathSourceArchive pathsource = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::pathsource(this),
        _Internal::pathsource(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.LineEndArchive head_line_end = 4 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::head_line_end(this),
        _Internal::head_line_end(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.LineEndArchive tail_line_end = 5 [deprecated = true];
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::tail_line_end(this),
        _Internal::tail_line_end(this).GetCachedSize(), target, stream);
  }

  // optional float strokePatternOffsetDistance = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_strokepatternoffsetdistance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ShapeArchive)
  return target;
}

size_t ShapeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ShapeArchive)
  size_t total_size = 0;

  // required .TSD.DrawableArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003eu) {
    // optional .TSP.Reference style = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.style_);
    }

    // optional .TSD.PathSourceArchive pathsource = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pathsource_);
    }

    // optional .TSD.LineEndArchive head_line_end = 4 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.head_line_end_);
    }

    // optional .TSD.LineEndArchive tail_line_end = 5 [deprecated = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tail_line_end_);
    }

    // optional float strokePatternOffsetDistance = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapeArchive::GetClassData() const { return &_class_data_; }


void ShapeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapeArchive*>(&to_msg);
  auto& from = static_cast<const ShapeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ShapeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::DrawableArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_style()->::TSP::Reference::MergeFrom(
          from._internal_style());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_pathsource()->::TSD::PathSourceArchive::MergeFrom(
          from._internal_pathsource());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_head_line_end()->::TSD::LineEndArchive::MergeFrom(
          from._internal_head_line_end());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_tail_line_end()->::TSD::LineEndArchive::MergeFrom(
          from._internal_tail_line_end());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.strokepatternoffsetdistance_ = from._impl_.strokepatternoffsetdistance_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapeArchive::CopyFrom(const ShapeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ShapeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_style()) {
    if (!_impl_.style_->IsInitialized()) return false;
  }
  if (_internal_has_pathsource()) {
    if (!_impl_.pathsource_->IsInitialized()) return false;
  }
  if (_internal_has_head_line_end()) {
    if (!_impl_.head_line_end_->IsInitialized()) return false;
  }
  if (_internal_has_tail_line_end()) {
    if (!_impl_.tail_line_end_->IsInitialized()) return false;
  }
  return true;
}

void ShapeArchive::InternalSwap(ShapeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShapeArchive, _impl_.strokepatternoffsetdistance_)
      + sizeof(ShapeArchive::_impl_.strokepatternoffsetdistance_)
      - PROTOBUF_FIELD_OFFSET(ShapeArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[40]);
}

// ===================================================================

class ConnectionLineArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionLineArchive>()._impl_._has_bits_);
  static const ::TSD::ShapeArchive& super(const ConnectionLineArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& connected_from(const ConnectionLineArchive* msg);
  static void set_has_connected_from(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& connected_to(const ConnectionLineArchive* msg);
  static void set_has_connected_to(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::UUID& connected_to_uuid(const ConnectionLineArchive* msg);
  static void set_has_connected_to_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::UUID& connected_from_uuid(const ConnectionLineArchive* msg);
  static void set_has_connected_from_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::ShapeArchive&
ConnectionLineArchive::_Internal::super(const ConnectionLineArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ConnectionLineArchive::_Internal::connected_from(const ConnectionLineArchive* msg) {
  return *msg->_impl_.connected_from_;
}
const ::TSP::Reference&
ConnectionLineArchive::_Internal::connected_to(const ConnectionLineArchive* msg) {
  return *msg->_impl_.connected_to_;
}
const ::TSP::UUID&
ConnectionLineArchive::_Internal::connected_to_uuid(const ConnectionLineArchive* msg) {
  return *msg->_impl_.connected_to_uuid_;
}
const ::TSP::UUID&
ConnectionLineArchive::_Internal::connected_from_uuid(const ConnectionLineArchive* msg) {
  return *msg->_impl_.connected_from_uuid_;
}
void ConnectionLineArchive::clear_connected_from() {
  if (_impl_.connected_from_ != nullptr) _impl_.connected_from_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ConnectionLineArchive::clear_connected_to() {
  if (_impl_.connected_to_ != nullptr) _impl_.connected_to_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ConnectionLineArchive::clear_connected_to_uuid() {
  if (_impl_.connected_to_uuid_ != nullptr) _impl_.connected_to_uuid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void ConnectionLineArchive::clear_connected_from_uuid() {
  if (_impl_.connected_from_uuid_ != nullptr) _impl_.connected_from_uuid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
ConnectionLineArchive::ConnectionLineArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ConnectionLineArchive)
}
ConnectionLineArchive::ConnectionLineArchive(const ConnectionLineArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConnectionLineArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.connected_from_){nullptr}
    , decltype(_impl_.connected_to_){nullptr}
    , decltype(_impl_.connected_to_uuid_){nullptr}
    , decltype(_impl_.connected_from_uuid_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::ShapeArchive(*from._impl_.super_);
  }
  if (from._internal_has_connected_from()) {
    _this->_impl_.connected_from_ = new ::TSP::Reference(*from._impl_.connected_from_);
  }
  if (from._internal_has_connected_to()) {
    _this->_impl_.connected_to_ = new ::TSP::Reference(*from._impl_.connected_to_);
  }
  if (from._internal_has_connected_to_uuid()) {
    _this->_impl_.connected_to_uuid_ = new ::TSP::UUID(*from._impl_.connected_to_uuid_);
  }
  if (from._internal_has_connected_from_uuid()) {
    _this->_impl_.connected_from_uuid_ = new ::TSP::UUID(*from._impl_.connected_from_uuid_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ConnectionLineArchive)
}

inline void ConnectionLineArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.connected_from_){nullptr}
    , decltype(_impl_.connected_to_){nullptr}
    , decltype(_impl_.connected_to_uuid_){nullptr}
    , decltype(_impl_.connected_from_uuid_){nullptr}
  };
}

ConnectionLineArchive::~ConnectionLineArchive() {
  // @@protoc_insertion_point(destructor:TSD.ConnectionLineArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionLineArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.connected_from_;
  if (this != internal_default_instance()) delete _impl_.connected_to_;
  if (this != internal_default_instance()) delete _impl_.connected_to_uuid_;
  if (this != internal_default_instance()) delete _impl_.connected_from_uuid_;
}

void ConnectionLineArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionLineArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ConnectionLineArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.connected_from_ != nullptr);
      _impl_.connected_from_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.connected_to_ != nullptr);
      _impl_.connected_to_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.connected_to_uuid_ != nullptr);
      _impl_.connected_to_uuid_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.connected_from_uuid_ != nullptr);
      _impl_.connected_from_uuid_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConnectionLineArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.ShapeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference connected_from = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_connected_from(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference connected_to = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_connected_to(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.UUID connected_to_uuid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_connected_to_uuid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.UUID connected_from_uuid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_connected_from_uuid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectionLineArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ConnectionLineArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.ShapeArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference connected_from = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::connected_from(this),
        _Internal::connected_from(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference connected_to = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::connected_to(this),
        _Internal::connected_to(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.UUID connected_to_uuid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::connected_to_uuid(this),
        _Internal::connected_to_uuid(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.UUID connected_from_uuid = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::connected_from_uuid(this),
        _Internal::connected_from_uuid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ConnectionLineArchive)
  return target;
}

size_t ConnectionLineArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ConnectionLineArchive)
  size_t total_size = 0;

  // required .TSD.ShapeArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional .TSP.Reference connected_from = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.connected_from_);
    }

    // optional .TSP.Reference connected_to = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.connected_to_);
    }

    // optional .TSP.UUID connected_to_uuid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.connected_to_uuid_);
    }

    // optional .TSP.UUID connected_from_uuid = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.connected_from_uuid_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConnectionLineArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConnectionLineArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConnectionLineArchive::GetClassData() const { return &_class_data_; }


void ConnectionLineArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConnectionLineArchive*>(&to_msg);
  auto& from = static_cast<const ConnectionLineArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ConnectionLineArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::ShapeArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_connected_from()->::TSP::Reference::MergeFrom(
          from._internal_connected_from());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_connected_to()->::TSP::Reference::MergeFrom(
          from._internal_connected_to());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_connected_to_uuid()->::TSP::UUID::MergeFrom(
          from._internal_connected_to_uuid());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_connected_from_uuid()->::TSP::UUID::MergeFrom(
          from._internal_connected_from_uuid());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConnectionLineArchive::CopyFrom(const ConnectionLineArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ConnectionLineArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionLineArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_connected_from()) {
    if (!_impl_.connected_from_->IsInitialized()) return false;
  }
  if (_internal_has_connected_to()) {
    if (!_impl_.connected_to_->IsInitialized()) return false;
  }
  if (_internal_has_connected_to_uuid()) {
    if (!_impl_.connected_to_uuid_->IsInitialized()) return false;
  }
  if (_internal_has_connected_from_uuid()) {
    if (!_impl_.connected_from_uuid_->IsInitialized()) return false;
  }
  return true;
}

void ConnectionLineArchive::InternalSwap(ConnectionLineArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionLineArchive, _impl_.connected_from_uuid_)
      + sizeof(ConnectionLineArchive::_impl_.connected_from_uuid_)
      - PROTOBUF_FIELD_OFFSET(ConnectionLineArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConnectionLineArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[41]);
}

// ===================================================================

class ImageArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ImageArchive>()._impl_._has_bits_);
  static const ::TSD::DrawableArchive& super(const ImageArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::DataReference& data(const ImageArchive* msg);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::TSP::Reference& style(const ImageArchive* msg);
  static void set_has_style(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Size& originalsize(const ImageArchive* msg);
  static void set_has_originalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& mask(const ImageArchive* msg);
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::DataReference& thumbnaildata(const ImageArchive* msg);
  static void set_has_thumbnaildata(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::TSP::DataReference& originaldata(const ImageArchive* msg);
  static void set_has_originaldata(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::TSP::Size& naturalsize(const ImageArchive* msg);
  static void set_has_naturalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::TSP::Path& instantalphapath(const ImageArchive* msg);
  static void set_has_instantalphapath(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::TSD::ImageAdjustmentsArchive& imageadjustments(const ImageArchive* msg);
  static void set_has_imageadjustments(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::TSP::DataReference& enhancedimagedata(const ImageArchive* msg);
  static void set_has_enhancedimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::TSP::DataReference& adjustedimagedata(const ImageArchive* msg);
  static void set_has_adjustedimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::TSP::DataReference& thumbnailadjustedimagedata(const ImageArchive* msg);
  static void set_has_thumbnailadjustedimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_interpretsuntaggedimagedataasgeneric(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::TSP::Reference& database_data(const ImageArchive* msg);
  static void set_has_database_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& database_thumbnaildata(const ImageArchive* msg);
  static void set_has_database_thumbnaildata(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::Reference& database_originaldata(const ImageArchive* msg);
  static void set_has_database_originaldata(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSP::Path& traced_path(const ImageArchive* msg);
  static void set_has_traced_path(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::TSD::Attribution& attribution(const ImageArchive* msg);
  static void set_has_attribution(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_should_trace_pdf_content(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_background_removed(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::DrawableArchive&
ImageArchive::_Internal::super(const ImageArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::DataReference&
ImageArchive::_Internal::data(const ImageArchive* msg) {
  return *msg->_impl_.data_;
}
const ::TSP::Reference&
ImageArchive::_Internal::style(const ImageArchive* msg) {
  return *msg->_impl_.style_;
}
const ::TSP::Size&
ImageArchive::_Internal::originalsize(const ImageArchive* msg) {
  return *msg->_impl_.originalsize_;
}
const ::TSP::Reference&
ImageArchive::_Internal::mask(const ImageArchive* msg) {
  return *msg->_impl_.mask_;
}
const ::TSP::DataReference&
ImageArchive::_Internal::thumbnaildata(const ImageArchive* msg) {
  return *msg->_impl_.thumbnaildata_;
}
const ::TSP::DataReference&
ImageArchive::_Internal::originaldata(const ImageArchive* msg) {
  return *msg->_impl_.originaldata_;
}
const ::TSP::Size&
ImageArchive::_Internal::naturalsize(const ImageArchive* msg) {
  return *msg->_impl_.naturalsize_;
}
const ::TSP::Path&
ImageArchive::_Internal::instantalphapath(const ImageArchive* msg) {
  return *msg->_impl_.instantalphapath_;
}
const ::TSD::ImageAdjustmentsArchive&
ImageArchive::_Internal::imageadjustments(const ImageArchive* msg) {
  return *msg->_impl_.imageadjustments_;
}
const ::TSP::DataReference&
ImageArchive::_Internal::enhancedimagedata(const ImageArchive* msg) {
  return *msg->_impl_.enhancedimagedata_;
}
const ::TSP::DataReference&
ImageArchive::_Internal::adjustedimagedata(const ImageArchive* msg) {
  return *msg->_impl_.adjustedimagedata_;
}
const ::TSP::DataReference&
ImageArchive::_Internal::thumbnailadjustedimagedata(const ImageArchive* msg) {
  return *msg->_impl_.thumbnailadjustedimagedata_;
}
const ::TSP::Reference&
ImageArchive::_Internal::database_data(const ImageArchive* msg) {
  return *msg->_impl_.database_data_;
}
const ::TSP::Reference&
ImageArchive::_Internal::database_thumbnaildata(const ImageArchive* msg) {
  return *msg->_impl_.database_thumbnaildata_;
}
const ::TSP::Reference&
ImageArchive::_Internal::database_originaldata(const ImageArchive* msg) {
  return *msg->_impl_.database_originaldata_;
}
const ::TSP::Path&
ImageArchive::_Internal::traced_path(const ImageArchive* msg) {
  return *msg->_impl_.traced_path_;
}
const ::TSD::Attribution&
ImageArchive::_Internal::attribution(const ImageArchive* msg) {
  return *msg->_impl_.attribution_;
}
void ImageArchive::clear_data() {
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
void ImageArchive::clear_style() {
  if (_impl_.style_ != nullptr) _impl_.style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ImageArchive::clear_originalsize() {
  if (_impl_.originalsize_ != nullptr) _impl_.originalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void ImageArchive::clear_mask() {
  if (_impl_.mask_ != nullptr) _impl_.mask_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void ImageArchive::clear_thumbnaildata() {
  if (_impl_.thumbnaildata_ != nullptr) _impl_.thumbnaildata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
void ImageArchive::clear_originaldata() {
  if (_impl_.originaldata_ != nullptr) _impl_.originaldata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
void ImageArchive::clear_naturalsize() {
  if (_impl_.naturalsize_ != nullptr) _impl_.naturalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
void ImageArchive::clear_instantalphapath() {
  if (_impl_.instantalphapath_ != nullptr) _impl_.instantalphapath_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
void ImageArchive::clear_enhancedimagedata() {
  if (_impl_.enhancedimagedata_ != nullptr) _impl_.enhancedimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
void ImageArchive::clear_adjustedimagedata() {
  if (_impl_.adjustedimagedata_ != nullptr) _impl_.adjustedimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
void ImageArchive::clear_thumbnailadjustedimagedata() {
  if (_impl_.thumbnailadjustedimagedata_ != nullptr) _impl_.thumbnailadjustedimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
void ImageArchive::clear_database_data() {
  if (_impl_.database_data_ != nullptr) _impl_.database_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ImageArchive::clear_database_thumbnaildata() {
  if (_impl_.database_thumbnaildata_ != nullptr) _impl_.database_thumbnaildata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void ImageArchive::clear_database_originaldata() {
  if (_impl_.database_originaldata_ != nullptr) _impl_.database_originaldata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void ImageArchive::clear_traced_path() {
  if (_impl_.traced_path_ != nullptr) _impl_.traced_path_->Clear();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
ImageArchive::ImageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ImageArchive)
}
ImageArchive::ImageArchive(const ImageArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ImageArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.database_data_){nullptr}
    , decltype(_impl_.style_){nullptr}
    , decltype(_impl_.originalsize_){nullptr}
    , decltype(_impl_.mask_){nullptr}
    , decltype(_impl_.database_thumbnaildata_){nullptr}
    , decltype(_impl_.database_originaldata_){nullptr}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.instantalphapath_){nullptr}
    , decltype(_impl_.data_){nullptr}
    , decltype(_impl_.thumbnaildata_){nullptr}
    , decltype(_impl_.originaldata_){nullptr}
    , decltype(_impl_.imageadjustments_){nullptr}
    , decltype(_impl_.adjustedimagedata_){nullptr}
    , decltype(_impl_.thumbnailadjustedimagedata_){nullptr}
    , decltype(_impl_.enhancedimagedata_){nullptr}
    , decltype(_impl_.traced_path_){nullptr}
    , decltype(_impl_.attribution_){nullptr}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.interpretsuntaggedimagedataasgeneric_){}
    , decltype(_impl_.should_trace_pdf_content_){}
    , decltype(_impl_.background_removed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::DrawableArchive(*from._impl_.super_);
  }
  if (from._internal_has_database_data()) {
    _this->_impl_.database_data_ = new ::TSP::Reference(*from._impl_.database_data_);
  }
  if (from._internal_has_style()) {
    _this->_impl_.style_ = new ::TSP::Reference(*from._impl_.style_);
  }
  if (from._internal_has_originalsize()) {
    _this->_impl_.originalsize_ = new ::TSP::Size(*from._impl_.originalsize_);
  }
  if (from._internal_has_mask()) {
    _this->_impl_.mask_ = new ::TSP::Reference(*from._impl_.mask_);
  }
  if (from._internal_has_database_thumbnaildata()) {
    _this->_impl_.database_thumbnaildata_ = new ::TSP::Reference(*from._impl_.database_thumbnaildata_);
  }
  if (from._internal_has_database_originaldata()) {
    _this->_impl_.database_originaldata_ = new ::TSP::Reference(*from._impl_.database_originaldata_);
  }
  if (from._internal_has_naturalsize()) {
    _this->_impl_.naturalsize_ = new ::TSP::Size(*from._impl_.naturalsize_);
  }
  if (from._internal_has_instantalphapath()) {
    _this->_impl_.instantalphapath_ = new ::TSP::Path(*from._impl_.instantalphapath_);
  }
  if (from._internal_has_data()) {
    _this->_impl_.data_ = new ::TSP::DataReference(*from._impl_.data_);
  }
  if (from._internal_has_thumbnaildata()) {
    _this->_impl_.thumbnaildata_ = new ::TSP::DataReference(*from._impl_.thumbnaildata_);
  }
  if (from._internal_has_originaldata()) {
    _this->_impl_.originaldata_ = new ::TSP::DataReference(*from._impl_.originaldata_);
  }
  if (from._internal_has_imageadjustments()) {
    _this->_impl_.imageadjustments_ = new ::TSD::ImageAdjustmentsArchive(*from._impl_.imageadjustments_);
  }
  if (from._internal_has_adjustedimagedata()) {
    _this->_impl_.adjustedimagedata_ = new ::TSP::DataReference(*from._impl_.adjustedimagedata_);
  }
  if (from._internal_has_thumbnailadjustedimagedata()) {
    _this->_impl_.thumbnailadjustedimagedata_ = new ::TSP::DataReference(*from._impl_.thumbnailadjustedimagedata_);
  }
  if (from._internal_has_enhancedimagedata()) {
    _this->_impl_.enhancedimagedata_ = new ::TSP::DataReference(*from._impl_.enhancedimagedata_);
  }
  if (from._internal_has_traced_path()) {
    _this->_impl_.traced_path_ = new ::TSP::Path(*from._impl_.traced_path_);
  }
  if (from._internal_has_attribution()) {
    _this->_impl_.attribution_ = new ::TSD::Attribution(*from._impl_.attribution_);
  }
  ::memcpy(&_impl_.flags_, &from._impl_.flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.background_removed_) -
    reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.background_removed_));
  // @@protoc_insertion_point(copy_constructor:TSD.ImageArchive)
}

inline void ImageArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.database_data_){nullptr}
    , decltype(_impl_.style_){nullptr}
    , decltype(_impl_.originalsize_){nullptr}
    , decltype(_impl_.mask_){nullptr}
    , decltype(_impl_.database_thumbnaildata_){nullptr}
    , decltype(_impl_.database_originaldata_){nullptr}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.instantalphapath_){nullptr}
    , decltype(_impl_.data_){nullptr}
    , decltype(_impl_.thumbnaildata_){nullptr}
    , decltype(_impl_.originaldata_){nullptr}
    , decltype(_impl_.imageadjustments_){nullptr}
    , decltype(_impl_.adjustedimagedata_){nullptr}
    , decltype(_impl_.thumbnailadjustedimagedata_){nullptr}
    , decltype(_impl_.enhancedimagedata_){nullptr}
    , decltype(_impl_.traced_path_){nullptr}
    , decltype(_impl_.attribution_){nullptr}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.interpretsuntaggedimagedataasgeneric_){false}
    , decltype(_impl_.should_trace_pdf_content_){false}
    , decltype(_impl_.background_removed_){false}
  };
}

ImageArchive::~ImageArchive() {
  // @@protoc_insertion_point(destructor:TSD.ImageArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImageArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.database_data_;
  if (this != internal_default_instance()) delete _impl_.style_;
  if (this != internal_default_instance()) delete _impl_.originalsize_;
  if (this != internal_default_instance()) delete _impl_.mask_;
  if (this != internal_default_instance()) delete _impl_.database_thumbnaildata_;
  if (this != internal_default_instance()) delete _impl_.database_originaldata_;
  if (this != internal_default_instance()) delete _impl_.naturalsize_;
  if (this != internal_default_instance()) delete _impl_.instantalphapath_;
  if (this != internal_default_instance()) delete _impl_.data_;
  if (this != internal_default_instance()) delete _impl_.thumbnaildata_;
  if (this != internal_default_instance()) delete _impl_.originaldata_;
  if (this != internal_default_instance()) delete _impl_.imageadjustments_;
  if (this != internal_default_instance()) delete _impl_.adjustedimagedata_;
  if (this != internal_default_instance()) delete _impl_.thumbnailadjustedimagedata_;
  if (this != internal_default_instance()) delete _impl_.enhancedimagedata_;
  if (this != internal_default_instance()) delete _impl_.traced_path_;
  if (this != internal_default_instance()) delete _impl_.attribution_;
}

void ImageArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImageArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ImageArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.database_data_ != nullptr);
      _impl_.database_data_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.style_ != nullptr);
      _impl_.style_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.originalsize_ != nullptr);
      _impl_.originalsize_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.mask_ != nullptr);
      _impl_.mask_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.database_thumbnaildata_ != nullptr);
      _impl_.database_thumbnaildata_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.database_originaldata_ != nullptr);
      _impl_.database_originaldata_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.naturalsize_ != nullptr);
      _impl_.naturalsize_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.instantalphapath_ != nullptr);
      _impl_.instantalphapath_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.data_ != nullptr);
      _impl_.data_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.thumbnaildata_ != nullptr);
      _impl_.thumbnaildata_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.originaldata_ != nullptr);
      _impl_.originaldata_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.imageadjustments_ != nullptr);
      _impl_.imageadjustments_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.adjustedimagedata_ != nullptr);
      _impl_.adjustedimagedata_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.thumbnailadjustedimagedata_ != nullptr);
      _impl_.thumbnailadjustedimagedata_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(_impl_.enhancedimagedata_ != nullptr);
      _impl_.enhancedimagedata_->Clear();
    }
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(_impl_.traced_path_ != nullptr);
      _impl_.traced_path_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(_impl_.attribution_ != nullptr);
      _impl_.attribution_->Clear();
    }
  }
  if (cached_has_bits & 0x003c0000u) {
    ::memset(&_impl_.flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.background_removed_) -
        reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.background_removed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImageArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.DrawableArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size originalSize = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_originalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference mask = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_mask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_thumbnailData = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_thumbnaildata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_originalData = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_originaldata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size naturalSize = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_naturalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Path instantAlphaPath = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_instantalphapath(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference data = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference thumbnailData = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_thumbnaildata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference originalData = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_originaldata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ImageAdjustmentsArchive imageAdjustments = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_imageadjustments(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference adjustedImageData = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_adjustedimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference thumbnailAdjustedImageData = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_thumbnailadjustedimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference enhancedImageData = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_enhancedimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool interpretsUntaggedImageDataAsGeneric = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_interpretsuntaggedimagedataasgeneric(&has_bits);
          _impl_.interpretsuntaggedimagedataasgeneric_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Path traced_path = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_traced_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.Attribution attribution = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_attribution(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool should_trace_pdf_content = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_should_trace_pdf_content(&has_bits);
          _impl_.should_trace_pdf_content_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool background_removed = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_background_removed(&has_bits);
          _impl_.background_removed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((800u <= tag && tag < 8000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ImageArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.DrawableArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference database_data = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::database_data(this),
        _Internal::database_data(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference style = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::style(this),
        _Internal::style(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size originalSize = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::originalsize(this),
        _Internal::originalsize(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference mask = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::mask(this),
        _Internal::mask(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference database_thumbnailData = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::database_thumbnaildata(this),
        _Internal::database_thumbnaildata(this).GetCachedSize(), target, stream);
  }

  // optional uint32 flags = 7;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_flags(), target);
  }

  // optional .TSP.Reference database_originalData = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::database_originaldata(this),
        _Internal::database_originaldata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size naturalSize = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::naturalsize(this),
        _Internal::naturalsize(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Path instantAlphaPath = 10;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::instantalphapath(this),
        _Internal::instantalphapath(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference data = 11;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::data(this),
        _Internal::data(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference thumbnailData = 12;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::thumbnaildata(this),
        _Internal::thumbnaildata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference originalData = 13;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::originaldata(this),
        _Internal::originaldata(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ImageAdjustmentsArchive imageAdjustments = 14;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::imageadjustments(this),
        _Internal::imageadjustments(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference adjustedImageData = 15;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::adjustedimagedata(this),
        _Internal::adjustedimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference thumbnailAdjustedImageData = 16;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::thumbnailadjustedimagedata(this),
        _Internal::thumbnailadjustedimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference enhancedImageData = 17;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::enhancedimagedata(this),
        _Internal::enhancedimagedata(this).GetCachedSize(), target, stream);
  }

  // optional bool interpretsUntaggedImageDataAsGeneric = 18;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_interpretsuntaggedimagedataasgeneric(), target);
  }

  // optional .TSP.Path traced_path = 19;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::traced_path(this),
        _Internal::traced_path(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.Attribution attribution = 20;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::attribution(this),
        _Internal::attribution(this).GetCachedSize(), target, stream);
  }

  // optional bool should_trace_pdf_content = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_should_trace_pdf_content(), target);
  }

  // optional bool background_removed = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_background_removed(), target);
  }

  // Extension range [100, 1000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 100, 1000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ImageArchive)
  return target;
}

size_t ImageArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ImageArchive)
  size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  // required .TSD.DrawableArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional .TSP.Reference database_data = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_data_);
    }

    // optional .TSP.Reference style = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.style_);
    }

    // optional .TSP.Size originalSize = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.originalsize_);
    }

    // optional .TSP.Reference mask = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.mask_);
    }

    // optional .TSP.Reference database_thumbnailData = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_thumbnaildata_);
    }

    // optional .TSP.Reference database_originalData = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_originaldata_);
    }

    // optional .TSP.Size naturalSize = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.naturalsize_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .TSP.Path instantAlphaPath = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.instantalphapath_);
    }

    // optional .TSP.DataReference data = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_);
    }

    // optional .TSP.DataReference thumbnailData = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.thumbnaildata_);
    }

    // optional .TSP.DataReference originalData = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.originaldata_);
    }

    // optional .TSD.ImageAdjustmentsArchive imageAdjustments = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.imageadjustments_);
    }

    // optional .TSP.DataReference adjustedImageData = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.adjustedimagedata_);
    }

    // optional .TSP.DataReference thumbnailAdjustedImageData = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.thumbnailadjustedimagedata_);
    }

    // optional .TSP.DataReference enhancedImageData = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.enhancedimagedata_);
    }

  }
  if (cached_has_bits & 0x003f0000u) {
    // optional .TSP.Path traced_path = 19;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.traced_path_);
    }

    // optional .TSD.Attribution attribution = 20;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.attribution_);
    }

    // optional uint32 flags = 7;
    if (cached_has_bits & 0x00040000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional bool interpretsUntaggedImageDataAsGeneric = 18;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional bool should_trace_pdf_content = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional bool background_removed = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImageArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ImageArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImageArchive::GetClassData() const { return &_class_data_; }


void ImageArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ImageArchive*>(&to_msg);
  auto& from = static_cast<const ImageArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ImageArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::DrawableArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_database_data()->::TSP::Reference::MergeFrom(
          from._internal_database_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_style()->::TSP::Reference::MergeFrom(
          from._internal_style());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_originalsize()->::TSP::Size::MergeFrom(
          from._internal_originalsize());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_mask()->::TSP::Reference::MergeFrom(
          from._internal_mask());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_database_thumbnaildata()->::TSP::Reference::MergeFrom(
          from._internal_database_thumbnaildata());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_database_originaldata()->::TSP::Reference::MergeFrom(
          from._internal_database_originaldata());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_naturalsize()->::TSP::Size::MergeFrom(
          from._internal_naturalsize());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_instantalphapath()->::TSP::Path::MergeFrom(
          from._internal_instantalphapath());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_data()->::TSP::DataReference::MergeFrom(
          from._internal_data());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_thumbnaildata()->::TSP::DataReference::MergeFrom(
          from._internal_thumbnaildata());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_originaldata()->::TSP::DataReference::MergeFrom(
          from._internal_originaldata());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_imageadjustments()->::TSD::ImageAdjustmentsArchive::MergeFrom(
          from._internal_imageadjustments());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_adjustedimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_adjustedimagedata());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_thumbnailadjustedimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_thumbnailadjustedimagedata());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_enhancedimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_enhancedimagedata());
    }
  }
  if (cached_has_bits & 0x003f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_mutable_traced_path()->::TSP::Path::MergeFrom(
          from._internal_traced_path());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_mutable_attribution()->::TSD::Attribution::MergeFrom(
          from._internal_attribution());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.interpretsuntaggedimagedataasgeneric_ = from._impl_.interpretsuntaggedimagedataasgeneric_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.should_trace_pdf_content_ = from._impl_.should_trace_pdf_content_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.background_removed_ = from._impl_.background_removed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImageArchive::CopyFrom(const ImageArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ImageArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageArchive::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized()) {
    return false;
  }

  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_database_data()) {
    if (!_impl_.database_data_->IsInitialized()) return false;
  }
  if (_internal_has_style()) {
    if (!_impl_.style_->IsInitialized()) return false;
  }
  if (_internal_has_originalsize()) {
    if (!_impl_.originalsize_->IsInitialized()) return false;
  }
  if (_internal_has_mask()) {
    if (!_impl_.mask_->IsInitialized()) return false;
  }
  if (_internal_has_database_thumbnaildata()) {
    if (!_impl_.database_thumbnaildata_->IsInitialized()) return false;
  }
  if (_internal_has_database_originaldata()) {
    if (!_impl_.database_originaldata_->IsInitialized()) return false;
  }
  if (_internal_has_naturalsize()) {
    if (!_impl_.naturalsize_->IsInitialized()) return false;
  }
  if (_internal_has_instantalphapath()) {
    if (!_impl_.instantalphapath_->IsInitialized()) return false;
  }
  if (_internal_has_data()) {
    if (!_impl_.data_->IsInitialized()) return false;
  }
  if (_internal_has_thumbnaildata()) {
    if (!_impl_.thumbnaildata_->IsInitialized()) return false;
  }
  if (_internal_has_originaldata()) {
    if (!_impl_.originaldata_->IsInitialized()) return false;
  }
  if (_internal_has_adjustedimagedata()) {
    if (!_impl_.adjustedimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_thumbnailadjustedimagedata()) {
    if (!_impl_.thumbnailadjustedimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_enhancedimagedata()) {
    if (!_impl_.enhancedimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_traced_path()) {
    if (!_impl_.traced_path_->IsInitialized()) return false;
  }
  return true;
}

void ImageArchive::InternalSwap(ImageArchive* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImageArchive, _impl_.background_removed_)
      + sizeof(ImageArchive::_impl_.background_removed_)
      - PROTOBUF_FIELD_OFFSET(ImageArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ImageArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[42]);
}

// ===================================================================

class MaskArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MaskArchive>()._impl_._has_bits_);
  static const ::TSD::DrawableArchive& super(const MaskArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::PathSourceArchive& pathsource(const MaskArchive* msg);
  static void set_has_pathsource(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::DrawableArchive&
MaskArchive::_Internal::super(const MaskArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSD::PathSourceArchive&
MaskArchive::_Internal::pathsource(const MaskArchive* msg) {
  return *msg->_impl_.pathsource_;
}
MaskArchive::MaskArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.MaskArchive)
}
MaskArchive::MaskArchive(const MaskArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MaskArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.pathsource_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::DrawableArchive(*from._impl_.super_);
  }
  if (from._internal_has_pathsource()) {
    _this->_impl_.pathsource_ = new ::TSD::PathSourceArchive(*from._impl_.pathsource_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.MaskArchive)
}

inline void MaskArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.pathsource_){nullptr}
  };
}

MaskArchive::~MaskArchive() {
  // @@protoc_insertion_point(destructor:TSD.MaskArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MaskArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.pathsource_;
}

void MaskArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MaskArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.MaskArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.pathsource_ != nullptr);
      _impl_.pathsource_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MaskArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.DrawableArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.PathSourceArchive pathsource = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pathsource(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MaskArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.MaskArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.DrawableArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.PathSourceArchive pathsource = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::pathsource(this),
        _Internal::pathsource(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.MaskArchive)
  return target;
}

size_t MaskArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.MaskArchive)
  size_t total_size = 0;

  // required .TSD.DrawableArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSD.PathSourceArchive pathsource = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pathsource_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MaskArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MaskArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MaskArchive::GetClassData() const { return &_class_data_; }


void MaskArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MaskArchive*>(&to_msg);
  auto& from = static_cast<const MaskArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.MaskArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::DrawableArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_pathsource()->::TSD::PathSourceArchive::MergeFrom(
          from._internal_pathsource());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MaskArchive::CopyFrom(const MaskArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.MaskArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MaskArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_pathsource()) {
    if (!_impl_.pathsource_->IsInitialized()) return false;
  }
  return true;
}

void MaskArchive::InternalSwap(MaskArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MaskArchive, _impl_.pathsource_)
      + sizeof(MaskArchive::_impl_.pathsource_)
      - PROTOBUF_FIELD_OFFSET(MaskArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MaskArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[43]);
}

// ===================================================================

class ImageDataAttributes::_Internal {
 public:
  using HasBits = decltype(std::declval<ImageDataAttributes>()._impl_._has_bits_);
  static const ::TSP::Size& pixel_size(const ImageDataAttributes* msg);
  static void set_has_pixel_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_image_is_srgb(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_should_be_interpreted_as_generic_if_untagged(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSP::Size&
ImageDataAttributes::_Internal::pixel_size(const ImageDataAttributes* msg) {
  return *msg->_impl_.pixel_size_;
}
void ImageDataAttributes::clear_pixel_size() {
  if (_impl_.pixel_size_ != nullptr) _impl_.pixel_size_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ImageDataAttributes::ImageDataAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ImageDataAttributes)
}
ImageDataAttributes::ImageDataAttributes(const ImageDataAttributes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ImageDataAttributes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pixel_size_){nullptr}
    , decltype(_impl_.image_is_srgb_){}
    , decltype(_impl_.should_be_interpreted_as_generic_if_untagged_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pixel_size()) {
    _this->_impl_.pixel_size_ = new ::TSP::Size(*from._impl_.pixel_size_);
  }
  ::memcpy(&_impl_.image_is_srgb_, &from._impl_.image_is_srgb_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.should_be_interpreted_as_generic_if_untagged_) -
    reinterpret_cast<char*>(&_impl_.image_is_srgb_)) + sizeof(_impl_.should_be_interpreted_as_generic_if_untagged_));
  // @@protoc_insertion_point(copy_constructor:TSD.ImageDataAttributes)
}

inline void ImageDataAttributes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pixel_size_){nullptr}
    , decltype(_impl_.image_is_srgb_){false}
    , decltype(_impl_.should_be_interpreted_as_generic_if_untagged_){false}
  };
}

ImageDataAttributes::~ImageDataAttributes() {
  // @@protoc_insertion_point(destructor:TSD.ImageDataAttributes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImageDataAttributes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pixel_size_;
}

void ImageDataAttributes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImageDataAttributes::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ImageDataAttributes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.pixel_size_ != nullptr);
    _impl_.pixel_size_->Clear();
  }
  ::memset(&_impl_.image_is_srgb_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.should_be_interpreted_as_generic_if_untagged_) -
      reinterpret_cast<char*>(&_impl_.image_is_srgb_)) + sizeof(_impl_.should_be_interpreted_as_generic_if_untagged_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImageDataAttributes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Size pixel_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pixel_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool image_is_srgb = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_image_is_srgb(&has_bits);
          _impl_.image_is_srgb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool should_be_interpreted_as_generic_if_untagged = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_should_be_interpreted_as_generic_if_untagged(&has_bits);
          _impl_.should_be_interpreted_as_generic_if_untagged_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageDataAttributes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ImageDataAttributes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Size pixel_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pixel_size(this),
        _Internal::pixel_size(this).GetCachedSize(), target, stream);
  }

  // optional bool image_is_srgb = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_image_is_srgb(), target);
  }

  // optional bool should_be_interpreted_as_generic_if_untagged = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_should_be_interpreted_as_generic_if_untagged(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ImageDataAttributes)
  return target;
}

size_t ImageDataAttributes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ImageDataAttributes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSP.Size pixel_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pixel_size_);
    }

    // optional bool image_is_srgb = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool should_be_interpreted_as_generic_if_untagged = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImageDataAttributes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ImageDataAttributes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImageDataAttributes::GetClassData() const { return &_class_data_; }


void ImageDataAttributes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ImageDataAttributes*>(&to_msg);
  auto& from = static_cast<const ImageDataAttributes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ImageDataAttributes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_pixel_size()->::TSP::Size::MergeFrom(
          from._internal_pixel_size());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.image_is_srgb_ = from._impl_.image_is_srgb_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.should_be_interpreted_as_generic_if_untagged_ = from._impl_.should_be_interpreted_as_generic_if_untagged_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImageDataAttributes::CopyFrom(const ImageDataAttributes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ImageDataAttributes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageDataAttributes::IsInitialized() const {
  if (_internal_has_pixel_size()) {
    if (!_impl_.pixel_size_->IsInitialized()) return false;
  }
  return true;
}

void ImageDataAttributes::InternalSwap(ImageDataAttributes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImageDataAttributes, _impl_.should_be_interpreted_as_generic_if_untagged_)
      + sizeof(ImageDataAttributes::_impl_.should_be_interpreted_as_generic_if_untagged_)
      - PROTOBUF_FIELD_OFFSET(ImageDataAttributes, _impl_.pixel_size_)>(
          reinterpret_cast<char*>(&_impl_.pixel_size_),
          reinterpret_cast<char*>(&other->_impl_.pixel_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ImageDataAttributes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[44]);
}

// ===================================================================

class MovieArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MovieArchive>()._impl_._has_bits_);
  static const ::TSD::DrawableArchive& super(const MovieArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::DataReference& moviedata(const MovieArchive* msg);
  static void set_has_moviedata(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSP::DataReference& importedauxiliarymoviedata(const MovieArchive* msg);
  static void set_has_importedauxiliarymoviedata(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_imported_auxiliary_movie_data_original_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_movieremoteurl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_starttime(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_endtime(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_postertime(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_loopoptionasinteger(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_loop_option(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_autoplay(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_audioonly(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_streaming(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_nativeaudiorecording(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_playsacrossslides(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static const ::TSP::DataReference& posterimagedata(const MovieArchive* msg);
  static void set_has_posterimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::TSP::DataReference& audioonlyimagedata(const MovieArchive* msg);
  static void set_has_audioonlyimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_poster_image_generated_with_alpha_support(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_playablestate(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::TSP::Reference& database_moviedata(const MovieArchive* msg);
  static void set_has_database_moviedata(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& database_posterimagedata(const MovieArchive* msg);
  static void set_has_database_posterimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& database_audioonlyimagedata(const MovieArchive* msg);
  static void set_has_database_audioonlyimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::Reference& style(const MovieArchive* msg);
  static void set_has_style(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::TSP::Size& originalsize(const MovieArchive* msg);
  static void set_has_originalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::TSP::Size& naturalsize(const MovieArchive* msg);
  static void set_has_naturalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::TSD::Attribution& attribution(const MovieArchive* msg);
  static void set_has_attribution(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::TSD::MovieFingerprint& fingerprint(const MovieArchive* msg);
  static void set_has_fingerprint(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_is_live_video(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

const ::TSD::DrawableArchive&
MovieArchive::_Internal::super(const MovieArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::DataReference&
MovieArchive::_Internal::moviedata(const MovieArchive* msg) {
  return *msg->_impl_.moviedata_;
}
const ::TSP::DataReference&
MovieArchive::_Internal::importedauxiliarymoviedata(const MovieArchive* msg) {
  return *msg->_impl_.importedauxiliarymoviedata_;
}
const ::TSP::DataReference&
MovieArchive::_Internal::posterimagedata(const MovieArchive* msg) {
  return *msg->_impl_.posterimagedata_;
}
const ::TSP::DataReference&
MovieArchive::_Internal::audioonlyimagedata(const MovieArchive* msg) {
  return *msg->_impl_.audioonlyimagedata_;
}
const ::TSP::Reference&
MovieArchive::_Internal::database_moviedata(const MovieArchive* msg) {
  return *msg->_impl_.database_moviedata_;
}
const ::TSP::Reference&
MovieArchive::_Internal::database_posterimagedata(const MovieArchive* msg) {
  return *msg->_impl_.database_posterimagedata_;
}
const ::TSP::Reference&
MovieArchive::_Internal::database_audioonlyimagedata(const MovieArchive* msg) {
  return *msg->_impl_.database_audioonlyimagedata_;
}
const ::TSP::Reference&
MovieArchive::_Internal::style(const MovieArchive* msg) {
  return *msg->_impl_.style_;
}
const ::TSP::Size&
MovieArchive::_Internal::originalsize(const MovieArchive* msg) {
  return *msg->_impl_.originalsize_;
}
const ::TSP::Size&
MovieArchive::_Internal::naturalsize(const MovieArchive* msg) {
  return *msg->_impl_.naturalsize_;
}
const ::TSD::Attribution&
MovieArchive::_Internal::attribution(const MovieArchive* msg) {
  return *msg->_impl_.attribution_;
}
const ::TSD::MovieFingerprint&
MovieArchive::_Internal::fingerprint(const MovieArchive* msg) {
  return *msg->_impl_.fingerprint_;
}
void MovieArchive::clear_moviedata() {
  if (_impl_.moviedata_ != nullptr) _impl_.moviedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void MovieArchive::clear_importedauxiliarymoviedata() {
  if (_impl_.importedauxiliarymoviedata_ != nullptr) _impl_.importedauxiliarymoviedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
void MovieArchive::clear_posterimagedata() {
  if (_impl_.posterimagedata_ != nullptr) _impl_.posterimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
void MovieArchive::clear_audioonlyimagedata() {
  if (_impl_.audioonlyimagedata_ != nullptr) _impl_.audioonlyimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
void MovieArchive::clear_database_moviedata() {
  if (_impl_.database_moviedata_ != nullptr) _impl_.database_moviedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void MovieArchive::clear_database_posterimagedata() {
  if (_impl_.database_posterimagedata_ != nullptr) _impl_.database_posterimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void MovieArchive::clear_database_audioonlyimagedata() {
  if (_impl_.database_audioonlyimagedata_ != nullptr) _impl_.database_audioonlyimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void MovieArchive::clear_style() {
  if (_impl_.style_ != nullptr) _impl_.style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
void MovieArchive::clear_originalsize() {
  if (_impl_.originalsize_ != nullptr) _impl_.originalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
void MovieArchive::clear_naturalsize() {
  if (_impl_.naturalsize_ != nullptr) _impl_.naturalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
MovieArchive::MovieArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.MovieArchive)
}
MovieArchive::MovieArchive(const MovieArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MovieArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.movieremoteurl_){}
    , decltype(_impl_.imported_auxiliary_movie_data_original_filename_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.database_moviedata_){nullptr}
    , decltype(_impl_.database_posterimagedata_){nullptr}
    , decltype(_impl_.database_audioonlyimagedata_){nullptr}
    , decltype(_impl_.moviedata_){nullptr}
    , decltype(_impl_.posterimagedata_){nullptr}
    , decltype(_impl_.audioonlyimagedata_){nullptr}
    , decltype(_impl_.style_){nullptr}
    , decltype(_impl_.originalsize_){nullptr}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.importedauxiliarymoviedata_){nullptr}
    , decltype(_impl_.attribution_){nullptr}
    , decltype(_impl_.fingerprint_){nullptr}
    , decltype(_impl_.starttime_){}
    , decltype(_impl_.endtime_){}
    , decltype(_impl_.postertime_){}
    , decltype(_impl_.loopoptionasinteger_){}
    , decltype(_impl_.volume_){}
    , decltype(_impl_.playablestate_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.autoplay_){}
    , decltype(_impl_.audioonly_){}
    , decltype(_impl_.streaming_){}
    , decltype(_impl_.nativeaudiorecording_){}
    , decltype(_impl_.loop_option_){}
    , decltype(_impl_.playsacrossslides_){}
    , decltype(_impl_.poster_image_generated_with_alpha_support_){}
    , decltype(_impl_.is_live_video_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.movieremoteurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.movieremoteurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_movieremoteurl()) {
    _this->_impl_.movieremoteurl_.Set(from._internal_movieremoteurl(), 
      _this->GetArenaForAllocation());
  }
  _impl_.imported_auxiliary_movie_data_original_filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imported_auxiliary_movie_data_original_filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_imported_auxiliary_movie_data_original_filename()) {
    _this->_impl_.imported_auxiliary_movie_data_original_filename_.Set(from._internal_imported_auxiliary_movie_data_original_filename(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::DrawableArchive(*from._impl_.super_);
  }
  if (from._internal_has_database_moviedata()) {
    _this->_impl_.database_moviedata_ = new ::TSP::Reference(*from._impl_.database_moviedata_);
  }
  if (from._internal_has_database_posterimagedata()) {
    _this->_impl_.database_posterimagedata_ = new ::TSP::Reference(*from._impl_.database_posterimagedata_);
  }
  if (from._internal_has_database_audioonlyimagedata()) {
    _this->_impl_.database_audioonlyimagedata_ = new ::TSP::Reference(*from._impl_.database_audioonlyimagedata_);
  }
  if (from._internal_has_moviedata()) {
    _this->_impl_.moviedata_ = new ::TSP::DataReference(*from._impl_.moviedata_);
  }
  if (from._internal_has_posterimagedata()) {
    _this->_impl_.posterimagedata_ = new ::TSP::DataReference(*from._impl_.posterimagedata_);
  }
  if (from._internal_has_audioonlyimagedata()) {
    _this->_impl_.audioonlyimagedata_ = new ::TSP::DataReference(*from._impl_.audioonlyimagedata_);
  }
  if (from._internal_has_style()) {
    _this->_impl_.style_ = new ::TSP::Reference(*from._impl_.style_);
  }
  if (from._internal_has_originalsize()) {
    _this->_impl_.originalsize_ = new ::TSP::Size(*from._impl_.originalsize_);
  }
  if (from._internal_has_naturalsize()) {
    _this->_impl_.naturalsize_ = new ::TSP::Size(*from._impl_.naturalsize_);
  }
  if (from._internal_has_importedauxiliarymoviedata()) {
    _this->_impl_.importedauxiliarymoviedata_ = new ::TSP::DataReference(*from._impl_.importedauxiliarymoviedata_);
  }
  if (from._internal_has_attribution()) {
    _this->_impl_.attribution_ = new ::TSD::Attribution(*from._impl_.attribution_);
  }
  if (from._internal_has_fingerprint()) {
    _this->_impl_.fingerprint_ = new ::TSD::MovieFingerprint(*from._impl_.fingerprint_);
  }
  ::memcpy(&_impl_.starttime_, &from._impl_.starttime_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_live_video_) -
    reinterpret_cast<char*>(&_impl_.starttime_)) + sizeof(_impl_.is_live_video_));
  // @@protoc_insertion_point(copy_constructor:TSD.MovieArchive)
}

inline void MovieArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.movieremoteurl_){}
    , decltype(_impl_.imported_auxiliary_movie_data_original_filename_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.database_moviedata_){nullptr}
    , decltype(_impl_.database_posterimagedata_){nullptr}
    , decltype(_impl_.database_audioonlyimagedata_){nullptr}
    , decltype(_impl_.moviedata_){nullptr}
    , decltype(_impl_.posterimagedata_){nullptr}
    , decltype(_impl_.audioonlyimagedata_){nullptr}
    , decltype(_impl_.style_){nullptr}
    , decltype(_impl_.originalsize_){nullptr}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.importedauxiliarymoviedata_){nullptr}
    , decltype(_impl_.attribution_){nullptr}
    , decltype(_impl_.fingerprint_){nullptr}
    , decltype(_impl_.starttime_){0}
    , decltype(_impl_.endtime_){0}
    , decltype(_impl_.postertime_){0}
    , decltype(_impl_.loopoptionasinteger_){0u}
    , decltype(_impl_.volume_){0}
    , decltype(_impl_.playablestate_){0u}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.autoplay_){false}
    , decltype(_impl_.audioonly_){false}
    , decltype(_impl_.streaming_){false}
    , decltype(_impl_.nativeaudiorecording_){false}
    , decltype(_impl_.loop_option_){0}
    , decltype(_impl_.playsacrossslides_){false}
    , decltype(_impl_.poster_image_generated_with_alpha_support_){false}
    , decltype(_impl_.is_live_video_){false}
  };
  _impl_.movieremoteurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.movieremoteurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.imported_auxiliary_movie_data_original_filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imported_auxiliary_movie_data_original_filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MovieArchive::~MovieArchive() {
  // @@protoc_insertion_point(destructor:TSD.MovieArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MovieArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.movieremoteurl_.Destroy();
  _impl_.imported_auxiliary_movie_data_original_filename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.database_moviedata_;
  if (this != internal_default_instance()) delete _impl_.database_posterimagedata_;
  if (this != internal_default_instance()) delete _impl_.database_audioonlyimagedata_;
  if (this != internal_default_instance()) delete _impl_.moviedata_;
  if (this != internal_default_instance()) delete _impl_.posterimagedata_;
  if (this != internal_default_instance()) delete _impl_.audioonlyimagedata_;
  if (this != internal_default_instance()) delete _impl_.style_;
  if (this != internal_default_instance()) delete _impl_.originalsize_;
  if (this != internal_default_instance()) delete _impl_.naturalsize_;
  if (this != internal_default_instance()) delete _impl_.importedauxiliarymoviedata_;
  if (this != internal_default_instance()) delete _impl_.attribution_;
  if (this != internal_default_instance()) delete _impl_.fingerprint_;
}

void MovieArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MovieArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.MovieArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.movieremoteurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.imported_auxiliary_movie_data_original_filename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.database_moviedata_ != nullptr);
      _impl_.database_moviedata_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.database_posterimagedata_ != nullptr);
      _impl_.database_posterimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.database_audioonlyimagedata_ != nullptr);
      _impl_.database_audioonlyimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.moviedata_ != nullptr);
      _impl_.moviedata_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.posterimagedata_ != nullptr);
      _impl_.posterimagedata_->Clear();
    }
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.audioonlyimagedata_ != nullptr);
      _impl_.audioonlyimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.style_ != nullptr);
      _impl_.style_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.originalsize_ != nullptr);
      _impl_.originalsize_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.naturalsize_ != nullptr);
      _impl_.naturalsize_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.importedauxiliarymoviedata_ != nullptr);
      _impl_.importedauxiliarymoviedata_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.attribution_ != nullptr);
      _impl_.attribution_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.fingerprint_ != nullptr);
      _impl_.fingerprint_->Clear();
    }
  }
  _impl_.starttime_ = 0;
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.endtime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.audioonly_) -
        reinterpret_cast<char*>(&_impl_.endtime_)) + sizeof(_impl_.audioonly_));
  }
  if (cached_has_bits & 0x3f000000u) {
    ::memset(&_impl_.streaming_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_live_video_) -
        reinterpret_cast<char*>(&_impl_.streaming_)) + sizeof(_impl_.is_live_video_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MovieArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.DrawableArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_movieData = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_moviedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float startTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_starttime(&has_bits);
          _impl_.starttime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float endTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_endtime(&has_bits);
          _impl_.endtime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float posterTime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_postertime(&has_bits);
          _impl_.postertime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 loopOptionAsInteger = 6 [deprecated = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_loopoptionasinteger(&has_bits);
          _impl_.loopoptionasinteger_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float volume = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_volume(&has_bits);
          _impl_.volume_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool autoPlay = 8 [deprecated = true];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_autoplay(&has_bits);
          _impl_.autoplay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool audioOnly = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_audioonly(&has_bits);
          _impl_.audioonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_posterImageData = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_posterimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_audioOnlyImageData = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_audioonlyimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 playableState = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_playablestate(&has_bits);
          _impl_.playablestate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference movieData = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_moviedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference posterImageData = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_posterimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference audioOnlyImageData = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_audioonlyimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string movieRemoteURL = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_movieremoteurl();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.MovieArchive.movieRemoteURL");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool streaming = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_streaming(&has_bits);
          _impl_.streaming_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference style = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size originalSize = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_originalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size naturalSize = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_naturalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference importedAuxiliaryMovieData = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_importedauxiliarymoviedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool poster_image_generated_with_alpha_support = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_poster_image_generated_with_alpha_support(&has_bits);
          _impl_.poster_image_generated_with_alpha_support_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.MovieArchive.MovieLoopOption loop_option = 24 [default = None];
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::MovieArchive_MovieLoopOption_IsValid(val))) {
            _internal_set_loop_option(static_cast<::TSD::MovieArchive_MovieLoopOption>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(24, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string imported_auxiliary_movie_data_original_filename = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          auto str = _internal_mutable_imported_auxiliary_movie_data_original_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.MovieArchive.imported_auxiliary_movie_data_original_filename");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.Attribution attribution = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_attribution(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool nativeAudioRecording = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_nativeaudiorecording(&has_bits);
          _impl_.nativeaudiorecording_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool playsAcrossSlides = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_playsacrossslides(&has_bits);
          _impl_.playsacrossslides_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.MovieFingerprint fingerprint = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_fingerprint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_live_video = 30 [default = false];
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_is_live_video(&has_bits);
          _impl_.is_live_video_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((800u <= tag && tag < 8000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MovieArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.MovieArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.DrawableArchive super = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference database_movieData = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::database_moviedata(this),
        _Internal::database_moviedata(this).GetCachedSize(), target, stream);
  }

  // optional float startTime = 3;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_starttime(), target);
  }

  // optional float endTime = 4;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_endtime(), target);
  }

  // optional float posterTime = 5;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_postertime(), target);
  }

  // optional uint32 loopOptionAsInteger = 6 [deprecated = true];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_loopoptionasinteger(), target);
  }

  // optional float volume = 7;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_volume(), target);
  }

  // optional bool autoPlay = 8 [deprecated = true];
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_autoplay(), target);
  }

  // optional bool audioOnly = 9;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_audioonly(), target);
  }

  // optional .TSP.Reference database_posterImageData = 10;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::database_posterimagedata(this),
        _Internal::database_posterimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference database_audioOnlyImageData = 11;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::database_audioonlyimagedata(this),
        _Internal::database_audioonlyimagedata(this).GetCachedSize(), target, stream);
  }

  // optional uint32 playableState = 12;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_playablestate(), target);
  }

  // optional uint32 flags = 13;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_flags(), target);
  }

  // optional .TSP.DataReference movieData = 14;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::moviedata(this),
        _Internal::moviedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference posterImageData = 15;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::posterimagedata(this),
        _Internal::posterimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference audioOnlyImageData = 16;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::audioonlyimagedata(this),
        _Internal::audioonlyimagedata(this).GetCachedSize(), target, stream);
  }

  // optional string movieRemoteURL = 17;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_movieremoteurl().data(), static_cast<int>(this->_internal_movieremoteurl().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.MovieArchive.movieRemoteURL");
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_movieremoteurl(), target);
  }

  // optional bool streaming = 18;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_streaming(), target);
  }

  // optional .TSP.Reference style = 19;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::style(this),
        _Internal::style(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size originalSize = 20;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::originalsize(this),
        _Internal::originalsize(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size naturalSize = 21;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::naturalsize(this),
        _Internal::naturalsize(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference importedAuxiliaryMovieData = 22;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::importedauxiliarymoviedata(this),
        _Internal::importedauxiliarymoviedata(this).GetCachedSize(), target, stream);
  }

  // optional bool poster_image_generated_with_alpha_support = 23;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(23, this->_internal_poster_image_generated_with_alpha_support(), target);
  }

  // optional .TSD.MovieArchive.MovieLoopOption loop_option = 24 [default = None];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      24, this->_internal_loop_option(), target);
  }

  // optional string imported_auxiliary_movie_data_original_filename = 25;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_imported_auxiliary_movie_data_original_filename().data(), static_cast<int>(this->_internal_imported_auxiliary_movie_data_original_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.MovieArchive.imported_auxiliary_movie_data_original_filename");
    target = stream->WriteStringMaybeAliased(
        25, this->_internal_imported_auxiliary_movie_data_original_filename(), target);
  }

  // optional .TSD.Attribution attribution = 26;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::attribution(this),
        _Internal::attribution(this).GetCachedSize(), target, stream);
  }

  // optional bool nativeAudioRecording = 27;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(27, this->_internal_nativeaudiorecording(), target);
  }

  // optional bool playsAcrossSlides = 28;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(28, this->_internal_playsacrossslides(), target);
  }

  // optional .TSD.MovieFingerprint fingerprint = 29;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::fingerprint(this),
        _Internal::fingerprint(this).GetCachedSize(), target, stream);
  }

  // optional bool is_live_video = 30 [default = false];
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(30, this->_internal_is_live_video(), target);
  }

  // Extension range [100, 1000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 100, 1000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.MovieArchive)
  return target;
}

size_t MovieArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.MovieArchive)
  size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  // required .TSD.DrawableArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string movieRemoteURL = 17;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_movieremoteurl());
    }

    // optional string imported_auxiliary_movie_data_original_filename = 25;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_imported_auxiliary_movie_data_original_filename());
    }

  }
  if (cached_has_bits & 0x000000f8u) {
    // optional .TSP.Reference database_movieData = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_moviedata_);
    }

    // optional .TSP.Reference database_posterImageData = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_posterimagedata_);
    }

    // optional .TSP.Reference database_audioOnlyImageData = 11;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_audioonlyimagedata_);
    }

    // optional .TSP.DataReference movieData = 14;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.moviedata_);
    }

    // optional .TSP.DataReference posterImageData = 15;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.posterimagedata_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .TSP.DataReference audioOnlyImageData = 16;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.audioonlyimagedata_);
    }

    // optional .TSP.Reference style = 19;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.style_);
    }

    // optional .TSP.Size originalSize = 20;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.originalsize_);
    }

    // optional .TSP.Size naturalSize = 21;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.naturalsize_);
    }

    // optional .TSP.DataReference importedAuxiliaryMovieData = 22;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.importedauxiliarymoviedata_);
    }

    // optional .TSD.Attribution attribution = 26;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.attribution_);
    }

    // optional .TSD.MovieFingerprint fingerprint = 29;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fingerprint_);
    }

    // optional float startTime = 3;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional float endTime = 4;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 4;
    }

    // optional float posterTime = 5;
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 4;
    }

    // optional uint32 loopOptionAsInteger = 6 [deprecated = true];
    if (cached_has_bits & 0x00040000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_loopoptionasinteger());
    }

    // optional float volume = 7;
    if (cached_has_bits & 0x00080000u) {
      total_size += 1 + 4;
    }

    // optional uint32 playableState = 12;
    if (cached_has_bits & 0x00100000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_playablestate());
    }

    // optional uint32 flags = 13;
    if (cached_has_bits & 0x00200000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional bool autoPlay = 8 [deprecated = true];
    if (cached_has_bits & 0x00400000u) {
      total_size += 1 + 1;
    }

    // optional bool audioOnly = 9;
    if (cached_has_bits & 0x00800000u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x3f000000u) {
    // optional bool streaming = 18;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 1;
    }

    // optional bool nativeAudioRecording = 27;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional .TSD.MovieArchive.MovieLoopOption loop_option = 24 [default = None];
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_loop_option());
    }

    // optional bool playsAcrossSlides = 28;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional bool poster_image_generated_with_alpha_support = 23;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 1;
    }

    // optional bool is_live_video = 30 [default = false];
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MovieArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MovieArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MovieArchive::GetClassData() const { return &_class_data_; }


void MovieArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MovieArchive*>(&to_msg);
  auto& from = static_cast<const MovieArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.MovieArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_movieremoteurl(from._internal_movieremoteurl());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_imported_auxiliary_movie_data_original_filename(from._internal_imported_auxiliary_movie_data_original_filename());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TSD::DrawableArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_database_moviedata()->::TSP::Reference::MergeFrom(
          from._internal_database_moviedata());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_database_posterimagedata()->::TSP::Reference::MergeFrom(
          from._internal_database_posterimagedata());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_database_audioonlyimagedata()->::TSP::Reference::MergeFrom(
          from._internal_database_audioonlyimagedata());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_moviedata()->::TSP::DataReference::MergeFrom(
          from._internal_moviedata());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_posterimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_posterimagedata());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_audioonlyimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_audioonlyimagedata());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_style()->::TSP::Reference::MergeFrom(
          from._internal_style());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_originalsize()->::TSP::Size::MergeFrom(
          from._internal_originalsize());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_naturalsize()->::TSP::Size::MergeFrom(
          from._internal_naturalsize());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_importedauxiliarymoviedata()->::TSP::DataReference::MergeFrom(
          from._internal_importedauxiliarymoviedata());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_attribution()->::TSD::Attribution::MergeFrom(
          from._internal_attribution());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_fingerprint()->::TSD::MovieFingerprint::MergeFrom(
          from._internal_fingerprint());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.starttime_ = from._impl_.starttime_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.endtime_ = from._impl_.endtime_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.postertime_ = from._impl_.postertime_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.loopoptionasinteger_ = from._impl_.loopoptionasinteger_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.volume_ = from._impl_.volume_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.playablestate_ = from._impl_.playablestate_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.autoplay_ = from._impl_.autoplay_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.audioonly_ = from._impl_.audioonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x3f000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.streaming_ = from._impl_.streaming_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.nativeaudiorecording_ = from._impl_.nativeaudiorecording_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.loop_option_ = from._impl_.loop_option_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.playsacrossslides_ = from._impl_.playsacrossslides_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.poster_image_generated_with_alpha_support_ = from._impl_.poster_image_generated_with_alpha_support_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.is_live_video_ = from._impl_.is_live_video_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MovieArchive::CopyFrom(const MovieArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.MovieArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MovieArchive::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized()) {
    return false;
  }

  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_database_moviedata()) {
    if (!_impl_.database_moviedata_->IsInitialized()) return false;
  }
  if (_internal_has_database_posterimagedata()) {
    if (!_impl_.database_posterimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_database_audioonlyimagedata()) {
    if (!_impl_.database_audioonlyimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_moviedata()) {
    if (!_impl_.moviedata_->IsInitialized()) return false;
  }
  if (_internal_has_posterimagedata()) {
    if (!_impl_.posterimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_audioonlyimagedata()) {
    if (!_impl_.audioonlyimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_style()) {
    if (!_impl_.style_->IsInitialized()) return false;
  }
  if (_internal_has_originalsize()) {
    if (!_impl_.originalsize_->IsInitialized()) return false;
  }
  if (_internal_has_naturalsize()) {
    if (!_impl_.naturalsize_->IsInitialized()) return false;
  }
  if (_internal_has_importedauxiliarymoviedata()) {
    if (!_impl_.importedauxiliarymoviedata_->IsInitialized()) return false;
  }
  if (_internal_has_fingerprint()) {
    if (!_impl_.fingerprint_->IsInitialized()) return false;
  }
  return true;
}

void MovieArchive::InternalSwap(MovieArchive* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.movieremoteurl_, lhs_arena,
      &other->_impl_.movieremoteurl_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.imported_auxiliary_movie_data_original_filename_, lhs_arena,
      &other->_impl_.imported_auxiliary_movie_data_original_filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MovieArchive, _impl_.is_live_video_)
      + sizeof(MovieArchive::_impl_.is_live_video_)
      - PROTOBUF_FIELD_OFFSET(MovieArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MovieArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[45]);
}

// ===================================================================

class ExteriorTextWrapArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ExteriorTextWrapArchive>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fit_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_margin(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_alpha_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_html_wrap(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

ExteriorTextWrapArchive::ExteriorTextWrapArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ExteriorTextWrapArchive)
}
ExteriorTextWrapArchive::ExteriorTextWrapArchive(const ExteriorTextWrapArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExteriorTextWrapArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.direction_){}
    , decltype(_impl_.fit_type_){}
    , decltype(_impl_.margin_){}
    , decltype(_impl_.alpha_threshold_){}
    , decltype(_impl_.is_html_wrap_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_html_wrap_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.is_html_wrap_));
  // @@protoc_insertion_point(copy_constructor:TSD.ExteriorTextWrapArchive)
}

inline void ExteriorTextWrapArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.direction_){0u}
    , decltype(_impl_.fit_type_){0u}
    , decltype(_impl_.margin_){0}
    , decltype(_impl_.alpha_threshold_){0}
    , decltype(_impl_.is_html_wrap_){false}
  };
}

ExteriorTextWrapArchive::~ExteriorTextWrapArchive() {
  // @@protoc_insertion_point(destructor:TSD.ExteriorTextWrapArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExteriorTextWrapArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ExteriorTextWrapArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExteriorTextWrapArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ExteriorTextWrapArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_html_wrap_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.is_html_wrap_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExteriorTextWrapArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_direction(&has_bits);
          _impl_.direction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fit_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_fit_type(&has_bits);
          _impl_.fit_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float margin = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_margin(&has_bits);
          _impl_.margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float alpha_threshold = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_alpha_threshold(&has_bits);
          _impl_.alpha_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_html_wrap = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_html_wrap(&has_bits);
          _impl_.is_html_wrap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExteriorTextWrapArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ExteriorTextWrapArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // optional uint32 direction = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_direction(), target);
  }

  // optional uint32 fit_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_fit_type(), target);
  }

  // optional float margin = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_margin(), target);
  }

  // optional float alpha_threshold = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_alpha_threshold(), target);
  }

  // optional bool is_html_wrap = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_html_wrap(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ExteriorTextWrapArchive)
  return target;
}

size_t ExteriorTextWrapArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ExteriorTextWrapArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint32 type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

    // optional uint32 direction = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_direction());
    }

    // optional uint32 fit_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fit_type());
    }

    // optional float margin = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float alpha_threshold = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional bool is_html_wrap = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExteriorTextWrapArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExteriorTextWrapArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExteriorTextWrapArchive::GetClassData() const { return &_class_data_; }


void ExteriorTextWrapArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExteriorTextWrapArchive*>(&to_msg);
  auto& from = static_cast<const ExteriorTextWrapArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ExteriorTextWrapArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.direction_ = from._impl_.direction_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.fit_type_ = from._impl_.fit_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.margin_ = from._impl_.margin_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.alpha_threshold_ = from._impl_.alpha_threshold_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.is_html_wrap_ = from._impl_.is_html_wrap_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExteriorTextWrapArchive::CopyFrom(const ExteriorTextWrapArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ExteriorTextWrapArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExteriorTextWrapArchive::IsInitialized() const {
  return true;
}

void ExteriorTextWrapArchive::InternalSwap(ExteriorTextWrapArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExteriorTextWrapArchive, _impl_.is_html_wrap_)
      + sizeof(ExteriorTextWrapArchive::_impl_.is_html_wrap_)
      - PROTOBUF_FIELD_OFFSET(ExteriorTextWrapArchive, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExteriorTextWrapArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[46]);
}

// ===================================================================

class DrawableContentDescription::_Internal {
 public:
  using HasBits = decltype(std::declval<DrawableContentDescription>()._impl_._has_bits_);
  static void set_has_element_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_anchored_to_text(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_floating_above_text(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_inline_with_text(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

DrawableContentDescription::DrawableContentDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.DrawableContentDescription)
}
DrawableContentDescription::DrawableContentDescription(const DrawableContentDescription& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DrawableContentDescription* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.element_kind_){}
    , decltype(_impl_.is_anchored_to_text_){}
    , decltype(_impl_.is_floating_above_text_){}
    , decltype(_impl_.is_inline_with_text_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.element_kind_, &from._impl_.element_kind_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_inline_with_text_) -
    reinterpret_cast<char*>(&_impl_.element_kind_)) + sizeof(_impl_.is_inline_with_text_));
  // @@protoc_insertion_point(copy_constructor:TSD.DrawableContentDescription)
}

inline void DrawableContentDescription::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.element_kind_){0u}
    , decltype(_impl_.is_anchored_to_text_){false}
    , decltype(_impl_.is_floating_above_text_){false}
    , decltype(_impl_.is_inline_with_text_){false}
  };
}

DrawableContentDescription::~DrawableContentDescription() {
  // @@protoc_insertion_point(destructor:TSD.DrawableContentDescription)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DrawableContentDescription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DrawableContentDescription::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DrawableContentDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.DrawableContentDescription)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.element_kind_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_inline_with_text_) -
        reinterpret_cast<char*>(&_impl_.element_kind_)) + sizeof(_impl_.is_inline_with_text_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DrawableContentDescription::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 element_kind = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_element_kind(&has_bits);
          _impl_.element_kind_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_anchored_to_text = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_anchored_to_text(&has_bits);
          _impl_.is_anchored_to_text_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_floating_above_text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_floating_above_text(&has_bits);
          _impl_.is_floating_above_text_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_inline_with_text = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_inline_with_text(&has_bits);
          _impl_.is_inline_with_text_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DrawableContentDescription::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.DrawableContentDescription)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 element_kind = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_element_kind(), target);
  }

  // optional bool is_anchored_to_text = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_anchored_to_text(), target);
  }

  // optional bool is_floating_above_text = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_floating_above_text(), target);
  }

  // optional bool is_inline_with_text = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_inline_with_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.DrawableContentDescription)
  return target;
}

size_t DrawableContentDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.DrawableContentDescription)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 element_kind = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_element_kind());
    }

    // optional bool is_anchored_to_text = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool is_floating_above_text = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool is_inline_with_text = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DrawableContentDescription::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DrawableContentDescription::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DrawableContentDescription::GetClassData() const { return &_class_data_; }


void DrawableContentDescription::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DrawableContentDescription*>(&to_msg);
  auto& from = static_cast<const DrawableContentDescription&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.DrawableContentDescription)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.element_kind_ = from._impl_.element_kind_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_anchored_to_text_ = from._impl_.is_anchored_to_text_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_floating_above_text_ = from._impl_.is_floating_above_text_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_inline_with_text_ = from._impl_.is_inline_with_text_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DrawableContentDescription::CopyFrom(const DrawableContentDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.DrawableContentDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawableContentDescription::IsInitialized() const {
  return true;
}

void DrawableContentDescription::InternalSwap(DrawableContentDescription* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DrawableContentDescription, _impl_.is_inline_with_text_)
      + sizeof(DrawableContentDescription::_impl_.is_inline_with_text_)
      - PROTOBUF_FIELD_OFFSET(DrawableContentDescription, _impl_.element_kind_)>(
          reinterpret_cast<char*>(&_impl_.element_kind_),
          reinterpret_cast<char*>(&other->_impl_.element_kind_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DrawableContentDescription::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[47]);
}

// ===================================================================

class FreehandDrawingContentDescription::_Internal {
 public:
  using HasBits = decltype(std::declval<FreehandDrawingContentDescription>()._impl_._has_bits_);
  static const ::TSD::DrawableContentDescription& super(const FreehandDrawingContentDescription* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_source_doc_wanted_spacer_shape(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::DrawableContentDescription&
FreehandDrawingContentDescription::_Internal::super(const FreehandDrawingContentDescription* msg) {
  return *msg->_impl_.super_;
}
FreehandDrawingContentDescription::FreehandDrawingContentDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.FreehandDrawingContentDescription)
}
FreehandDrawingContentDescription::FreehandDrawingContentDescription(const FreehandDrawingContentDescription& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FreehandDrawingContentDescription* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.source_doc_wanted_spacer_shape_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::DrawableContentDescription(*from._impl_.super_);
  }
  _this->_impl_.source_doc_wanted_spacer_shape_ = from._impl_.source_doc_wanted_spacer_shape_;
  // @@protoc_insertion_point(copy_constructor:TSD.FreehandDrawingContentDescription)
}

inline void FreehandDrawingContentDescription::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.source_doc_wanted_spacer_shape_){false}
  };
}

FreehandDrawingContentDescription::~FreehandDrawingContentDescription() {
  // @@protoc_insertion_point(destructor:TSD.FreehandDrawingContentDescription)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FreehandDrawingContentDescription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void FreehandDrawingContentDescription::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FreehandDrawingContentDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.FreehandDrawingContentDescription)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.source_doc_wanted_spacer_shape_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FreehandDrawingContentDescription::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.DrawableContentDescription super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool source_doc_wanted_spacer_shape = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_source_doc_wanted_spacer_shape(&has_bits);
          _impl_.source_doc_wanted_spacer_shape_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FreehandDrawingContentDescription::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.FreehandDrawingContentDescription)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.DrawableContentDescription super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional bool source_doc_wanted_spacer_shape = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_source_doc_wanted_spacer_shape(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.FreehandDrawingContentDescription)
  return target;
}

size_t FreehandDrawingContentDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.FreehandDrawingContentDescription)
  size_t total_size = 0;

  // required .TSD.DrawableContentDescription super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool source_doc_wanted_spacer_shape = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FreehandDrawingContentDescription::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FreehandDrawingContentDescription::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FreehandDrawingContentDescription::GetClassData() const { return &_class_data_; }


void FreehandDrawingContentDescription::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FreehandDrawingContentDescription*>(&to_msg);
  auto& from = static_cast<const FreehandDrawingContentDescription&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.FreehandDrawingContentDescription)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::DrawableContentDescription::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.source_doc_wanted_spacer_shape_ = from._impl_.source_doc_wanted_spacer_shape_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FreehandDrawingContentDescription::CopyFrom(const FreehandDrawingContentDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.FreehandDrawingContentDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FreehandDrawingContentDescription::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void FreehandDrawingContentDescription::InternalSwap(FreehandDrawingContentDescription* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FreehandDrawingContentDescription, _impl_.source_doc_wanted_spacer_shape_)
      + sizeof(FreehandDrawingContentDescription::_impl_.source_doc_wanted_spacer_shape_)
      - PROTOBUF_FIELD_OFFSET(FreehandDrawingContentDescription, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FreehandDrawingContentDescription::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[48]);
}

// ===================================================================

class FreehandDrawingToolkitUIState::_Internal {
 public:
  using HasBits = decltype(std::declval<FreehandDrawingToolkitUIState>()._impl_._has_bits_);
  static const ::TSP::Color& current_color(const FreehandDrawingToolkitUIState* msg);
  static void set_has_current_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_most_recent_restorable_tool_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_pen_tool_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pen_tool_unscaled_width(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_pencil_tool_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pencil_tool_unscaled_width(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_crayon_tool_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_crayon_tool_unscaled_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_fill_tool_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_eraser_tool_scaled_width(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_eraser_tool_erases_whole_objects(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::TSP::Color& pen_tool_color(const FreehandDrawingToolkitUIState* msg);
  static void set_has_pen_tool_color(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Color& pencil_tool_color(const FreehandDrawingToolkitUIState* msg);
  static void set_has_pencil_tool_color(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Color& crayon_tool_color(const FreehandDrawingToolkitUIState* msg);
  static void set_has_crayon_tool_color(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Color& fill_tool_color(const FreehandDrawingToolkitUIState* msg);
  static void set_has_fill_tool_color(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::TSP::Color&
FreehandDrawingToolkitUIState::_Internal::current_color(const FreehandDrawingToolkitUIState* msg) {
  return *msg->_impl_.current_color_;
}
const ::TSP::Color&
FreehandDrawingToolkitUIState::_Internal::pen_tool_color(const FreehandDrawingToolkitUIState* msg) {
  return *msg->_impl_.pen_tool_color_;
}
const ::TSP::Color&
FreehandDrawingToolkitUIState::_Internal::pencil_tool_color(const FreehandDrawingToolkitUIState* msg) {
  return *msg->_impl_.pencil_tool_color_;
}
const ::TSP::Color&
FreehandDrawingToolkitUIState::_Internal::crayon_tool_color(const FreehandDrawingToolkitUIState* msg) {
  return *msg->_impl_.crayon_tool_color_;
}
const ::TSP::Color&
FreehandDrawingToolkitUIState::_Internal::fill_tool_color(const FreehandDrawingToolkitUIState* msg) {
  return *msg->_impl_.fill_tool_color_;
}
void FreehandDrawingToolkitUIState::clear_current_color() {
  if (_impl_.current_color_ != nullptr) _impl_.current_color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void FreehandDrawingToolkitUIState::clear_pen_tool_color() {
  if (_impl_.pen_tool_color_ != nullptr) _impl_.pen_tool_color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void FreehandDrawingToolkitUIState::clear_pencil_tool_color() {
  if (_impl_.pencil_tool_color_ != nullptr) _impl_.pencil_tool_color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void FreehandDrawingToolkitUIState::clear_crayon_tool_color() {
  if (_impl_.crayon_tool_color_ != nullptr) _impl_.crayon_tool_color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void FreehandDrawingToolkitUIState::clear_fill_tool_color() {
  if (_impl_.fill_tool_color_ != nullptr) _impl_.fill_tool_color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
FreehandDrawingToolkitUIState::FreehandDrawingToolkitUIState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.FreehandDrawingToolkitUIState)
}
FreehandDrawingToolkitUIState::FreehandDrawingToolkitUIState(const FreehandDrawingToolkitUIState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FreehandDrawingToolkitUIState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.current_color_){nullptr}
    , decltype(_impl_.pen_tool_color_){nullptr}
    , decltype(_impl_.pencil_tool_color_){nullptr}
    , decltype(_impl_.crayon_tool_color_){nullptr}
    , decltype(_impl_.fill_tool_color_){nullptr}
    , decltype(_impl_.most_recent_restorable_tool_type_){}
    , decltype(_impl_.pen_tool_opacity_){}
    , decltype(_impl_.pen_tool_unscaled_width_){}
    , decltype(_impl_.pencil_tool_opacity_){}
    , decltype(_impl_.pencil_tool_unscaled_width_){}
    , decltype(_impl_.crayon_tool_opacity_){}
    , decltype(_impl_.crayon_tool_unscaled_width_){}
    , decltype(_impl_.fill_tool_opacity_){}
    , decltype(_impl_.eraser_tool_scaled_width_){}
    , decltype(_impl_.eraser_tool_erases_whole_objects_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_current_color()) {
    _this->_impl_.current_color_ = new ::TSP::Color(*from._impl_.current_color_);
  }
  if (from._internal_has_pen_tool_color()) {
    _this->_impl_.pen_tool_color_ = new ::TSP::Color(*from._impl_.pen_tool_color_);
  }
  if (from._internal_has_pencil_tool_color()) {
    _this->_impl_.pencil_tool_color_ = new ::TSP::Color(*from._impl_.pencil_tool_color_);
  }
  if (from._internal_has_crayon_tool_color()) {
    _this->_impl_.crayon_tool_color_ = new ::TSP::Color(*from._impl_.crayon_tool_color_);
  }
  if (from._internal_has_fill_tool_color()) {
    _this->_impl_.fill_tool_color_ = new ::TSP::Color(*from._impl_.fill_tool_color_);
  }
  ::memcpy(&_impl_.most_recent_restorable_tool_type_, &from._impl_.most_recent_restorable_tool_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.eraser_tool_erases_whole_objects_) -
    reinterpret_cast<char*>(&_impl_.most_recent_restorable_tool_type_)) + sizeof(_impl_.eraser_tool_erases_whole_objects_));
  // @@protoc_insertion_point(copy_constructor:TSD.FreehandDrawingToolkitUIState)
}

inline void FreehandDrawingToolkitUIState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.current_color_){nullptr}
    , decltype(_impl_.pen_tool_color_){nullptr}
    , decltype(_impl_.pencil_tool_color_){nullptr}
    , decltype(_impl_.crayon_tool_color_){nullptr}
    , decltype(_impl_.fill_tool_color_){nullptr}
    , decltype(_impl_.most_recent_restorable_tool_type_){0}
    , decltype(_impl_.pen_tool_opacity_){0}
    , decltype(_impl_.pen_tool_unscaled_width_){0}
    , decltype(_impl_.pencil_tool_opacity_){0}
    , decltype(_impl_.pencil_tool_unscaled_width_){0}
    , decltype(_impl_.crayon_tool_opacity_){0}
    , decltype(_impl_.crayon_tool_unscaled_width_){0}
    , decltype(_impl_.fill_tool_opacity_){0}
    , decltype(_impl_.eraser_tool_scaled_width_){0}
    , decltype(_impl_.eraser_tool_erases_whole_objects_){false}
  };
}

FreehandDrawingToolkitUIState::~FreehandDrawingToolkitUIState() {
  // @@protoc_insertion_point(destructor:TSD.FreehandDrawingToolkitUIState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FreehandDrawingToolkitUIState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.current_color_;
  if (this != internal_default_instance()) delete _impl_.pen_tool_color_;
  if (this != internal_default_instance()) delete _impl_.pencil_tool_color_;
  if (this != internal_default_instance()) delete _impl_.crayon_tool_color_;
  if (this != internal_default_instance()) delete _impl_.fill_tool_color_;
}

void FreehandDrawingToolkitUIState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FreehandDrawingToolkitUIState::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.FreehandDrawingToolkitUIState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.current_color_ != nullptr);
      _impl_.current_color_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.pen_tool_color_ != nullptr);
      _impl_.pen_tool_color_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.pencil_tool_color_ != nullptr);
      _impl_.pencil_tool_color_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.crayon_tool_color_ != nullptr);
      _impl_.crayon_tool_color_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.fill_tool_color_ != nullptr);
      _impl_.fill_tool_color_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.most_recent_restorable_tool_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pen_tool_unscaled_width_) -
        reinterpret_cast<char*>(&_impl_.most_recent_restorable_tool_type_)) + sizeof(_impl_.pen_tool_unscaled_width_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.pencil_tool_opacity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.eraser_tool_erases_whole_objects_) -
        reinterpret_cast<char*>(&_impl_.pencil_tool_opacity_)) + sizeof(_impl_.eraser_tool_erases_whole_objects_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FreehandDrawingToolkitUIState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Color current_color = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_current_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.FreehandDrawingToolkitUIState.FreehandDrawingToolType most_recent_restorable_tool_type = 2 [default = Pen];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::FreehandDrawingToolkitUIState_FreehandDrawingToolType_IsValid(val))) {
            _internal_set_most_recent_restorable_tool_type(static_cast<::TSD::FreehandDrawingToolkitUIState_FreehandDrawingToolType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float pen_tool_opacity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_pen_tool_opacity(&has_bits);
          _impl_.pen_tool_opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float pen_tool_unscaled_width = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_pen_tool_unscaled_width(&has_bits);
          _impl_.pen_tool_unscaled_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float pencil_tool_opacity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_pencil_tool_opacity(&has_bits);
          _impl_.pencil_tool_opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float pencil_tool_unscaled_width = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_pencil_tool_unscaled_width(&has_bits);
          _impl_.pencil_tool_unscaled_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float crayon_tool_opacity = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_crayon_tool_opacity(&has_bits);
          _impl_.crayon_tool_opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float crayon_tool_unscaled_width = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_crayon_tool_unscaled_width(&has_bits);
          _impl_.crayon_tool_unscaled_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float fill_tool_opacity = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_fill_tool_opacity(&has_bits);
          _impl_.fill_tool_opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float eraser_tool_scaled_width = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_eraser_tool_scaled_width(&has_bits);
          _impl_.eraser_tool_scaled_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool eraser_tool_erases_whole_objects = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_eraser_tool_erases_whole_objects(&has_bits);
          _impl_.eraser_tool_erases_whole_objects_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Color pen_tool_color = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_pen_tool_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Color pencil_tool_color = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_pencil_tool_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Color crayon_tool_color = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_crayon_tool_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Color fill_tool_color = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_fill_tool_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FreehandDrawingToolkitUIState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.FreehandDrawingToolkitUIState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Color current_color = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::current_color(this),
        _Internal::current_color(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.FreehandDrawingToolkitUIState.FreehandDrawingToolType most_recent_restorable_tool_type = 2 [default = Pen];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_most_recent_restorable_tool_type(), target);
  }

  // optional float pen_tool_opacity = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_pen_tool_opacity(), target);
  }

  // optional float pen_tool_unscaled_width = 4;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_pen_tool_unscaled_width(), target);
  }

  // optional float pencil_tool_opacity = 5;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_pencil_tool_opacity(), target);
  }

  // optional float pencil_tool_unscaled_width = 6;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_pencil_tool_unscaled_width(), target);
  }

  // optional float crayon_tool_opacity = 7;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_crayon_tool_opacity(), target);
  }

  // optional float crayon_tool_unscaled_width = 8;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_crayon_tool_unscaled_width(), target);
  }

  // optional float fill_tool_opacity = 9;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_fill_tool_opacity(), target);
  }

  // optional float eraser_tool_scaled_width = 10;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_eraser_tool_scaled_width(), target);
  }

  // optional bool eraser_tool_erases_whole_objects = 11;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_eraser_tool_erases_whole_objects(), target);
  }

  // optional .TSP.Color pen_tool_color = 12;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::pen_tool_color(this),
        _Internal::pen_tool_color(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Color pencil_tool_color = 13;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::pencil_tool_color(this),
        _Internal::pencil_tool_color(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Color crayon_tool_color = 14;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::crayon_tool_color(this),
        _Internal::crayon_tool_color(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Color fill_tool_color = 15;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::fill_tool_color(this),
        _Internal::fill_tool_color(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.FreehandDrawingToolkitUIState)
  return target;
}

size_t FreehandDrawingToolkitUIState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.FreehandDrawingToolkitUIState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSP.Color current_color = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.current_color_);
    }

    // optional .TSP.Color pen_tool_color = 12;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pen_tool_color_);
    }

    // optional .TSP.Color pencil_tool_color = 13;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pencil_tool_color_);
    }

    // optional .TSP.Color crayon_tool_color = 14;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.crayon_tool_color_);
    }

    // optional .TSP.Color fill_tool_color = 15;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fill_tool_color_);
    }

    // optional .TSD.FreehandDrawingToolkitUIState.FreehandDrawingToolType most_recent_restorable_tool_type = 2 [default = Pen];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_most_recent_restorable_tool_type());
    }

    // optional float pen_tool_opacity = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float pen_tool_unscaled_width = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional float pencil_tool_opacity = 5;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float pencil_tool_unscaled_width = 6;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float crayon_tool_opacity = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional float crayon_tool_unscaled_width = 8;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional float fill_tool_opacity = 9;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional float eraser_tool_scaled_width = 10;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

    // optional bool eraser_tool_erases_whole_objects = 11;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FreehandDrawingToolkitUIState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FreehandDrawingToolkitUIState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FreehandDrawingToolkitUIState::GetClassData() const { return &_class_data_; }


void FreehandDrawingToolkitUIState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FreehandDrawingToolkitUIState*>(&to_msg);
  auto& from = static_cast<const FreehandDrawingToolkitUIState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.FreehandDrawingToolkitUIState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_current_color()->::TSP::Color::MergeFrom(
          from._internal_current_color());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_pen_tool_color()->::TSP::Color::MergeFrom(
          from._internal_pen_tool_color());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_pencil_tool_color()->::TSP::Color::MergeFrom(
          from._internal_pencil_tool_color());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_crayon_tool_color()->::TSP::Color::MergeFrom(
          from._internal_crayon_tool_color());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_fill_tool_color()->::TSP::Color::MergeFrom(
          from._internal_fill_tool_color());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.most_recent_restorable_tool_type_ = from._impl_.most_recent_restorable_tool_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.pen_tool_opacity_ = from._impl_.pen_tool_opacity_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.pen_tool_unscaled_width_ = from._impl_.pen_tool_unscaled_width_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.pencil_tool_opacity_ = from._impl_.pencil_tool_opacity_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.pencil_tool_unscaled_width_ = from._impl_.pencil_tool_unscaled_width_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.crayon_tool_opacity_ = from._impl_.crayon_tool_opacity_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.crayon_tool_unscaled_width_ = from._impl_.crayon_tool_unscaled_width_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.fill_tool_opacity_ = from._impl_.fill_tool_opacity_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.eraser_tool_scaled_width_ = from._impl_.eraser_tool_scaled_width_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.eraser_tool_erases_whole_objects_ = from._impl_.eraser_tool_erases_whole_objects_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FreehandDrawingToolkitUIState::CopyFrom(const FreehandDrawingToolkitUIState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.FreehandDrawingToolkitUIState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FreehandDrawingToolkitUIState::IsInitialized() const {
  if (_internal_has_current_color()) {
    if (!_impl_.current_color_->IsInitialized()) return false;
  }
  if (_internal_has_pen_tool_color()) {
    if (!_impl_.pen_tool_color_->IsInitialized()) return false;
  }
  if (_internal_has_pencil_tool_color()) {
    if (!_impl_.pencil_tool_color_->IsInitialized()) return false;
  }
  if (_internal_has_crayon_tool_color()) {
    if (!_impl_.crayon_tool_color_->IsInitialized()) return false;
  }
  if (_internal_has_fill_tool_color()) {
    if (!_impl_.fill_tool_color_->IsInitialized()) return false;
  }
  return true;
}

void FreehandDrawingToolkitUIState::InternalSwap(FreehandDrawingToolkitUIState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FreehandDrawingToolkitUIState, _impl_.eraser_tool_erases_whole_objects_)
      + sizeof(FreehandDrawingToolkitUIState::_impl_.eraser_tool_erases_whole_objects_)
      - PROTOBUF_FIELD_OFFSET(FreehandDrawingToolkitUIState, _impl_.current_color_)>(
          reinterpret_cast<char*>(&_impl_.current_color_),
          reinterpret_cast<char*>(&other->_impl_.current_color_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FreehandDrawingToolkitUIState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[49]);
}

// ===================================================================

class StandinCaptionArchive::_Internal {
 public:
};

StandinCaptionArchive::StandinCaptionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:TSD.StandinCaptionArchive)
}
StandinCaptionArchive::StandinCaptionArchive(const StandinCaptionArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  StandinCaptionArchive* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSD.StandinCaptionArchive)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StandinCaptionArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StandinCaptionArchive::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata StandinCaptionArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[50]);
}

// ===================================================================

class GuideArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<GuideArchive>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dynamic(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_infinite(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

GuideArchive::GuideArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.GuideArchive)
}
GuideArchive::GuideArchive(const GuideArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GuideArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.offset_){}
    , decltype(_impl_.start_){}
    , decltype(_impl_.end_){}
    , decltype(_impl_.dynamic_){}
    , decltype(_impl_.infinite_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.infinite_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.infinite_));
  // @@protoc_insertion_point(copy_constructor:TSD.GuideArchive)
}

inline void GuideArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.offset_){0}
    , decltype(_impl_.start_){0}
    , decltype(_impl_.end_){0}
    , decltype(_impl_.dynamic_){false}
    , decltype(_impl_.infinite_){false}
  };
}

GuideArchive::~GuideArchive() {
  // @@protoc_insertion_point(destructor:TSD.GuideArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GuideArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GuideArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GuideArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.GuideArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.infinite_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.infinite_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GuideArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.GuideArchive.GuideType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::GuideArchive_GuideType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::GuideArchive_GuideType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_start(&has_bits);
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float end = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_end(&has_bits);
          _impl_.end_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool dynamic = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_dynamic(&has_bits);
          _impl_.dynamic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool infinite = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_infinite(&has_bits);
          _impl_.infinite_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GuideArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.GuideArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.GuideArchive.GuideType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional float offset = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_offset(), target);
  }

  // optional float start = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_start(), target);
  }

  // optional float end = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_end(), target);
  }

  // optional bool dynamic = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_dynamic(), target);
  }

  // optional bool infinite = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_infinite(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.GuideArchive)
  return target;
}

size_t GuideArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.GuideArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .TSD.GuideArchive.GuideType type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional float offset = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float start = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float end = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional bool dynamic = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool infinite = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GuideArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GuideArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GuideArchive::GetClassData() const { return &_class_data_; }


void GuideArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GuideArchive*>(&to_msg);
  auto& from = static_cast<const GuideArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.GuideArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.start_ = from._impl_.start_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.end_ = from._impl_.end_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.dynamic_ = from._impl_.dynamic_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.infinite_ = from._impl_.infinite_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GuideArchive::CopyFrom(const GuideArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.GuideArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GuideArchive::IsInitialized() const {
  return true;
}

void GuideArchive::InternalSwap(GuideArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GuideArchive, _impl_.infinite_)
      + sizeof(GuideArchive::_impl_.infinite_)
      - PROTOBUF_FIELD_OFFSET(GuideArchive, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GuideArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[51]);
}

// ===================================================================

class UserDefinedGuideArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<UserDefinedGuideArchive>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UserDefinedGuideArchive::UserDefinedGuideArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.UserDefinedGuideArchive)
}
UserDefinedGuideArchive::UserDefinedGuideArchive(const UserDefinedGuideArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UserDefinedGuideArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.position_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.position_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.position_));
  // @@protoc_insertion_point(copy_constructor:TSD.UserDefinedGuideArchive)
}

inline void UserDefinedGuideArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.position_){0}
  };
}

UserDefinedGuideArchive::~UserDefinedGuideArchive() {
  // @@protoc_insertion_point(destructor:TSD.UserDefinedGuideArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserDefinedGuideArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserDefinedGuideArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserDefinedGuideArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.UserDefinedGuideArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.position_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.position_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserDefinedGuideArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.UserDefinedGuideArchive.GuideType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::UserDefinedGuideArchive_GuideType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::UserDefinedGuideArchive_GuideType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_position(&has_bits);
          _impl_.position_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserDefinedGuideArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.UserDefinedGuideArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.UserDefinedGuideArchive.GuideType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional float position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_position(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.UserDefinedGuideArchive)
  return target;
}

size_t UserDefinedGuideArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.UserDefinedGuideArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSD.UserDefinedGuideArchive.GuideType type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional float position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserDefinedGuideArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UserDefinedGuideArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserDefinedGuideArchive::GetClassData() const { return &_class_data_; }


void UserDefinedGuideArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UserDefinedGuideArchive*>(&to_msg);
  auto& from = static_cast<const UserDefinedGuideArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.UserDefinedGuideArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.position_ = from._impl_.position_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserDefinedGuideArchive::CopyFrom(const UserDefinedGuideArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.UserDefinedGuideArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserDefinedGuideArchive::IsInitialized() const {
  return true;
}

void UserDefinedGuideArchive::InternalSwap(UserDefinedGuideArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserDefinedGuideArchive, _impl_.position_)
      + sizeof(UserDefinedGuideArchive::_impl_.position_)
      - PROTOBUF_FIELD_OFFSET(UserDefinedGuideArchive, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UserDefinedGuideArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[52]);
}

// ===================================================================

class GuideStorageArchive::_Internal {
 public:
};

GuideStorageArchive::GuideStorageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.GuideStorageArchive)
}
GuideStorageArchive::GuideStorageArchive(const GuideStorageArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GuideStorageArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.userdefinedguides_){from._impl_.userdefinedguides_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSD.GuideStorageArchive)
}

inline void GuideStorageArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.userdefinedguides_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GuideStorageArchive::~GuideStorageArchive() {
  // @@protoc_insertion_point(destructor:TSD.GuideStorageArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GuideStorageArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userdefinedguides_.~RepeatedPtrField();
}

void GuideStorageArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GuideStorageArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.GuideStorageArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.userdefinedguides_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GuideStorageArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSD.UserDefinedGuideArchive userDefinedGuides = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_userdefinedguides(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GuideStorageArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.GuideStorageArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSD.UserDefinedGuideArchive userDefinedGuides = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_userdefinedguides_size()); i < n; i++) {
    const auto& repfield = this->_internal_userdefinedguides(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.GuideStorageArchive)
  return target;
}

size_t GuideStorageArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.GuideStorageArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSD.UserDefinedGuideArchive userDefinedGuides = 1;
  total_size += 1UL * this->_internal_userdefinedguides_size();
  for (const auto& msg : this->_impl_.userdefinedguides_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GuideStorageArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GuideStorageArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GuideStorageArchive::GetClassData() const { return &_class_data_; }


void GuideStorageArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GuideStorageArchive*>(&to_msg);
  auto& from = static_cast<const GuideStorageArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.GuideStorageArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.userdefinedguides_.MergeFrom(from._impl_.userdefinedguides_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GuideStorageArchive::CopyFrom(const GuideStorageArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.GuideStorageArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GuideStorageArchive::IsInitialized() const {
  return true;
}

void GuideStorageArchive::InternalSwap(GuideStorageArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.userdefinedguides_.InternalSwap(&other->_impl_.userdefinedguides_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GuideStorageArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[53]);
}

// ===================================================================

class CanvasSelectionArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CanvasSelectionArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& container(const CanvasSelectionArchive* msg);
  static void set_has_container(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::Reference&
CanvasSelectionArchive::_Internal::container(const CanvasSelectionArchive* msg) {
  return *msg->_impl_.container_;
}
void CanvasSelectionArchive::clear_infos() {
  _impl_.infos_.Clear();
}
void CanvasSelectionArchive::clear_non_interactive_infos() {
  _impl_.non_interactive_infos_.Clear();
}
void CanvasSelectionArchive::clear_container() {
  if (_impl_.container_ != nullptr) _impl_.container_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CanvasSelectionArchive::CanvasSelectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.CanvasSelectionArchive)
}
CanvasSelectionArchive::CanvasSelectionArchive(const CanvasSelectionArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CanvasSelectionArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.infos_){from._impl_.infos_}
    , decltype(_impl_.non_interactive_infos_){from._impl_.non_interactive_infos_}
    , decltype(_impl_.container_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_container()) {
    _this->_impl_.container_ = new ::TSP::Reference(*from._impl_.container_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.CanvasSelectionArchive)
}

inline void CanvasSelectionArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.infos_){arena}
    , decltype(_impl_.non_interactive_infos_){arena}
    , decltype(_impl_.container_){nullptr}
  };
}

CanvasSelectionArchive::~CanvasSelectionArchive() {
  // @@protoc_insertion_point(destructor:TSD.CanvasSelectionArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CanvasSelectionArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.infos_.~RepeatedPtrField();
  _impl_.non_interactive_infos_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.container_;
}

void CanvasSelectionArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CanvasSelectionArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.CanvasSelectionArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.infos_.Clear();
  _impl_.non_interactive_infos_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.container_ != nullptr);
    _impl_.container_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CanvasSelectionArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSP.Reference infos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference container = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_container(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference non_interactive_infos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_non_interactive_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CanvasSelectionArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.CanvasSelectionArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSP.Reference infos = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference container = 2 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::container(this),
        _Internal::container(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference non_interactive_infos = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_non_interactive_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_non_interactive_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.CanvasSelectionArchive)
  return target;
}

size_t CanvasSelectionArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.CanvasSelectionArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference infos = 1;
  total_size += 1UL * this->_internal_infos_size();
  for (const auto& msg : this->_impl_.infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference non_interactive_infos = 3;
  total_size += 1UL * this->_internal_non_interactive_infos_size();
  for (const auto& msg : this->_impl_.non_interactive_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TSP.Reference container = 2 [deprecated = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.container_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CanvasSelectionArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CanvasSelectionArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CanvasSelectionArchive::GetClassData() const { return &_class_data_; }


void CanvasSelectionArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CanvasSelectionArchive*>(&to_msg);
  auto& from = static_cast<const CanvasSelectionArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.CanvasSelectionArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.infos_.MergeFrom(from._impl_.infos_);
  _this->_impl_.non_interactive_infos_.MergeFrom(from._impl_.non_interactive_infos_);
  if (from._internal_has_container()) {
    _this->_internal_mutable_container()->::TSP::Reference::MergeFrom(
        from._internal_container());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CanvasSelectionArchive::CopyFrom(const CanvasSelectionArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.CanvasSelectionArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CanvasSelectionArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.infos_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.non_interactive_infos_))
    return false;
  if (_internal_has_container()) {
    if (!_impl_.container_->IsInitialized()) return false;
  }
  return true;
}

void CanvasSelectionArchive::InternalSwap(CanvasSelectionArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.infos_.InternalSwap(&other->_impl_.infos_);
  _impl_.non_interactive_infos_.InternalSwap(&other->_impl_.non_interactive_infos_);
  swap(_impl_.container_, other->_impl_.container_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CanvasSelectionArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[54]);
}

// ===================================================================

class DrawableSelectionArchive::_Internal {
 public:
};

void DrawableSelectionArchive::clear_infos() {
  _impl_.infos_.Clear();
}
void DrawableSelectionArchive::clear_non_interactive_infos() {
  _impl_.non_interactive_infos_.Clear();
}
DrawableSelectionArchive::DrawableSelectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.DrawableSelectionArchive)
}
DrawableSelectionArchive::DrawableSelectionArchive(const DrawableSelectionArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DrawableSelectionArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.infos_){from._impl_.infos_}
    , decltype(_impl_.non_interactive_infos_){from._impl_.non_interactive_infos_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSD.DrawableSelectionArchive)
}

inline void DrawableSelectionArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.infos_){arena}
    , decltype(_impl_.non_interactive_infos_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DrawableSelectionArchive::~DrawableSelectionArchive() {
  // @@protoc_insertion_point(destructor:TSD.DrawableSelectionArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DrawableSelectionArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.infos_.~RepeatedPtrField();
  _impl_.non_interactive_infos_.~RepeatedPtrField();
}

void DrawableSelectionArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DrawableSelectionArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.DrawableSelectionArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.infos_.Clear();
  _impl_.non_interactive_infos_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DrawableSelectionArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSP.Reference infos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference non_interactive_infos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_non_interactive_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DrawableSelectionArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.DrawableSelectionArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSP.Reference infos = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference non_interactive_infos = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_non_interactive_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_non_interactive_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.DrawableSelectionArchive)
  return target;
}

size_t DrawableSelectionArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.DrawableSelectionArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference infos = 2;
  total_size += 1UL * this->_internal_infos_size();
  for (const auto& msg : this->_impl_.infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference non_interactive_infos = 3;
  total_size += 1UL * this->_internal_non_interactive_infos_size();
  for (const auto& msg : this->_impl_.non_interactive_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DrawableSelectionArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DrawableSelectionArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DrawableSelectionArchive::GetClassData() const { return &_class_data_; }


void DrawableSelectionArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DrawableSelectionArchive*>(&to_msg);
  auto& from = static_cast<const DrawableSelectionArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.DrawableSelectionArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.infos_.MergeFrom(from._impl_.infos_);
  _this->_impl_.non_interactive_infos_.MergeFrom(from._impl_.non_interactive_infos_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DrawableSelectionArchive::CopyFrom(const DrawableSelectionArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.DrawableSelectionArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawableSelectionArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.infos_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.non_interactive_infos_))
    return false;
  return true;
}

void DrawableSelectionArchive::InternalSwap(DrawableSelectionArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.infos_.InternalSwap(&other->_impl_.infos_);
  _impl_.non_interactive_infos_.InternalSwap(&other->_impl_.non_interactive_infos_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DrawableSelectionArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[55]);
}

// ===================================================================

class GroupSelectionArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupSelectionArchive>()._impl_._has_bits_);
  static const ::TSD::DrawableSelectionArchive& super(const GroupSelectionArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_has_selected_infos_in_non_group_container(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::DrawableSelectionArchive&
GroupSelectionArchive::_Internal::super(const GroupSelectionArchive* msg) {
  return *msg->_impl_.super_;
}
GroupSelectionArchive::GroupSelectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.GroupSelectionArchive)
}
GroupSelectionArchive::GroupSelectionArchive(const GroupSelectionArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GroupSelectionArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.has_selected_infos_in_non_group_container_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::DrawableSelectionArchive(*from._impl_.super_);
  }
  _this->_impl_.has_selected_infos_in_non_group_container_ = from._impl_.has_selected_infos_in_non_group_container_;
  // @@protoc_insertion_point(copy_constructor:TSD.GroupSelectionArchive)
}

inline void GroupSelectionArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.has_selected_infos_in_non_group_container_){false}
  };
}

GroupSelectionArchive::~GroupSelectionArchive() {
  // @@protoc_insertion_point(destructor:TSD.GroupSelectionArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupSelectionArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void GroupSelectionArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupSelectionArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.GroupSelectionArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.has_selected_infos_in_non_group_container_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GroupSelectionArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.DrawableSelectionArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_selected_infos_in_non_group_container = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_has_selected_infos_in_non_group_container(&has_bits);
          _impl_.has_selected_infos_in_non_group_container_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupSelectionArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.GroupSelectionArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.DrawableSelectionArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional bool has_selected_infos_in_non_group_container = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_has_selected_infos_in_non_group_container(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.GroupSelectionArchive)
  return target;
}

size_t GroupSelectionArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.GroupSelectionArchive)
  size_t total_size = 0;

  // required .TSD.DrawableSelectionArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool has_selected_infos_in_non_group_container = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GroupSelectionArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GroupSelectionArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GroupSelectionArchive::GetClassData() const { return &_class_data_; }


void GroupSelectionArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GroupSelectionArchive*>(&to_msg);
  auto& from = static_cast<const GroupSelectionArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.GroupSelectionArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::DrawableSelectionArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.has_selected_infos_in_non_group_container_ = from._impl_.has_selected_infos_in_non_group_container_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GroupSelectionArchive::CopyFrom(const GroupSelectionArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.GroupSelectionArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupSelectionArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void GroupSelectionArchive::InternalSwap(GroupSelectionArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupSelectionArchive, _impl_.has_selected_infos_in_non_group_container_)
      + sizeof(GroupSelectionArchive::_impl_.has_selected_infos_in_non_group_container_)
      - PROTOBUF_FIELD_OFFSET(GroupSelectionArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GroupSelectionArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[56]);
}

// ===================================================================

class PathSelectionArchive::_Internal {
 public:
};

PathSelectionArchive::PathSelectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:TSD.PathSelectionArchive)
}
PathSelectionArchive::PathSelectionArchive(const PathSelectionArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  PathSelectionArchive* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSD.PathSelectionArchive)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PathSelectionArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PathSelectionArchive::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata PathSelectionArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[57]);
}

// ===================================================================

class InfoHyperlinkSelectionArchive::_Internal {
 public:
};

InfoHyperlinkSelectionArchive::InfoHyperlinkSelectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:TSD.InfoHyperlinkSelectionArchive)
}
InfoHyperlinkSelectionArchive::InfoHyperlinkSelectionArchive(const InfoHyperlinkSelectionArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  InfoHyperlinkSelectionArchive* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSD.InfoHyperlinkSelectionArchive)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InfoHyperlinkSelectionArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InfoHyperlinkSelectionArchive::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata InfoHyperlinkSelectionArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[58]);
}

// ===================================================================

class CommentStorageArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommentStorageArchive>()._impl_._has_bits_);
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Date& creation_date(const CommentStorageArchive* msg);
  static void set_has_creation_date(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& author(const CommentStorageArchive* msg);
  static void set_has_author(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::UUID& storage_uuid(const CommentStorageArchive* msg);
  static void set_has_storage_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::TSP::Date&
CommentStorageArchive::_Internal::creation_date(const CommentStorageArchive* msg) {
  return *msg->_impl_.creation_date_;
}
const ::TSP::Reference&
CommentStorageArchive::_Internal::author(const CommentStorageArchive* msg) {
  return *msg->_impl_.author_;
}
const ::TSP::UUID&
CommentStorageArchive::_Internal::storage_uuid(const CommentStorageArchive* msg) {
  return *msg->_impl_.storage_uuid_;
}
void CommentStorageArchive::clear_creation_date() {
  if (_impl_.creation_date_ != nullptr) _impl_.creation_date_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommentStorageArchive::clear_author() {
  if (_impl_.author_ != nullptr) _impl_.author_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommentStorageArchive::clear_replies() {
  _impl_.replies_.Clear();
}
void CommentStorageArchive::clear_storage_uuid() {
  if (_impl_.storage_uuid_ != nullptr) _impl_.storage_uuid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommentStorageArchive::CommentStorageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.CommentStorageArchive)
}
CommentStorageArchive::CommentStorageArchive(const CommentStorageArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommentStorageArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.replies_){from._impl_.replies_}
    , decltype(_impl_.text_){}
    , decltype(_impl_.creation_date_){nullptr}
    , decltype(_impl_.author_){nullptr}
    , decltype(_impl_.storage_uuid_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_creation_date()) {
    _this->_impl_.creation_date_ = new ::TSP::Date(*from._impl_.creation_date_);
  }
  if (from._internal_has_author()) {
    _this->_impl_.author_ = new ::TSP::Reference(*from._impl_.author_);
  }
  if (from._internal_has_storage_uuid()) {
    _this->_impl_.storage_uuid_ = new ::TSP::UUID(*from._impl_.storage_uuid_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.CommentStorageArchive)
}

inline void CommentStorageArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.replies_){arena}
    , decltype(_impl_.text_){}
    , decltype(_impl_.creation_date_){nullptr}
    , decltype(_impl_.author_){nullptr}
    , decltype(_impl_.storage_uuid_){nullptr}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CommentStorageArchive::~CommentStorageArchive() {
  // @@protoc_insertion_point(destructor:TSD.CommentStorageArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommentStorageArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.replies_.~RepeatedPtrField();
  _impl_.text_.Destroy();
  if (this != internal_default_instance()) delete _impl_.creation_date_;
  if (this != internal_default_instance()) delete _impl_.author_;
  if (this != internal_default_instance()) delete _impl_.storage_uuid_;
}

void CommentStorageArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommentStorageArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.CommentStorageArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.replies_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.creation_date_ != nullptr);
      _impl_.creation_date_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.author_ != nullptr);
      _impl_.author_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.storage_uuid_ != nullptr);
      _impl_.storage_uuid_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommentStorageArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.CommentStorageArchive.text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Date creation_date = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_creation_date(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference author = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_author(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference replies = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_replies(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.UUID storage_uuid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage_uuid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommentStorageArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.CommentStorageArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string text = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.CommentStorageArchive.text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_text(), target);
  }

  // optional .TSP.Date creation_date = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::creation_date(this),
        _Internal::creation_date(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference author = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::author(this),
        _Internal::author(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference replies = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_replies_size()); i < n; i++) {
    const auto& repfield = this->_internal_replies(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.UUID storage_uuid = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::storage_uuid(this),
        _Internal::storage_uuid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.CommentStorageArchive)
  return target;
}

size_t CommentStorageArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.CommentStorageArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference replies = 4;
  total_size += 1UL * this->_internal_replies_size();
  for (const auto& msg : this->_impl_.replies_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string text = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
    }

    // optional .TSP.Date creation_date = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.creation_date_);
    }

    // optional .TSP.Reference author = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.author_);
    }

    // optional .TSP.UUID storage_uuid = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_uuid_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommentStorageArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommentStorageArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommentStorageArchive::GetClassData() const { return &_class_data_; }


void CommentStorageArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommentStorageArchive*>(&to_msg);
  auto& from = static_cast<const CommentStorageArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.CommentStorageArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.replies_.MergeFrom(from._impl_.replies_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_text(from._internal_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_creation_date()->::TSP::Date::MergeFrom(
          from._internal_creation_date());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_author()->::TSP::Reference::MergeFrom(
          from._internal_author());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_storage_uuid()->::TSP::UUID::MergeFrom(
          from._internal_storage_uuid());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommentStorageArchive::CopyFrom(const CommentStorageArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.CommentStorageArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommentStorageArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.replies_))
    return false;
  if (_internal_has_creation_date()) {
    if (!_impl_.creation_date_->IsInitialized()) return false;
  }
  if (_internal_has_author()) {
    if (!_impl_.author_->IsInitialized()) return false;
  }
  if (_internal_has_storage_uuid()) {
    if (!_impl_.storage_uuid_->IsInitialized()) return false;
  }
  return true;
}

void CommentStorageArchive::InternalSwap(CommentStorageArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.replies_.InternalSwap(&other->_impl_.replies_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommentStorageArchive, _impl_.storage_uuid_)
      + sizeof(CommentStorageArchive::_impl_.storage_uuid_)
      - PROTOBUF_FIELD_OFFSET(CommentStorageArchive, _impl_.creation_date_)>(
          reinterpret_cast<char*>(&_impl_.creation_date_),
          reinterpret_cast<char*>(&other->_impl_.creation_date_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommentStorageArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[59]);
}

// ===================================================================

class ReplaceAnnotationAuthorCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ReplaceAnnotationAuthorCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ReplaceAnnotationAuthorCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& old_annotation_author(const ReplaceAnnotationAuthorCommandArchive* msg);
  static void set_has_old_annotation_author(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& new_annotation_author(const ReplaceAnnotationAuthorCommandArchive* msg);
  static void set_has_new_annotation_author(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ReplaceAnnotationAuthorCommandArchive::_Internal::super(const ReplaceAnnotationAuthorCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ReplaceAnnotationAuthorCommandArchive::_Internal::old_annotation_author(const ReplaceAnnotationAuthorCommandArchive* msg) {
  return *msg->_impl_.old_annotation_author_;
}
const ::TSP::Reference&
ReplaceAnnotationAuthorCommandArchive::_Internal::new_annotation_author(const ReplaceAnnotationAuthorCommandArchive* msg) {
  return *msg->_impl_.new_annotation_author_;
}
void ReplaceAnnotationAuthorCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ReplaceAnnotationAuthorCommandArchive::clear_old_annotation_author() {
  if (_impl_.old_annotation_author_ != nullptr) _impl_.old_annotation_author_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ReplaceAnnotationAuthorCommandArchive::clear_new_annotation_author() {
  if (_impl_.new_annotation_author_ != nullptr) _impl_.new_annotation_author_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
ReplaceAnnotationAuthorCommandArchive::ReplaceAnnotationAuthorCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ReplaceAnnotationAuthorCommandArchive)
}
ReplaceAnnotationAuthorCommandArchive::ReplaceAnnotationAuthorCommandArchive(const ReplaceAnnotationAuthorCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReplaceAnnotationAuthorCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_annotation_author_){nullptr}
    , decltype(_impl_.new_annotation_author_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_old_annotation_author()) {
    _this->_impl_.old_annotation_author_ = new ::TSP::Reference(*from._impl_.old_annotation_author_);
  }
  if (from._internal_has_new_annotation_author()) {
    _this->_impl_.new_annotation_author_ = new ::TSP::Reference(*from._impl_.new_annotation_author_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ReplaceAnnotationAuthorCommandArchive)
}

inline void ReplaceAnnotationAuthorCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_annotation_author_){nullptr}
    , decltype(_impl_.new_annotation_author_){nullptr}
  };
}

ReplaceAnnotationAuthorCommandArchive::~ReplaceAnnotationAuthorCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.ReplaceAnnotationAuthorCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReplaceAnnotationAuthorCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.old_annotation_author_;
  if (this != internal_default_instance()) delete _impl_.new_annotation_author_;
}

void ReplaceAnnotationAuthorCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReplaceAnnotationAuthorCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ReplaceAnnotationAuthorCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.old_annotation_author_ != nullptr);
      _impl_.old_annotation_author_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.new_annotation_author_ != nullptr);
      _impl_.new_annotation_author_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReplaceAnnotationAuthorCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference old_annotation_author = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_annotation_author(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference new_annotation_author = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_annotation_author(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReplaceAnnotationAuthorCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ReplaceAnnotationAuthorCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference old_annotation_author = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::old_annotation_author(this),
        _Internal::old_annotation_author(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference new_annotation_author = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::new_annotation_author(this),
        _Internal::new_annotation_author(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ReplaceAnnotationAuthorCommandArchive)
  return target;
}

size_t ReplaceAnnotationAuthorCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ReplaceAnnotationAuthorCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSP.Reference old_annotation_author = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.old_annotation_author_);
    }

    // optional .TSP.Reference new_annotation_author = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.new_annotation_author_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReplaceAnnotationAuthorCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReplaceAnnotationAuthorCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReplaceAnnotationAuthorCommandArchive::GetClassData() const { return &_class_data_; }


void ReplaceAnnotationAuthorCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReplaceAnnotationAuthorCommandArchive*>(&to_msg);
  auto& from = static_cast<const ReplaceAnnotationAuthorCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ReplaceAnnotationAuthorCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_old_annotation_author()->::TSP::Reference::MergeFrom(
          from._internal_old_annotation_author());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_new_annotation_author()->::TSP::Reference::MergeFrom(
          from._internal_new_annotation_author());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReplaceAnnotationAuthorCommandArchive::CopyFrom(const ReplaceAnnotationAuthorCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ReplaceAnnotationAuthorCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplaceAnnotationAuthorCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_old_annotation_author()) {
    if (!_impl_.old_annotation_author_->IsInitialized()) return false;
  }
  if (_internal_has_new_annotation_author()) {
    if (!_impl_.new_annotation_author_->IsInitialized()) return false;
  }
  return true;
}

void ReplaceAnnotationAuthorCommandArchive::InternalSwap(ReplaceAnnotationAuthorCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReplaceAnnotationAuthorCommandArchive, _impl_.new_annotation_author_)
      + sizeof(ReplaceAnnotationAuthorCommandArchive::_impl_.new_annotation_author_)
      - PROTOBUF_FIELD_OFFSET(ReplaceAnnotationAuthorCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReplaceAnnotationAuthorCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[60]);
}

// ===================================================================

class PencilAnnotationArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PencilAnnotationArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& pencil_annotation_storage(const PencilAnnotationArchive* msg);
  static void set_has_pencil_annotation_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::Reference&
PencilAnnotationArchive::_Internal::pencil_annotation_storage(const PencilAnnotationArchive* msg) {
  return *msg->_impl_.pencil_annotation_storage_;
}
void PencilAnnotationArchive::clear_pencil_annotation_storage() {
  if (_impl_.pencil_annotation_storage_ != nullptr) _impl_.pencil_annotation_storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PencilAnnotationArchive::PencilAnnotationArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.PencilAnnotationArchive)
}
PencilAnnotationArchive::PencilAnnotationArchive(const PencilAnnotationArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PencilAnnotationArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pencil_annotation_storage_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pencil_annotation_storage()) {
    _this->_impl_.pencil_annotation_storage_ = new ::TSP::Reference(*from._impl_.pencil_annotation_storage_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.PencilAnnotationArchive)
}

inline void PencilAnnotationArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pencil_annotation_storage_){nullptr}
  };
}

PencilAnnotationArchive::~PencilAnnotationArchive() {
  // @@protoc_insertion_point(destructor:TSD.PencilAnnotationArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PencilAnnotationArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pencil_annotation_storage_;
}

void PencilAnnotationArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PencilAnnotationArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.PencilAnnotationArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.pencil_annotation_storage_ != nullptr);
    _impl_.pencil_annotation_storage_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PencilAnnotationArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference pencil_annotation_storage = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pencil_annotation_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PencilAnnotationArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.PencilAnnotationArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference pencil_annotation_storage = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pencil_annotation_storage(this),
        _Internal::pencil_annotation_storage(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.PencilAnnotationArchive)
  return target;
}

size_t PencilAnnotationArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.PencilAnnotationArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Reference pencil_annotation_storage = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pencil_annotation_storage_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PencilAnnotationArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PencilAnnotationArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PencilAnnotationArchive::GetClassData() const { return &_class_data_; }


void PencilAnnotationArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PencilAnnotationArchive*>(&to_msg);
  auto& from = static_cast<const PencilAnnotationArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.PencilAnnotationArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pencil_annotation_storage()) {
    _this->_internal_mutable_pencil_annotation_storage()->::TSP::Reference::MergeFrom(
        from._internal_pencil_annotation_storage());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PencilAnnotationArchive::CopyFrom(const PencilAnnotationArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.PencilAnnotationArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PencilAnnotationArchive::IsInitialized() const {
  if (_internal_has_pencil_annotation_storage()) {
    if (!_impl_.pencil_annotation_storage_->IsInitialized()) return false;
  }
  return true;
}

void PencilAnnotationArchive::InternalSwap(PencilAnnotationArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.pencil_annotation_storage_, other->_impl_.pencil_annotation_storage_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PencilAnnotationArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[61]);
}

// ===================================================================

class PencilAnnotationSelectionArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PencilAnnotationSelectionArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& pencil_annotation(const PencilAnnotationSelectionArchive* msg);
  static void set_has_pencil_annotation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::Reference&
PencilAnnotationSelectionArchive::_Internal::pencil_annotation(const PencilAnnotationSelectionArchive* msg) {
  return *msg->_impl_.pencil_annotation_;
}
void PencilAnnotationSelectionArchive::clear_pencil_annotation() {
  if (_impl_.pencil_annotation_ != nullptr) _impl_.pencil_annotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PencilAnnotationSelectionArchive::PencilAnnotationSelectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.PencilAnnotationSelectionArchive)
}
PencilAnnotationSelectionArchive::PencilAnnotationSelectionArchive(const PencilAnnotationSelectionArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PencilAnnotationSelectionArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pencil_annotation_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pencil_annotation()) {
    _this->_impl_.pencil_annotation_ = new ::TSP::Reference(*from._impl_.pencil_annotation_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.PencilAnnotationSelectionArchive)
}

inline void PencilAnnotationSelectionArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pencil_annotation_){nullptr}
  };
}

PencilAnnotationSelectionArchive::~PencilAnnotationSelectionArchive() {
  // @@protoc_insertion_point(destructor:TSD.PencilAnnotationSelectionArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PencilAnnotationSelectionArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pencil_annotation_;
}

void PencilAnnotationSelectionArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PencilAnnotationSelectionArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.PencilAnnotationSelectionArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.pencil_annotation_ != nullptr);
    _impl_.pencil_annotation_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PencilAnnotationSelectionArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference pencil_annotation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pencil_annotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PencilAnnotationSelectionArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.PencilAnnotationSelectionArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference pencil_annotation = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pencil_annotation(this),
        _Internal::pencil_annotation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.PencilAnnotationSelectionArchive)
  return target;
}

size_t PencilAnnotationSelectionArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.PencilAnnotationSelectionArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Reference pencil_annotation = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pencil_annotation_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PencilAnnotationSelectionArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PencilAnnotationSelectionArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PencilAnnotationSelectionArchive::GetClassData() const { return &_class_data_; }


void PencilAnnotationSelectionArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PencilAnnotationSelectionArchive*>(&to_msg);
  auto& from = static_cast<const PencilAnnotationSelectionArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.PencilAnnotationSelectionArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pencil_annotation()) {
    _this->_internal_mutable_pencil_annotation()->::TSP::Reference::MergeFrom(
        from._internal_pencil_annotation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PencilAnnotationSelectionArchive::CopyFrom(const PencilAnnotationSelectionArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.PencilAnnotationSelectionArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PencilAnnotationSelectionArchive::IsInitialized() const {
  if (_internal_has_pencil_annotation()) {
    if (!_impl_.pencil_annotation_->IsInitialized()) return false;
  }
  return true;
}

void PencilAnnotationSelectionArchive::InternalSwap(PencilAnnotationSelectionArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.pencil_annotation_, other->_impl_.pencil_annotation_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PencilAnnotationSelectionArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[62]);
}

// ===================================================================

class PencilAnnotationStorageArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PencilAnnotationStorageArchive>()._impl_._has_bits_);
  static void set_has_attached_location(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::TSP::Point& markup_offset(const PencilAnnotationStorageArchive* msg);
  static void set_has_markup_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::DataReference& rasterized_image(const PencilAnnotationStorageArchive* msg);
  static void set_has_rasterized_image(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::DataReference& legacy_encoded_drawing(const PencilAnnotationStorageArchive* msg);
  static void set_has_legacy_encoded_drawing(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Path& drawing_path(const PencilAnnotationStorageArchive* msg);
  static void set_has_drawing_path(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Point& strokes_bounding_box_origin(const PencilAnnotationStorageArchive* msg);
  static void set_has_strokes_bounding_box_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Size& strokes_bounding_box_size(const PencilAnnotationStorageArchive* msg);
  static void set_has_strokes_bounding_box_size(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_attached_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::TSP::Size& original_attached_size(const PencilAnnotationStorageArchive* msg);
  static void set_has_original_attached_size(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_percent_of_pa_contained_in_parent_rep(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_text_baselines_touched_count(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_visible_strokes_count(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::TSP::Color& pen_color(const PencilAnnotationStorageArchive* msg);
  static void set_has_pen_color(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_tool_type(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::TSP::Date& creation_date(const PencilAnnotationStorageArchive* msg);
  static void set_has_creation_date(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pencil_annotation_drawing_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_compound_annotation_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::TSP::DataReference& encoded_drawing(const PencilAnnotationStorageArchive* msg);
  static void set_has_encoded_drawing(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::TSP::Point& stroke_points_frame_origin(const PencilAnnotationStorageArchive* msg);
  static void set_has_stroke_points_frame_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::TSP::Size& stroke_points_frame_size(const PencilAnnotationStorageArchive* msg);
  static void set_has_stroke_points_frame_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::TSP::Point& rendered_frame_origin(const PencilAnnotationStorageArchive* msg);
  static void set_has_rendered_frame_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::TSP::Size& rendered_frame_size(const PencilAnnotationStorageArchive* msg);
  static void set_has_rendered_frame_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

const ::TSP::Point&
PencilAnnotationStorageArchive::_Internal::markup_offset(const PencilAnnotationStorageArchive* msg) {
  return *msg->_impl_.markup_offset_;
}
const ::TSP::DataReference&
PencilAnnotationStorageArchive::_Internal::rasterized_image(const PencilAnnotationStorageArchive* msg) {
  return *msg->_impl_.rasterized_image_;
}
const ::TSP::DataReference&
PencilAnnotationStorageArchive::_Internal::legacy_encoded_drawing(const PencilAnnotationStorageArchive* msg) {
  return *msg->_impl_.legacy_encoded_drawing_;
}
const ::TSP::Path&
PencilAnnotationStorageArchive::_Internal::drawing_path(const PencilAnnotationStorageArchive* msg) {
  return *msg->_impl_.drawing_path_;
}
const ::TSP::Point&
PencilAnnotationStorageArchive::_Internal::strokes_bounding_box_origin(const PencilAnnotationStorageArchive* msg) {
  return *msg->_impl_.strokes_bounding_box_origin_;
}
const ::TSP::Size&
PencilAnnotationStorageArchive::_Internal::strokes_bounding_box_size(const PencilAnnotationStorageArchive* msg) {
  return *msg->_impl_.strokes_bounding_box_size_;
}
const ::TSP::Size&
PencilAnnotationStorageArchive::_Internal::original_attached_size(const PencilAnnotationStorageArchive* msg) {
  return *msg->_impl_.original_attached_size_;
}
const ::TSP::Color&
PencilAnnotationStorageArchive::_Internal::pen_color(const PencilAnnotationStorageArchive* msg) {
  return *msg->_impl_.pen_color_;
}
const ::TSP::Date&
PencilAnnotationStorageArchive::_Internal::creation_date(const PencilAnnotationStorageArchive* msg) {
  return *msg->_impl_.creation_date_;
}
const ::TSP::DataReference&
PencilAnnotationStorageArchive::_Internal::encoded_drawing(const PencilAnnotationStorageArchive* msg) {
  return *msg->_impl_.encoded_drawing_;
}
const ::TSP::Point&
PencilAnnotationStorageArchive::_Internal::stroke_points_frame_origin(const PencilAnnotationStorageArchive* msg) {
  return *msg->_impl_.stroke_points_frame_origin_;
}
const ::TSP::Size&
PencilAnnotationStorageArchive::_Internal::stroke_points_frame_size(const PencilAnnotationStorageArchive* msg) {
  return *msg->_impl_.stroke_points_frame_size_;
}
const ::TSP::Point&
PencilAnnotationStorageArchive::_Internal::rendered_frame_origin(const PencilAnnotationStorageArchive* msg) {
  return *msg->_impl_.rendered_frame_origin_;
}
const ::TSP::Size&
PencilAnnotationStorageArchive::_Internal::rendered_frame_size(const PencilAnnotationStorageArchive* msg) {
  return *msg->_impl_.rendered_frame_size_;
}
void PencilAnnotationStorageArchive::clear_markup_offset() {
  if (_impl_.markup_offset_ != nullptr) _impl_.markup_offset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PencilAnnotationStorageArchive::clear_rasterized_image() {
  if (_impl_.rasterized_image_ != nullptr) _impl_.rasterized_image_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void PencilAnnotationStorageArchive::clear_legacy_encoded_drawing() {
  if (_impl_.legacy_encoded_drawing_ != nullptr) _impl_.legacy_encoded_drawing_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void PencilAnnotationStorageArchive::clear_drawing_path() {
  if (_impl_.drawing_path_ != nullptr) _impl_.drawing_path_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void PencilAnnotationStorageArchive::clear_strokes_bounding_box_origin() {
  if (_impl_.strokes_bounding_box_origin_ != nullptr) _impl_.strokes_bounding_box_origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void PencilAnnotationStorageArchive::clear_strokes_bounding_box_size() {
  if (_impl_.strokes_bounding_box_size_ != nullptr) _impl_.strokes_bounding_box_size_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void PencilAnnotationStorageArchive::clear_original_attached_size() {
  if (_impl_.original_attached_size_ != nullptr) _impl_.original_attached_size_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void PencilAnnotationStorageArchive::clear_pen_color() {
  if (_impl_.pen_color_ != nullptr) _impl_.pen_color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
void PencilAnnotationStorageArchive::clear_callout_sub_storages() {
  _impl_.callout_sub_storages_.Clear();
}
void PencilAnnotationStorageArchive::clear_creation_date() {
  if (_impl_.creation_date_ != nullptr) _impl_.creation_date_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
void PencilAnnotationStorageArchive::clear_sub_storages() {
  _impl_.sub_storages_.Clear();
}
void PencilAnnotationStorageArchive::clear_encoded_drawing() {
  if (_impl_.encoded_drawing_ != nullptr) _impl_.encoded_drawing_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
void PencilAnnotationStorageArchive::clear_stroke_points_frame_origin() {
  if (_impl_.stroke_points_frame_origin_ != nullptr) _impl_.stroke_points_frame_origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
void PencilAnnotationStorageArchive::clear_stroke_points_frame_size() {
  if (_impl_.stroke_points_frame_size_ != nullptr) _impl_.stroke_points_frame_size_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
void PencilAnnotationStorageArchive::clear_rendered_frame_origin() {
  if (_impl_.rendered_frame_origin_ != nullptr) _impl_.rendered_frame_origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
void PencilAnnotationStorageArchive::clear_rendered_frame_size() {
  if (_impl_.rendered_frame_size_ != nullptr) _impl_.rendered_frame_size_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
PencilAnnotationStorageArchive::PencilAnnotationStorageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.PencilAnnotationStorageArchive)
}
PencilAnnotationStorageArchive::PencilAnnotationStorageArchive(const PencilAnnotationStorageArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PencilAnnotationStorageArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.callout_sub_storages_){from._impl_.callout_sub_storages_}
    , decltype(_impl_.sub_storages_){from._impl_.sub_storages_}
    , decltype(_impl_.markup_offset_){nullptr}
    , decltype(_impl_.rasterized_image_){nullptr}
    , decltype(_impl_.legacy_encoded_drawing_){nullptr}
    , decltype(_impl_.drawing_path_){nullptr}
    , decltype(_impl_.strokes_bounding_box_origin_){nullptr}
    , decltype(_impl_.strokes_bounding_box_size_){nullptr}
    , decltype(_impl_.original_attached_size_){nullptr}
    , decltype(_impl_.pen_color_){nullptr}
    , decltype(_impl_.creation_date_){nullptr}
    , decltype(_impl_.encoded_drawing_){nullptr}
    , decltype(_impl_.stroke_points_frame_origin_){nullptr}
    , decltype(_impl_.stroke_points_frame_size_){nullptr}
    , decltype(_impl_.rendered_frame_origin_){nullptr}
    , decltype(_impl_.rendered_frame_size_){nullptr}
    , decltype(_impl_.attached_location_){}
    , decltype(_impl_.attached_type_){}
    , decltype(_impl_.percent_of_pa_contained_in_parent_rep_){}
    , decltype(_impl_.text_baselines_touched_count_){}
    , decltype(_impl_.visible_strokes_count_){}
    , decltype(_impl_.tool_type_){}
    , decltype(_impl_.compound_annotation_type_){}
    , decltype(_impl_.pencil_annotation_drawing_scale_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_markup_offset()) {
    _this->_impl_.markup_offset_ = new ::TSP::Point(*from._impl_.markup_offset_);
  }
  if (from._internal_has_rasterized_image()) {
    _this->_impl_.rasterized_image_ = new ::TSP::DataReference(*from._impl_.rasterized_image_);
  }
  if (from._internal_has_legacy_encoded_drawing()) {
    _this->_impl_.legacy_encoded_drawing_ = new ::TSP::DataReference(*from._impl_.legacy_encoded_drawing_);
  }
  if (from._internal_has_drawing_path()) {
    _this->_impl_.drawing_path_ = new ::TSP::Path(*from._impl_.drawing_path_);
  }
  if (from._internal_has_strokes_bounding_box_origin()) {
    _this->_impl_.strokes_bounding_box_origin_ = new ::TSP::Point(*from._impl_.strokes_bounding_box_origin_);
  }
  if (from._internal_has_strokes_bounding_box_size()) {
    _this->_impl_.strokes_bounding_box_size_ = new ::TSP::Size(*from._impl_.strokes_bounding_box_size_);
  }
  if (from._internal_has_original_attached_size()) {
    _this->_impl_.original_attached_size_ = new ::TSP::Size(*from._impl_.original_attached_size_);
  }
  if (from._internal_has_pen_color()) {
    _this->_impl_.pen_color_ = new ::TSP::Color(*from._impl_.pen_color_);
  }
  if (from._internal_has_creation_date()) {
    _this->_impl_.creation_date_ = new ::TSP::Date(*from._impl_.creation_date_);
  }
  if (from._internal_has_encoded_drawing()) {
    _this->_impl_.encoded_drawing_ = new ::TSP::DataReference(*from._impl_.encoded_drawing_);
  }
  if (from._internal_has_stroke_points_frame_origin()) {
    _this->_impl_.stroke_points_frame_origin_ = new ::TSP::Point(*from._impl_.stroke_points_frame_origin_);
  }
  if (from._internal_has_stroke_points_frame_size()) {
    _this->_impl_.stroke_points_frame_size_ = new ::TSP::Size(*from._impl_.stroke_points_frame_size_);
  }
  if (from._internal_has_rendered_frame_origin()) {
    _this->_impl_.rendered_frame_origin_ = new ::TSP::Point(*from._impl_.rendered_frame_origin_);
  }
  if (from._internal_has_rendered_frame_size()) {
    _this->_impl_.rendered_frame_size_ = new ::TSP::Size(*from._impl_.rendered_frame_size_);
  }
  ::memcpy(&_impl_.attached_location_, &from._impl_.attached_location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pencil_annotation_drawing_scale_) -
    reinterpret_cast<char*>(&_impl_.attached_location_)) + sizeof(_impl_.pencil_annotation_drawing_scale_));
  // @@protoc_insertion_point(copy_constructor:TSD.PencilAnnotationStorageArchive)
}

inline void PencilAnnotationStorageArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.callout_sub_storages_){arena}
    , decltype(_impl_.sub_storages_){arena}
    , decltype(_impl_.markup_offset_){nullptr}
    , decltype(_impl_.rasterized_image_){nullptr}
    , decltype(_impl_.legacy_encoded_drawing_){nullptr}
    , decltype(_impl_.drawing_path_){nullptr}
    , decltype(_impl_.strokes_bounding_box_origin_){nullptr}
    , decltype(_impl_.strokes_bounding_box_size_){nullptr}
    , decltype(_impl_.original_attached_size_){nullptr}
    , decltype(_impl_.pen_color_){nullptr}
    , decltype(_impl_.creation_date_){nullptr}
    , decltype(_impl_.encoded_drawing_){nullptr}
    , decltype(_impl_.stroke_points_frame_origin_){nullptr}
    , decltype(_impl_.stroke_points_frame_size_){nullptr}
    , decltype(_impl_.rendered_frame_origin_){nullptr}
    , decltype(_impl_.rendered_frame_size_){nullptr}
    , decltype(_impl_.attached_location_){0}
    , decltype(_impl_.attached_type_){0}
    , decltype(_impl_.percent_of_pa_contained_in_parent_rep_){0}
    , decltype(_impl_.text_baselines_touched_count_){uint64_t{0u}}
    , decltype(_impl_.visible_strokes_count_){uint64_t{0u}}
    , decltype(_impl_.tool_type_){0}
    , decltype(_impl_.compound_annotation_type_){0}
    , decltype(_impl_.pencil_annotation_drawing_scale_){0}
  };
}

PencilAnnotationStorageArchive::~PencilAnnotationStorageArchive() {
  // @@protoc_insertion_point(destructor:TSD.PencilAnnotationStorageArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PencilAnnotationStorageArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.callout_sub_storages_.~RepeatedPtrField();
  _impl_.sub_storages_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.markup_offset_;
  if (this != internal_default_instance()) delete _impl_.rasterized_image_;
  if (this != internal_default_instance()) delete _impl_.legacy_encoded_drawing_;
  if (this != internal_default_instance()) delete _impl_.drawing_path_;
  if (this != internal_default_instance()) delete _impl_.strokes_bounding_box_origin_;
  if (this != internal_default_instance()) delete _impl_.strokes_bounding_box_size_;
  if (this != internal_default_instance()) delete _impl_.original_attached_size_;
  if (this != internal_default_instance()) delete _impl_.pen_color_;
  if (this != internal_default_instance()) delete _impl_.creation_date_;
  if (this != internal_default_instance()) delete _impl_.encoded_drawing_;
  if (this != internal_default_instance()) delete _impl_.stroke_points_frame_origin_;
  if (this != internal_default_instance()) delete _impl_.stroke_points_frame_size_;
  if (this != internal_default_instance()) delete _impl_.rendered_frame_origin_;
  if (this != internal_default_instance()) delete _impl_.rendered_frame_size_;
}

void PencilAnnotationStorageArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PencilAnnotationStorageArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.PencilAnnotationStorageArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.callout_sub_storages_.Clear();
  _impl_.sub_storages_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.markup_offset_ != nullptr);
      _impl_.markup_offset_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.rasterized_image_ != nullptr);
      _impl_.rasterized_image_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.legacy_encoded_drawing_ != nullptr);
      _impl_.legacy_encoded_drawing_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.drawing_path_ != nullptr);
      _impl_.drawing_path_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.strokes_bounding_box_origin_ != nullptr);
      _impl_.strokes_bounding_box_origin_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.strokes_bounding_box_size_ != nullptr);
      _impl_.strokes_bounding_box_size_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.original_attached_size_ != nullptr);
      _impl_.original_attached_size_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.pen_color_ != nullptr);
      _impl_.pen_color_->Clear();
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.creation_date_ != nullptr);
      _impl_.creation_date_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.encoded_drawing_ != nullptr);
      _impl_.encoded_drawing_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.stroke_points_frame_origin_ != nullptr);
      _impl_.stroke_points_frame_origin_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.stroke_points_frame_size_ != nullptr);
      _impl_.stroke_points_frame_size_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.rendered_frame_origin_ != nullptr);
      _impl_.rendered_frame_origin_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.rendered_frame_size_ != nullptr);
      _impl_.rendered_frame_size_->Clear();
    }
  }
  if (cached_has_bits & 0x0000c000u) {
    ::memset(&_impl_.attached_location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.attached_type_) -
        reinterpret_cast<char*>(&_impl_.attached_location_)) + sizeof(_impl_.attached_type_));
  }
  if (cached_has_bits & 0x003f0000u) {
    ::memset(&_impl_.percent_of_pa_contained_in_parent_rep_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pencil_annotation_drawing_scale_) -
        reinterpret_cast<char*>(&_impl_.percent_of_pa_contained_in_parent_rep_)) + sizeof(_impl_.pencil_annotation_drawing_scale_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PencilAnnotationStorageArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 attached_location = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_attached_location(&has_bits);
          _impl_.attached_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Point markup_offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_markup_offset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference rasterized_image = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_rasterized_image(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference legacy_encoded_drawing = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_legacy_encoded_drawing(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Path drawing_path = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_drawing_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Point strokes_bounding_box_origin = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_strokes_bounding_box_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size strokes_bounding_box_size = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_strokes_bounding_box_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 attached_type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_attached_type(&has_bits);
          _impl_.attached_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size original_attached_size = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_original_attached_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double percent_of_pa_contained_in_parent_rep = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_percent_of_pa_contained_in_parent_rep(&has_bits);
          _impl_.percent_of_pa_contained_in_parent_rep_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 text_baselines_touched_count = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_text_baselines_touched_count(&has_bits);
          _impl_.text_baselines_touched_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 visible_strokes_count = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_visible_strokes_count(&has_bits);
          _impl_.visible_strokes_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Color pen_color = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_pen_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tool_type = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_tool_type(&has_bits);
          _impl_.tool_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference callout_sub_storages = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_callout_sub_storages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Date creation_date = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_creation_date(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double pencil_annotation_drawing_scale = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          _Internal::set_has_pencil_annotation_drawing_scale(&has_bits);
          _impl_.pencil_annotation_drawing_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int32 compound_annotation_type = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_compound_annotation_type(&has_bits);
          _impl_.compound_annotation_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference sub_storages = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_sub_storages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<154>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference encoded_drawing = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_encoded_drawing(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Point stroke_points_frame_origin = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_stroke_points_frame_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size stroke_points_frame_size = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_stroke_points_frame_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Point rendered_frame_origin = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_rendered_frame_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size rendered_frame_size = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_rendered_frame_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PencilAnnotationStorageArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.PencilAnnotationStorageArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 attached_location = 1;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_attached_location(), target);
  }

  // optional .TSP.Point markup_offset = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::markup_offset(this),
        _Internal::markup_offset(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference rasterized_image = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::rasterized_image(this),
        _Internal::rasterized_image(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference legacy_encoded_drawing = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::legacy_encoded_drawing(this),
        _Internal::legacy_encoded_drawing(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Path drawing_path = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::drawing_path(this),
        _Internal::drawing_path(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Point strokes_bounding_box_origin = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::strokes_bounding_box_origin(this),
        _Internal::strokes_bounding_box_origin(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size strokes_bounding_box_size = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::strokes_bounding_box_size(this),
        _Internal::strokes_bounding_box_size(this).GetCachedSize(), target, stream);
  }

  // optional int32 attached_type = 8;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_attached_type(), target);
  }

  // optional .TSP.Size original_attached_size = 9;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::original_attached_size(this),
        _Internal::original_attached_size(this).GetCachedSize(), target, stream);
  }

  // optional double percent_of_pa_contained_in_parent_rep = 10;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_percent_of_pa_contained_in_parent_rep(), target);
  }

  // optional uint64 text_baselines_touched_count = 11;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(11, this->_internal_text_baselines_touched_count(), target);
  }

  // optional uint64 visible_strokes_count = 12;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(12, this->_internal_visible_strokes_count(), target);
  }

  // optional .TSP.Color pen_color = 13;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::pen_color(this),
        _Internal::pen_color(this).GetCachedSize(), target, stream);
  }

  // optional int32 tool_type = 14;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_tool_type(), target);
  }

  // repeated .TSP.Reference callout_sub_storages = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_callout_sub_storages_size()); i < n; i++) {
    const auto& repfield = this->_internal_callout_sub_storages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.Date creation_date = 16;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::creation_date(this),
        _Internal::creation_date(this).GetCachedSize(), target, stream);
  }

  // optional double pencil_annotation_drawing_scale = 17;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(17, this->_internal_pencil_annotation_drawing_scale(), target);
  }

  // optional int32 compound_annotation_type = 18;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(18, this->_internal_compound_annotation_type(), target);
  }

  // repeated .TSP.Reference sub_storages = 19;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sub_storages_size()); i < n; i++) {
    const auto& repfield = this->_internal_sub_storages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(19, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference encoded_drawing = 20;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::encoded_drawing(this),
        _Internal::encoded_drawing(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Point stroke_points_frame_origin = 21;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::stroke_points_frame_origin(this),
        _Internal::stroke_points_frame_origin(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size stroke_points_frame_size = 22;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::stroke_points_frame_size(this),
        _Internal::stroke_points_frame_size(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Point rendered_frame_origin = 23;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::rendered_frame_origin(this),
        _Internal::rendered_frame_origin(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size rendered_frame_size = 24;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::rendered_frame_size(this),
        _Internal::rendered_frame_size(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.PencilAnnotationStorageArchive)
  return target;
}

size_t PencilAnnotationStorageArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.PencilAnnotationStorageArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference callout_sub_storages = 15;
  total_size += 1UL * this->_internal_callout_sub_storages_size();
  for (const auto& msg : this->_impl_.callout_sub_storages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference sub_storages = 19;
  total_size += 2UL * this->_internal_sub_storages_size();
  for (const auto& msg : this->_impl_.sub_storages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSP.Point markup_offset = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.markup_offset_);
    }

    // optional .TSP.DataReference rasterized_image = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rasterized_image_);
    }

    // optional .TSP.DataReference legacy_encoded_drawing = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.legacy_encoded_drawing_);
    }

    // optional .TSP.Path drawing_path = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.drawing_path_);
    }

    // optional .TSP.Point strokes_bounding_box_origin = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.strokes_bounding_box_origin_);
    }

    // optional .TSP.Size strokes_bounding_box_size = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.strokes_bounding_box_size_);
    }

    // optional .TSP.Size original_attached_size = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.original_attached_size_);
    }

    // optional .TSP.Color pen_color = 13;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pen_color_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .TSP.Date creation_date = 16;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.creation_date_);
    }

    // optional .TSP.DataReference encoded_drawing = 20;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.encoded_drawing_);
    }

    // optional .TSP.Point stroke_points_frame_origin = 21;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stroke_points_frame_origin_);
    }

    // optional .TSP.Size stroke_points_frame_size = 22;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stroke_points_frame_size_);
    }

    // optional .TSP.Point rendered_frame_origin = 23;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rendered_frame_origin_);
    }

    // optional .TSP.Size rendered_frame_size = 24;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rendered_frame_size_);
    }

    // optional int32 attached_location = 1;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_attached_location());
    }

    // optional int32 attached_type = 8;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_attached_type());
    }

  }
  if (cached_has_bits & 0x003f0000u) {
    // optional double percent_of_pa_contained_in_parent_rep = 10;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 8;
    }

    // optional uint64 text_baselines_touched_count = 11;
    if (cached_has_bits & 0x00020000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_text_baselines_touched_count());
    }

    // optional uint64 visible_strokes_count = 12;
    if (cached_has_bits & 0x00040000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_visible_strokes_count());
    }

    // optional int32 tool_type = 14;
    if (cached_has_bits & 0x00080000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tool_type());
    }

    // optional int32 compound_annotation_type = 18;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_compound_annotation_type());
    }

    // optional double pencil_annotation_drawing_scale = 17;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PencilAnnotationStorageArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PencilAnnotationStorageArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PencilAnnotationStorageArchive::GetClassData() const { return &_class_data_; }


void PencilAnnotationStorageArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PencilAnnotationStorageArchive*>(&to_msg);
  auto& from = static_cast<const PencilAnnotationStorageArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.PencilAnnotationStorageArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.callout_sub_storages_.MergeFrom(from._impl_.callout_sub_storages_);
  _this->_impl_.sub_storages_.MergeFrom(from._impl_.sub_storages_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_markup_offset()->::TSP::Point::MergeFrom(
          from._internal_markup_offset());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_rasterized_image()->::TSP::DataReference::MergeFrom(
          from._internal_rasterized_image());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_legacy_encoded_drawing()->::TSP::DataReference::MergeFrom(
          from._internal_legacy_encoded_drawing());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_drawing_path()->::TSP::Path::MergeFrom(
          from._internal_drawing_path());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_strokes_bounding_box_origin()->::TSP::Point::MergeFrom(
          from._internal_strokes_bounding_box_origin());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_strokes_bounding_box_size()->::TSP::Size::MergeFrom(
          from._internal_strokes_bounding_box_size());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_original_attached_size()->::TSP::Size::MergeFrom(
          from._internal_original_attached_size());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_pen_color()->::TSP::Color::MergeFrom(
          from._internal_pen_color());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_creation_date()->::TSP::Date::MergeFrom(
          from._internal_creation_date());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_encoded_drawing()->::TSP::DataReference::MergeFrom(
          from._internal_encoded_drawing());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_stroke_points_frame_origin()->::TSP::Point::MergeFrom(
          from._internal_stroke_points_frame_origin());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_stroke_points_frame_size()->::TSP::Size::MergeFrom(
          from._internal_stroke_points_frame_size());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_rendered_frame_origin()->::TSP::Point::MergeFrom(
          from._internal_rendered_frame_origin());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_rendered_frame_size()->::TSP::Size::MergeFrom(
          from._internal_rendered_frame_size());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.attached_location_ = from._impl_.attached_location_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.attached_type_ = from._impl_.attached_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x003f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.percent_of_pa_contained_in_parent_rep_ = from._impl_.percent_of_pa_contained_in_parent_rep_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.text_baselines_touched_count_ = from._impl_.text_baselines_touched_count_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.visible_strokes_count_ = from._impl_.visible_strokes_count_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.tool_type_ = from._impl_.tool_type_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.compound_annotation_type_ = from._impl_.compound_annotation_type_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.pencil_annotation_drawing_scale_ = from._impl_.pencil_annotation_drawing_scale_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PencilAnnotationStorageArchive::CopyFrom(const PencilAnnotationStorageArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.PencilAnnotationStorageArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PencilAnnotationStorageArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.callout_sub_storages_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.sub_storages_))
    return false;
  if (_internal_has_markup_offset()) {
    if (!_impl_.markup_offset_->IsInitialized()) return false;
  }
  if (_internal_has_rasterized_image()) {
    if (!_impl_.rasterized_image_->IsInitialized()) return false;
  }
  if (_internal_has_legacy_encoded_drawing()) {
    if (!_impl_.legacy_encoded_drawing_->IsInitialized()) return false;
  }
  if (_internal_has_drawing_path()) {
    if (!_impl_.drawing_path_->IsInitialized()) return false;
  }
  if (_internal_has_strokes_bounding_box_origin()) {
    if (!_impl_.strokes_bounding_box_origin_->IsInitialized()) return false;
  }
  if (_internal_has_strokes_bounding_box_size()) {
    if (!_impl_.strokes_bounding_box_size_->IsInitialized()) return false;
  }
  if (_internal_has_original_attached_size()) {
    if (!_impl_.original_attached_size_->IsInitialized()) return false;
  }
  if (_internal_has_pen_color()) {
    if (!_impl_.pen_color_->IsInitialized()) return false;
  }
  if (_internal_has_creation_date()) {
    if (!_impl_.creation_date_->IsInitialized()) return false;
  }
  if (_internal_has_encoded_drawing()) {
    if (!_impl_.encoded_drawing_->IsInitialized()) return false;
  }
  if (_internal_has_stroke_points_frame_origin()) {
    if (!_impl_.stroke_points_frame_origin_->IsInitialized()) return false;
  }
  if (_internal_has_stroke_points_frame_size()) {
    if (!_impl_.stroke_points_frame_size_->IsInitialized()) return false;
  }
  if (_internal_has_rendered_frame_origin()) {
    if (!_impl_.rendered_frame_origin_->IsInitialized()) return false;
  }
  if (_internal_has_rendered_frame_size()) {
    if (!_impl_.rendered_frame_size_->IsInitialized()) return false;
  }
  return true;
}

void PencilAnnotationStorageArchive::InternalSwap(PencilAnnotationStorageArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.callout_sub_storages_.InternalSwap(&other->_impl_.callout_sub_storages_);
  _impl_.sub_storages_.InternalSwap(&other->_impl_.sub_storages_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PencilAnnotationStorageArchive, _impl_.pencil_annotation_drawing_scale_)
      + sizeof(PencilAnnotationStorageArchive::_impl_.pencil_annotation_drawing_scale_)
      - PROTOBUF_FIELD_OFFSET(PencilAnnotationStorageArchive, _impl_.markup_offset_)>(
          reinterpret_cast<char*>(&_impl_.markup_offset_),
          reinterpret_cast<char*>(&other->_impl_.markup_offset_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PencilAnnotationStorageArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[63]);
}

// ===================================================================

class SpecColorFillSetColorArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SpecColorFillSetColorArchive>()._impl_._has_bits_);
  static const ::TSP::Color& color(const SpecColorFillSetColorArchive* msg);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSP::Color&
SpecColorFillSetColorArchive::_Internal::color(const SpecColorFillSetColorArchive* msg) {
  return *msg->_impl_.color_;
}
void SpecColorFillSetColorArchive::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SpecColorFillSetColorArchive::SpecColorFillSetColorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.SpecColorFillSetColorArchive)
}
SpecColorFillSetColorArchive::SpecColorFillSetColorArchive(const SpecColorFillSetColorArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpecColorFillSetColorArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::TSP::Color(*from._impl_.color_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.SpecColorFillSetColorArchive)
}

inline void SpecColorFillSetColorArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
  };
}

SpecColorFillSetColorArchive::~SpecColorFillSetColorArchive() {
  // @@protoc_insertion_point(destructor:TSD.SpecColorFillSetColorArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpecColorFillSetColorArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.color_;
}

void SpecColorFillSetColorArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpecColorFillSetColorArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.SpecColorFillSetColorArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.color_ != nullptr);
    _impl_.color_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpecColorFillSetColorArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.Color color = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpecColorFillSetColorArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.SpecColorFillSetColorArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.Color color = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.SpecColorFillSetColorArchive)
  return target;
}

size_t SpecColorFillSetColorArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.SpecColorFillSetColorArchive)
  size_t total_size = 0;

  // required .TSP.Color color = 1;
  if (_internal_has_color()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.color_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpecColorFillSetColorArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpecColorFillSetColorArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpecColorFillSetColorArchive::GetClassData() const { return &_class_data_; }


void SpecColorFillSetColorArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpecColorFillSetColorArchive*>(&to_msg);
  auto& from = static_cast<const SpecColorFillSetColorArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.SpecColorFillSetColorArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_color()) {
    _this->_internal_mutable_color()->::TSP::Color::MergeFrom(
        from._internal_color());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpecColorFillSetColorArchive::CopyFrom(const SpecColorFillSetColorArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.SpecColorFillSetColorArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpecColorFillSetColorArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_color()) {
    if (!_impl_.color_->IsInitialized()) return false;
  }
  return true;
}

void SpecColorFillSetColorArchive::InternalSwap(SpecColorFillSetColorArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.color_, other->_impl_.color_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpecColorFillSetColorArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[64]);
}

// ===================================================================

class SpecFrameSetAssetScaleArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SpecFrameSetAssetScaleArchive>()._impl_._has_bits_);
  static void set_has_asset_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SpecFrameSetAssetScaleArchive::SpecFrameSetAssetScaleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.SpecFrameSetAssetScaleArchive)
}
SpecFrameSetAssetScaleArchive::SpecFrameSetAssetScaleArchive(const SpecFrameSetAssetScaleArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpecFrameSetAssetScaleArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.asset_scale_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.asset_scale_ = from._impl_.asset_scale_;
  // @@protoc_insertion_point(copy_constructor:TSD.SpecFrameSetAssetScaleArchive)
}

inline void SpecFrameSetAssetScaleArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.asset_scale_){0}
  };
}

SpecFrameSetAssetScaleArchive::~SpecFrameSetAssetScaleArchive() {
  // @@protoc_insertion_point(destructor:TSD.SpecFrameSetAssetScaleArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpecFrameSetAssetScaleArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SpecFrameSetAssetScaleArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpecFrameSetAssetScaleArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.SpecFrameSetAssetScaleArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.asset_scale_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpecFrameSetAssetScaleArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double asset_scale = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_asset_scale(&has_bits);
          _impl_.asset_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpecFrameSetAssetScaleArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.SpecFrameSetAssetScaleArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double asset_scale = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_asset_scale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.SpecFrameSetAssetScaleArchive)
  return target;
}

size_t SpecFrameSetAssetScaleArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.SpecFrameSetAssetScaleArchive)
  size_t total_size = 0;

  // required double asset_scale = 1;
  if (_internal_has_asset_scale()) {
    total_size += 1 + 8;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpecFrameSetAssetScaleArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpecFrameSetAssetScaleArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpecFrameSetAssetScaleArchive::GetClassData() const { return &_class_data_; }


void SpecFrameSetAssetScaleArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpecFrameSetAssetScaleArchive*>(&to_msg);
  auto& from = static_cast<const SpecFrameSetAssetScaleArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.SpecFrameSetAssetScaleArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_asset_scale()) {
    _this->_internal_set_asset_scale(from._internal_asset_scale());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpecFrameSetAssetScaleArchive::CopyFrom(const SpecFrameSetAssetScaleArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.SpecFrameSetAssetScaleArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpecFrameSetAssetScaleArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SpecFrameSetAssetScaleArchive::InternalSwap(SpecFrameSetAssetScaleArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.asset_scale_, other->_impl_.asset_scale_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpecFrameSetAssetScaleArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[65]);
}

// ===================================================================

class SpecGradientFillSetAngleArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SpecGradientFillSetAngleArchive>()._impl_._has_bits_);
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SpecGradientFillSetAngleArchive::SpecGradientFillSetAngleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.SpecGradientFillSetAngleArchive)
}
SpecGradientFillSetAngleArchive::SpecGradientFillSetAngleArchive(const SpecGradientFillSetAngleArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpecGradientFillSetAngleArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.angle_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.angle_ = from._impl_.angle_;
  // @@protoc_insertion_point(copy_constructor:TSD.SpecGradientFillSetAngleArchive)
}

inline void SpecGradientFillSetAngleArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.angle_){0}
  };
}

SpecGradientFillSetAngleArchive::~SpecGradientFillSetAngleArchive() {
  // @@protoc_insertion_point(destructor:TSD.SpecGradientFillSetAngleArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpecGradientFillSetAngleArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SpecGradientFillSetAngleArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpecGradientFillSetAngleArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.SpecGradientFillSetAngleArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.angle_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpecGradientFillSetAngleArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double angle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_angle(&has_bits);
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpecGradientFillSetAngleArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.SpecGradientFillSetAngleArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double angle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.SpecGradientFillSetAngleArchive)
  return target;
}

size_t SpecGradientFillSetAngleArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.SpecGradientFillSetAngleArchive)
  size_t total_size = 0;

  // required double angle = 1;
  if (_internal_has_angle()) {
    total_size += 1 + 8;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpecGradientFillSetAngleArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpecGradientFillSetAngleArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpecGradientFillSetAngleArchive::GetClassData() const { return &_class_data_; }


void SpecGradientFillSetAngleArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpecGradientFillSetAngleArchive*>(&to_msg);
  auto& from = static_cast<const SpecGradientFillSetAngleArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.SpecGradientFillSetAngleArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_angle()) {
    _this->_internal_set_angle(from._internal_angle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpecGradientFillSetAngleArchive::CopyFrom(const SpecGradientFillSetAngleArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.SpecGradientFillSetAngleArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpecGradientFillSetAngleArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SpecGradientFillSetAngleArchive::InternalSwap(SpecGradientFillSetAngleArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.angle_, other->_impl_.angle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpecGradientFillSetAngleArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[66]);
}

// ===================================================================

class SpecImageFillSetTechniqueArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SpecImageFillSetTechniqueArchive>()._impl_._has_bits_);
  static void set_has_technique(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SpecImageFillSetTechniqueArchive::SpecImageFillSetTechniqueArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.SpecImageFillSetTechniqueArchive)
}
SpecImageFillSetTechniqueArchive::SpecImageFillSetTechniqueArchive(const SpecImageFillSetTechniqueArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpecImageFillSetTechniqueArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.technique_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.technique_ = from._impl_.technique_;
  // @@protoc_insertion_point(copy_constructor:TSD.SpecImageFillSetTechniqueArchive)
}

inline void SpecImageFillSetTechniqueArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.technique_){0}
  };
}

SpecImageFillSetTechniqueArchive::~SpecImageFillSetTechniqueArchive() {
  // @@protoc_insertion_point(destructor:TSD.SpecImageFillSetTechniqueArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpecImageFillSetTechniqueArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SpecImageFillSetTechniqueArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpecImageFillSetTechniqueArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.SpecImageFillSetTechniqueArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.technique_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpecImageFillSetTechniqueArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 technique = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_technique(&has_bits);
          _impl_.technique_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpecImageFillSetTechniqueArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.SpecImageFillSetTechniqueArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 technique = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_technique(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.SpecImageFillSetTechniqueArchive)
  return target;
}

size_t SpecImageFillSetTechniqueArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.SpecImageFillSetTechniqueArchive)
  size_t total_size = 0;

  // required int32 technique = 1;
  if (_internal_has_technique()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_technique());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpecImageFillSetTechniqueArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpecImageFillSetTechniqueArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpecImageFillSetTechniqueArchive::GetClassData() const { return &_class_data_; }


void SpecImageFillSetTechniqueArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpecImageFillSetTechniqueArchive*>(&to_msg);
  auto& from = static_cast<const SpecImageFillSetTechniqueArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.SpecImageFillSetTechniqueArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_technique()) {
    _this->_internal_set_technique(from._internal_technique());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpecImageFillSetTechniqueArchive::CopyFrom(const SpecImageFillSetTechniqueArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.SpecImageFillSetTechniqueArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpecImageFillSetTechniqueArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SpecImageFillSetTechniqueArchive::InternalSwap(SpecImageFillSetTechniqueArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.technique_, other->_impl_.technique_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpecImageFillSetTechniqueArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[67]);
}

// ===================================================================

class SpecReflectionSetOpacityArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SpecReflectionSetOpacityArchive>()._impl_._has_bits_);
  static void set_has_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SpecReflectionSetOpacityArchive::SpecReflectionSetOpacityArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.SpecReflectionSetOpacityArchive)
}
SpecReflectionSetOpacityArchive::SpecReflectionSetOpacityArchive(const SpecReflectionSetOpacityArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpecReflectionSetOpacityArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.opacity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.opacity_ = from._impl_.opacity_;
  // @@protoc_insertion_point(copy_constructor:TSD.SpecReflectionSetOpacityArchive)
}

inline void SpecReflectionSetOpacityArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.opacity_){0}
  };
}

SpecReflectionSetOpacityArchive::~SpecReflectionSetOpacityArchive() {
  // @@protoc_insertion_point(destructor:TSD.SpecReflectionSetOpacityArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpecReflectionSetOpacityArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SpecReflectionSetOpacityArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpecReflectionSetOpacityArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.SpecReflectionSetOpacityArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.opacity_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpecReflectionSetOpacityArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double opacity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_opacity(&has_bits);
          _impl_.opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpecReflectionSetOpacityArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.SpecReflectionSetOpacityArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double opacity = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_opacity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.SpecReflectionSetOpacityArchive)
  return target;
}

size_t SpecReflectionSetOpacityArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.SpecReflectionSetOpacityArchive)
  size_t total_size = 0;

  // required double opacity = 1;
  if (_internal_has_opacity()) {
    total_size += 1 + 8;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpecReflectionSetOpacityArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpecReflectionSetOpacityArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpecReflectionSetOpacityArchive::GetClassData() const { return &_class_data_; }


void SpecReflectionSetOpacityArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpecReflectionSetOpacityArchive*>(&to_msg);
  auto& from = static_cast<const SpecReflectionSetOpacityArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.SpecReflectionSetOpacityArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_opacity()) {
    _this->_internal_set_opacity(from._internal_opacity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpecReflectionSetOpacityArchive::CopyFrom(const SpecReflectionSetOpacityArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.SpecReflectionSetOpacityArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpecReflectionSetOpacityArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SpecReflectionSetOpacityArchive::InternalSwap(SpecReflectionSetOpacityArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.opacity_, other->_impl_.opacity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpecReflectionSetOpacityArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[68]);
}

// ===================================================================

class SpecShadowSetAngleArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SpecShadowSetAngleArchive>()._impl_._has_bits_);
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SpecShadowSetAngleArchive::SpecShadowSetAngleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.SpecShadowSetAngleArchive)
}
SpecShadowSetAngleArchive::SpecShadowSetAngleArchive(const SpecShadowSetAngleArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpecShadowSetAngleArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.angle_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.angle_ = from._impl_.angle_;
  // @@protoc_insertion_point(copy_constructor:TSD.SpecShadowSetAngleArchive)
}

inline void SpecShadowSetAngleArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.angle_){0}
  };
}

SpecShadowSetAngleArchive::~SpecShadowSetAngleArchive() {
  // @@protoc_insertion_point(destructor:TSD.SpecShadowSetAngleArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpecShadowSetAngleArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SpecShadowSetAngleArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpecShadowSetAngleArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.SpecShadowSetAngleArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.angle_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpecShadowSetAngleArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double angle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_angle(&has_bits);
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpecShadowSetAngleArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.SpecShadowSetAngleArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double angle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.SpecShadowSetAngleArchive)
  return target;
}

size_t SpecShadowSetAngleArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.SpecShadowSetAngleArchive)
  size_t total_size = 0;

  // required double angle = 1;
  if (_internal_has_angle()) {
    total_size += 1 + 8;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpecShadowSetAngleArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpecShadowSetAngleArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpecShadowSetAngleArchive::GetClassData() const { return &_class_data_; }


void SpecShadowSetAngleArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpecShadowSetAngleArchive*>(&to_msg);
  auto& from = static_cast<const SpecShadowSetAngleArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.SpecShadowSetAngleArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_angle()) {
    _this->_internal_set_angle(from._internal_angle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpecShadowSetAngleArchive::CopyFrom(const SpecShadowSetAngleArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.SpecShadowSetAngleArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpecShadowSetAngleArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SpecShadowSetAngleArchive::InternalSwap(SpecShadowSetAngleArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.angle_, other->_impl_.angle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpecShadowSetAngleArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[69]);
}

// ===================================================================

class SpecShadowSetColorArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SpecShadowSetColorArchive>()._impl_._has_bits_);
  static const ::TSP::Color& color(const SpecShadowSetColorArchive* msg);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSP::Color&
SpecShadowSetColorArchive::_Internal::color(const SpecShadowSetColorArchive* msg) {
  return *msg->_impl_.color_;
}
void SpecShadowSetColorArchive::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SpecShadowSetColorArchive::SpecShadowSetColorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.SpecShadowSetColorArchive)
}
SpecShadowSetColorArchive::SpecShadowSetColorArchive(const SpecShadowSetColorArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpecShadowSetColorArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::TSP::Color(*from._impl_.color_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.SpecShadowSetColorArchive)
}

inline void SpecShadowSetColorArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
  };
}

SpecShadowSetColorArchive::~SpecShadowSetColorArchive() {
  // @@protoc_insertion_point(destructor:TSD.SpecShadowSetColorArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpecShadowSetColorArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.color_;
}

void SpecShadowSetColorArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpecShadowSetColorArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.SpecShadowSetColorArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.color_ != nullptr);
    _impl_.color_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpecShadowSetColorArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.Color color = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpecShadowSetColorArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.SpecShadowSetColorArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.Color color = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.SpecShadowSetColorArchive)
  return target;
}

size_t SpecShadowSetColorArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.SpecShadowSetColorArchive)
  size_t total_size = 0;

  // required .TSP.Color color = 1;
  if (_internal_has_color()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.color_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpecShadowSetColorArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpecShadowSetColorArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpecShadowSetColorArchive::GetClassData() const { return &_class_data_; }


void SpecShadowSetColorArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpecShadowSetColorArchive*>(&to_msg);
  auto& from = static_cast<const SpecShadowSetColorArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.SpecShadowSetColorArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_color()) {
    _this->_internal_mutable_color()->::TSP::Color::MergeFrom(
        from._internal_color());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpecShadowSetColorArchive::CopyFrom(const SpecShadowSetColorArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.SpecShadowSetColorArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpecShadowSetColorArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_color()) {
    if (!_impl_.color_->IsInitialized()) return false;
  }
  return true;
}

void SpecShadowSetColorArchive::InternalSwap(SpecShadowSetColorArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.color_, other->_impl_.color_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpecShadowSetColorArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[70]);
}

// ===================================================================

class SpecShadowSetOffsetArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SpecShadowSetOffsetArchive>()._impl_._has_bits_);
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SpecShadowSetOffsetArchive::SpecShadowSetOffsetArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.SpecShadowSetOffsetArchive)
}
SpecShadowSetOffsetArchive::SpecShadowSetOffsetArchive(const SpecShadowSetOffsetArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpecShadowSetOffsetArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.offset_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.offset_ = from._impl_.offset_;
  // @@protoc_insertion_point(copy_constructor:TSD.SpecShadowSetOffsetArchive)
}

inline void SpecShadowSetOffsetArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.offset_){0}
  };
}

SpecShadowSetOffsetArchive::~SpecShadowSetOffsetArchive() {
  // @@protoc_insertion_point(destructor:TSD.SpecShadowSetOffsetArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpecShadowSetOffsetArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SpecShadowSetOffsetArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpecShadowSetOffsetArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.SpecShadowSetOffsetArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.offset_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpecShadowSetOffsetArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double offset = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpecShadowSetOffsetArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.SpecShadowSetOffsetArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double offset = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.SpecShadowSetOffsetArchive)
  return target;
}

size_t SpecShadowSetOffsetArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.SpecShadowSetOffsetArchive)
  size_t total_size = 0;

  // required double offset = 1;
  if (_internal_has_offset()) {
    total_size += 1 + 8;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpecShadowSetOffsetArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpecShadowSetOffsetArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpecShadowSetOffsetArchive::GetClassData() const { return &_class_data_; }


void SpecShadowSetOffsetArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpecShadowSetOffsetArchive*>(&to_msg);
  auto& from = static_cast<const SpecShadowSetOffsetArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.SpecShadowSetOffsetArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_offset()) {
    _this->_internal_set_offset(from._internal_offset());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpecShadowSetOffsetArchive::CopyFrom(const SpecShadowSetOffsetArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.SpecShadowSetOffsetArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpecShadowSetOffsetArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SpecShadowSetOffsetArchive::InternalSwap(SpecShadowSetOffsetArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.offset_, other->_impl_.offset_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpecShadowSetOffsetArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[71]);
}

// ===================================================================

class SpecShadowSetOpacityArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SpecShadowSetOpacityArchive>()._impl_._has_bits_);
  static void set_has_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SpecShadowSetOpacityArchive::SpecShadowSetOpacityArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.SpecShadowSetOpacityArchive)
}
SpecShadowSetOpacityArchive::SpecShadowSetOpacityArchive(const SpecShadowSetOpacityArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpecShadowSetOpacityArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.opacity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.opacity_ = from._impl_.opacity_;
  // @@protoc_insertion_point(copy_constructor:TSD.SpecShadowSetOpacityArchive)
}

inline void SpecShadowSetOpacityArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.opacity_){0}
  };
}

SpecShadowSetOpacityArchive::~SpecShadowSetOpacityArchive() {
  // @@protoc_insertion_point(destructor:TSD.SpecShadowSetOpacityArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpecShadowSetOpacityArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SpecShadowSetOpacityArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpecShadowSetOpacityArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.SpecShadowSetOpacityArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.opacity_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpecShadowSetOpacityArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double opacity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_opacity(&has_bits);
          _impl_.opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpecShadowSetOpacityArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.SpecShadowSetOpacityArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double opacity = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_opacity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.SpecShadowSetOpacityArchive)
  return target;
}

size_t SpecShadowSetOpacityArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.SpecShadowSetOpacityArchive)
  size_t total_size = 0;

  // required double opacity = 1;
  if (_internal_has_opacity()) {
    total_size += 1 + 8;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpecShadowSetOpacityArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpecShadowSetOpacityArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpecShadowSetOpacityArchive::GetClassData() const { return &_class_data_; }


void SpecShadowSetOpacityArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpecShadowSetOpacityArchive*>(&to_msg);
  auto& from = static_cast<const SpecShadowSetOpacityArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.SpecShadowSetOpacityArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_opacity()) {
    _this->_internal_set_opacity(from._internal_opacity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpecShadowSetOpacityArchive::CopyFrom(const SpecShadowSetOpacityArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.SpecShadowSetOpacityArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpecShadowSetOpacityArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SpecShadowSetOpacityArchive::InternalSwap(SpecShadowSetOpacityArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.opacity_, other->_impl_.opacity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpecShadowSetOpacityArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[72]);
}

// ===================================================================

class SpecShadowSetRadiusArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SpecShadowSetRadiusArchive>()._impl_._has_bits_);
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SpecShadowSetRadiusArchive::SpecShadowSetRadiusArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.SpecShadowSetRadiusArchive)
}
SpecShadowSetRadiusArchive::SpecShadowSetRadiusArchive(const SpecShadowSetRadiusArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpecShadowSetRadiusArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.radius_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.radius_ = from._impl_.radius_;
  // @@protoc_insertion_point(copy_constructor:TSD.SpecShadowSetRadiusArchive)
}

inline void SpecShadowSetRadiusArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.radius_){0}
  };
}

SpecShadowSetRadiusArchive::~SpecShadowSetRadiusArchive() {
  // @@protoc_insertion_point(destructor:TSD.SpecShadowSetRadiusArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpecShadowSetRadiusArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SpecShadowSetRadiusArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpecShadowSetRadiusArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.SpecShadowSetRadiusArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.radius_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpecShadowSetRadiusArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 radius = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_radius(&has_bits);
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpecShadowSetRadiusArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.SpecShadowSetRadiusArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 radius = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_radius(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.SpecShadowSetRadiusArchive)
  return target;
}

size_t SpecShadowSetRadiusArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.SpecShadowSetRadiusArchive)
  size_t total_size = 0;

  // required int32 radius = 1;
  if (_internal_has_radius()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_radius());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpecShadowSetRadiusArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpecShadowSetRadiusArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpecShadowSetRadiusArchive::GetClassData() const { return &_class_data_; }


void SpecShadowSetRadiusArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpecShadowSetRadiusArchive*>(&to_msg);
  auto& from = static_cast<const SpecShadowSetRadiusArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.SpecShadowSetRadiusArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_radius()) {
    _this->_internal_set_radius(from._internal_radius());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpecShadowSetRadiusArchive::CopyFrom(const SpecShadowSetRadiusArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.SpecShadowSetRadiusArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpecShadowSetRadiusArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SpecShadowSetRadiusArchive::InternalSwap(SpecShadowSetRadiusArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.radius_, other->_impl_.radius_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpecShadowSetRadiusArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[73]);
}

// ===================================================================

class SpecStrokeSetColorArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SpecStrokeSetColorArchive>()._impl_._has_bits_);
  static const ::TSP::Color& color(const SpecStrokeSetColorArchive* msg);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSP::Color&
SpecStrokeSetColorArchive::_Internal::color(const SpecStrokeSetColorArchive* msg) {
  return *msg->_impl_.color_;
}
void SpecStrokeSetColorArchive::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SpecStrokeSetColorArchive::SpecStrokeSetColorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.SpecStrokeSetColorArchive)
}
SpecStrokeSetColorArchive::SpecStrokeSetColorArchive(const SpecStrokeSetColorArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpecStrokeSetColorArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::TSP::Color(*from._impl_.color_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.SpecStrokeSetColorArchive)
}

inline void SpecStrokeSetColorArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
  };
}

SpecStrokeSetColorArchive::~SpecStrokeSetColorArchive() {
  // @@protoc_insertion_point(destructor:TSD.SpecStrokeSetColorArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpecStrokeSetColorArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.color_;
}

void SpecStrokeSetColorArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpecStrokeSetColorArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.SpecStrokeSetColorArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.color_ != nullptr);
    _impl_.color_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpecStrokeSetColorArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.Color color = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpecStrokeSetColorArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.SpecStrokeSetColorArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.Color color = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.SpecStrokeSetColorArchive)
  return target;
}

size_t SpecStrokeSetColorArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.SpecStrokeSetColorArchive)
  size_t total_size = 0;

  // required .TSP.Color color = 1;
  if (_internal_has_color()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.color_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpecStrokeSetColorArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpecStrokeSetColorArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpecStrokeSetColorArchive::GetClassData() const { return &_class_data_; }


void SpecStrokeSetColorArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpecStrokeSetColorArchive*>(&to_msg);
  auto& from = static_cast<const SpecStrokeSetColorArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.SpecStrokeSetColorArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_color()) {
    _this->_internal_mutable_color()->::TSP::Color::MergeFrom(
        from._internal_color());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpecStrokeSetColorArchive::CopyFrom(const SpecStrokeSetColorArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.SpecStrokeSetColorArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpecStrokeSetColorArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_color()) {
    if (!_impl_.color_->IsInitialized()) return false;
  }
  return true;
}

void SpecStrokeSetColorArchive::InternalSwap(SpecStrokeSetColorArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.color_, other->_impl_.color_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpecStrokeSetColorArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[74]);
}

// ===================================================================

class SpecStrokeSetPatternArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SpecStrokeSetPatternArchive>()._impl_._has_bits_);
  static void set_has_line_cap(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_line_join(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_miter_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::Color& color(const SpecStrokeSetPatternArchive* msg);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::StrokePatternArchive& pattern(const SpecStrokeSetPatternArchive* msg);
  static void set_has_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::TSP::Color&
SpecStrokeSetPatternArchive::_Internal::color(const SpecStrokeSetPatternArchive* msg) {
  return *msg->_impl_.color_;
}
const ::TSD::StrokePatternArchive&
SpecStrokeSetPatternArchive::_Internal::pattern(const SpecStrokeSetPatternArchive* msg) {
  return *msg->_impl_.pattern_;
}
void SpecStrokeSetPatternArchive::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SpecStrokeSetPatternArchive::SpecStrokeSetPatternArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.SpecStrokeSetPatternArchive)
}
SpecStrokeSetPatternArchive::SpecStrokeSetPatternArchive(const SpecStrokeSetPatternArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpecStrokeSetPatternArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.pattern_){nullptr}
    , decltype(_impl_.line_cap_){}
    , decltype(_impl_.line_join_){}
    , decltype(_impl_.miter_limit_){}
    , decltype(_impl_.width_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::TSP::Color(*from._impl_.color_);
  }
  if (from._internal_has_pattern()) {
    _this->_impl_.pattern_ = new ::TSD::StrokePatternArchive(*from._impl_.pattern_);
  }
  ::memcpy(&_impl_.line_cap_, &from._impl_.line_cap_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.width_) -
    reinterpret_cast<char*>(&_impl_.line_cap_)) + sizeof(_impl_.width_));
  // @@protoc_insertion_point(copy_constructor:TSD.SpecStrokeSetPatternArchive)
}

inline void SpecStrokeSetPatternArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.pattern_){nullptr}
    , decltype(_impl_.line_cap_){0}
    , decltype(_impl_.line_join_){0}
    , decltype(_impl_.miter_limit_){0}
    , decltype(_impl_.width_){0}
  };
}

SpecStrokeSetPatternArchive::~SpecStrokeSetPatternArchive() {
  // @@protoc_insertion_point(destructor:TSD.SpecStrokeSetPatternArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpecStrokeSetPatternArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.color_;
  if (this != internal_default_instance()) delete _impl_.pattern_;
}

void SpecStrokeSetPatternArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpecStrokeSetPatternArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.SpecStrokeSetPatternArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.color_ != nullptr);
      _impl_.color_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.pattern_ != nullptr);
      _impl_.pattern_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.line_cap_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.width_) -
        reinterpret_cast<char*>(&_impl_.line_cap_)) + sizeof(_impl_.width_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpecStrokeSetPatternArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 line_cap = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_line_cap(&has_bits);
          _impl_.line_cap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 line_join = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_line_join(&has_bits);
          _impl_.line_join_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double miter_limit = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_miter_limit(&has_bits);
          _impl_.miter_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double width = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Color color = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSD.StrokePatternArchive pattern = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_pattern(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpecStrokeSetPatternArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.SpecStrokeSetPatternArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 line_cap = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_line_cap(), target);
  }

  // optional int32 line_join = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_line_join(), target);
  }

  // optional double miter_limit = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_miter_limit(), target);
  }

  // optional double width = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_width(), target);
  }

  // optional .TSP.Color color = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  // required .TSD.StrokePatternArchive pattern = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::pattern(this),
        _Internal::pattern(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.SpecStrokeSetPatternArchive)
  return target;
}

size_t SpecStrokeSetPatternArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.SpecStrokeSetPatternArchive)
  size_t total_size = 0;

  // required .TSD.StrokePatternArchive pattern = 6;
  if (_internal_has_pattern()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pattern_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Color color = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.color_);
  }

  if (cached_has_bits & 0x0000003cu) {
    // optional int32 line_cap = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_line_cap());
    }

    // optional int32 line_join = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_line_join());
    }

    // optional double miter_limit = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double width = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpecStrokeSetPatternArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpecStrokeSetPatternArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpecStrokeSetPatternArchive::GetClassData() const { return &_class_data_; }


void SpecStrokeSetPatternArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpecStrokeSetPatternArchive*>(&to_msg);
  auto& from = static_cast<const SpecStrokeSetPatternArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.SpecStrokeSetPatternArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_color()->::TSP::Color::MergeFrom(
          from._internal_color());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_pattern()->::TSD::StrokePatternArchive::MergeFrom(
          from._internal_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.line_cap_ = from._impl_.line_cap_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.line_join_ = from._impl_.line_join_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.miter_limit_ = from._impl_.miter_limit_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpecStrokeSetPatternArchive::CopyFrom(const SpecStrokeSetPatternArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.SpecStrokeSetPatternArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpecStrokeSetPatternArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_color()) {
    if (!_impl_.color_->IsInitialized()) return false;
  }
  return true;
}

void SpecStrokeSetPatternArchive::InternalSwap(SpecStrokeSetPatternArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpecStrokeSetPatternArchive, _impl_.width_)
      + sizeof(SpecStrokeSetPatternArchive::_impl_.width_)
      - PROTOBUF_FIELD_OFFSET(SpecStrokeSetPatternArchive, _impl_.color_)>(
          reinterpret_cast<char*>(&_impl_.color_),
          reinterpret_cast<char*>(&other->_impl_.color_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpecStrokeSetPatternArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[75]);
}

// ===================================================================

class SpecStrokeSetWidthArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SpecStrokeSetWidthArchive>()._impl_._has_bits_);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SpecStrokeSetWidthArchive::SpecStrokeSetWidthArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.SpecStrokeSetWidthArchive)
}
SpecStrokeSetWidthArchive::SpecStrokeSetWidthArchive(const SpecStrokeSetWidthArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpecStrokeSetWidthArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.width_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.width_ = from._impl_.width_;
  // @@protoc_insertion_point(copy_constructor:TSD.SpecStrokeSetWidthArchive)
}

inline void SpecStrokeSetWidthArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.width_){0}
  };
}

SpecStrokeSetWidthArchive::~SpecStrokeSetWidthArchive() {
  // @@protoc_insertion_point(destructor:TSD.SpecStrokeSetWidthArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpecStrokeSetWidthArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SpecStrokeSetWidthArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpecStrokeSetWidthArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.SpecStrokeSetWidthArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.width_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpecStrokeSetWidthArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpecStrokeSetWidthArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.SpecStrokeSetWidthArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double width = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.SpecStrokeSetWidthArchive)
  return target;
}

size_t SpecStrokeSetWidthArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.SpecStrokeSetWidthArchive)
  size_t total_size = 0;

  // required double width = 1;
  if (_internal_has_width()) {
    total_size += 1 + 8;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpecStrokeSetWidthArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpecStrokeSetWidthArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpecStrokeSetWidthArchive::GetClassData() const { return &_class_data_; }


void SpecStrokeSetWidthArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpecStrokeSetWidthArchive*>(&to_msg);
  auto& from = static_cast<const SpecStrokeSetWidthArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.SpecStrokeSetWidthArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_width()) {
    _this->_internal_set_width(from._internal_width());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpecStrokeSetWidthArchive::CopyFrom(const SpecStrokeSetWidthArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.SpecStrokeSetWidthArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpecStrokeSetWidthArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SpecStrokeSetWidthArchive::InternalSwap(SpecStrokeSetWidthArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.width_, other->_impl_.width_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpecStrokeSetWidthArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[76]);
}

// ===================================================================

class Attribution::_Internal {
 public:
  using HasBits = decltype(std::declval<Attribution>()._impl_._has_bits_);
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_description_text(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_external_url(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_author_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_author_url(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Attribution::Attribution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.Attribution)
}
Attribution::Attribution(const Attribution& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Attribution* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.title_){}
    , decltype(_impl_.description_text_){}
    , decltype(_impl_.external_url_){}
    , decltype(_impl_.author_name_){}
    , decltype(_impl_.author_url_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description_text()) {
    _this->_impl_.description_text_.Set(from._internal_description_text(), 
      _this->GetArenaForAllocation());
  }
  _impl_.external_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.external_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_external_url()) {
    _this->_impl_.external_url_.Set(from._internal_external_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.author_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.author_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_author_name()) {
    _this->_impl_.author_name_.Set(from._internal_author_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.author_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.author_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_author_url()) {
    _this->_impl_.author_url_.Set(from._internal_author_url(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:TSD.Attribution)
}

inline void Attribution::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.title_){}
    , decltype(_impl_.description_text_){}
    , decltype(_impl_.external_url_){}
    , decltype(_impl_.author_name_){}
    , decltype(_impl_.author_url_){}
  };
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.external_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.external_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.author_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.author_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.author_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.author_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Attribution::~Attribution() {
  // @@protoc_insertion_point(destructor:TSD.Attribution)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Attribution::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.title_.Destroy();
  _impl_.description_text_.Destroy();
  _impl_.external_url_.Destroy();
  _impl_.author_name_.Destroy();
  _impl_.author_url_.Destroy();
}

void Attribution::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Attribution::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.Attribution)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.description_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.external_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.author_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.author_url_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Attribution::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string title = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.Attribution.title");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string description_text = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.Attribution.description_text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string external_url = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_external_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.Attribution.external_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string author_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_author_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.Attribution.author_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string author_url = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_author_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.Attribution.author_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Attribution::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.Attribution)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string title = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.Attribution.title");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_title(), target);
  }

  // optional string description_text = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description_text().data(), static_cast<int>(this->_internal_description_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.Attribution.description_text");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description_text(), target);
  }

  // optional string external_url = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_external_url().data(), static_cast<int>(this->_internal_external_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.Attribution.external_url");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_external_url(), target);
  }

  // optional string author_name = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_author_name().data(), static_cast<int>(this->_internal_author_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.Attribution.author_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_author_name(), target);
  }

  // optional string author_url = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_author_url().data(), static_cast<int>(this->_internal_author_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.Attribution.author_url");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_author_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.Attribution)
  return target;
}

size_t Attribution::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.Attribution)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string title = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title());
    }

    // optional string description_text = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description_text());
    }

    // optional string external_url = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_external_url());
    }

    // optional string author_name = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_author_name());
    }

    // optional string author_url = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_author_url());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Attribution::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Attribution::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Attribution::GetClassData() const { return &_class_data_; }


void Attribution::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Attribution*>(&to_msg);
  auto& from = static_cast<const Attribution&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.Attribution)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_title(from._internal_title());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_description_text(from._internal_description_text());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_external_url(from._internal_external_url());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_author_name(from._internal_author_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_author_url(from._internal_author_url());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Attribution::CopyFrom(const Attribution& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.Attribution)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Attribution::IsInitialized() const {
  return true;
}

void Attribution::InternalSwap(Attribution* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_text_, lhs_arena,
      &other->_impl_.description_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.external_url_, lhs_arena,
      &other->_impl_.external_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.author_name_, lhs_arena,
      &other->_impl_.author_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.author_url_, lhs_arena,
      &other->_impl_.author_url_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Attribution::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[77]);
}

// ===================================================================

class MovieFingerprint::_Internal {
 public:
};

MovieFingerprint::MovieFingerprint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.MovieFingerprint)
}
MovieFingerprint::MovieFingerprint(const MovieFingerprint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MovieFingerprint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tracks_){from._impl_.tracks_}
    , decltype(_impl_.version_){from._impl_.version_}
    , /*decltype(_impl_._version_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSD.MovieFingerprint)
}

inline void MovieFingerprint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tracks_){arena}
    , decltype(_impl_.version_){arena}
    , /*decltype(_impl_._version_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MovieFingerprint::~MovieFingerprint() {
  // @@protoc_insertion_point(destructor:TSD.MovieFingerprint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MovieFingerprint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tracks_.~RepeatedPtrField();
  _impl_.version_.~RepeatedField();
}

void MovieFingerprint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MovieFingerprint::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.MovieFingerprint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tracks_.Clear();
  _impl_.version_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MovieFingerprint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSD.MovieFingerprintTrack tracks = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tracks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 version = 2 [packed = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_version(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_version(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MovieFingerprint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.MovieFingerprint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSD.MovieFingerprintTrack tracks = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tracks_size()); i < n; i++) {
    const auto& repfield = this->_internal_tracks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated uint32 version = 2 [packed = true];
  {
    int byte_size = _impl_._version_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, _internal_version(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.MovieFingerprint)
  return target;
}

size_t MovieFingerprint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.MovieFingerprint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSD.MovieFingerprintTrack tracks = 1;
  total_size += 1UL * this->_internal_tracks_size();
  for (const auto& msg : this->_impl_.tracks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 version = 2 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.version_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._version_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MovieFingerprint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MovieFingerprint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MovieFingerprint::GetClassData() const { return &_class_data_; }


void MovieFingerprint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MovieFingerprint*>(&to_msg);
  auto& from = static_cast<const MovieFingerprint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.MovieFingerprint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tracks_.MergeFrom(from._impl_.tracks_);
  _this->_impl_.version_.MergeFrom(from._impl_.version_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MovieFingerprint::CopyFrom(const MovieFingerprint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.MovieFingerprint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MovieFingerprint::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.tracks_))
    return false;
  return true;
}

void MovieFingerprint::InternalSwap(MovieFingerprint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tracks_.InternalSwap(&other->_impl_.tracks_);
  _impl_.version_.InternalSwap(&other->_impl_.version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MovieFingerprint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[78]);
}

// ===================================================================

class MovieFingerprintTrack::_Internal {
 public:
  using HasBits = decltype(std::declval<MovieFingerprintTrack>()._impl_._has_bits_);
  static void set_has_media_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_total_sample_data_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_sample_data_digest_string(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_time_range_start_value(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_time_range_start_timescale(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_time_range_start_is_valid(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_time_range_duration_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_time_range_duration_timescale(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_time_range_duration_is_valid(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::TSP::Size& natural_size(const MovieFingerprintTrack* msg);
  static void set_has_natural_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_preferred_transform_a(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_preferred_transform_b(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_preferred_transform_c(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_preferred_transform_d(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_preferred_transform_tx(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_preferred_transform_ty(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_preferred_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_language_code(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_extended_language_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::TSP::Size&
MovieFingerprintTrack::_Internal::natural_size(const MovieFingerprintTrack* msg) {
  return *msg->_impl_.natural_size_;
}
void MovieFingerprintTrack::clear_natural_size() {
  if (_impl_.natural_size_ != nullptr) _impl_.natural_size_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
MovieFingerprintTrack::MovieFingerprintTrack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.MovieFingerprintTrack)
}
MovieFingerprintTrack::MovieFingerprintTrack(const MovieFingerprintTrack& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MovieFingerprintTrack* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.media_type_){}
    , decltype(_impl_.sample_data_digest_string_){}
    , decltype(_impl_.language_code_){}
    , decltype(_impl_.extended_language_tag_){}
    , decltype(_impl_.natural_size_){nullptr}
    , decltype(_impl_.total_sample_data_length_){}
    , decltype(_impl_.time_range_start_value_){}
    , decltype(_impl_.time_range_start_timescale_){}
    , decltype(_impl_.enabled_){}
    , decltype(_impl_.time_range_start_is_valid_){}
    , decltype(_impl_.time_range_duration_is_valid_){}
    , decltype(_impl_.time_range_duration_value_){}
    , decltype(_impl_.preferred_transform_a_){}
    , decltype(_impl_.preferred_transform_b_){}
    , decltype(_impl_.preferred_transform_c_){}
    , decltype(_impl_.preferred_transform_d_){}
    , decltype(_impl_.preferred_transform_tx_){}
    , decltype(_impl_.preferred_transform_ty_){}
    , decltype(_impl_.preferred_volume_){}
    , decltype(_impl_.time_range_duration_timescale_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.media_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.media_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_media_type()) {
    _this->_impl_.media_type_.Set(from._internal_media_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sample_data_digest_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sample_data_digest_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sample_data_digest_string()) {
    _this->_impl_.sample_data_digest_string_.Set(from._internal_sample_data_digest_string(), 
      _this->GetArenaForAllocation());
  }
  _impl_.language_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language_code()) {
    _this->_impl_.language_code_.Set(from._internal_language_code(), 
      _this->GetArenaForAllocation());
  }
  _impl_.extended_language_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extended_language_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_extended_language_tag()) {
    _this->_impl_.extended_language_tag_.Set(from._internal_extended_language_tag(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_natural_size()) {
    _this->_impl_.natural_size_ = new ::TSP::Size(*from._impl_.natural_size_);
  }
  ::memcpy(&_impl_.total_sample_data_length_, &from._impl_.total_sample_data_length_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.time_range_duration_timescale_) -
    reinterpret_cast<char*>(&_impl_.total_sample_data_length_)) + sizeof(_impl_.time_range_duration_timescale_));
  // @@protoc_insertion_point(copy_constructor:TSD.MovieFingerprintTrack)
}

inline void MovieFingerprintTrack::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.media_type_){}
    , decltype(_impl_.sample_data_digest_string_){}
    , decltype(_impl_.language_code_){}
    , decltype(_impl_.extended_language_tag_){}
    , decltype(_impl_.natural_size_){nullptr}
    , decltype(_impl_.total_sample_data_length_){int64_t{0}}
    , decltype(_impl_.time_range_start_value_){int64_t{0}}
    , decltype(_impl_.time_range_start_timescale_){0}
    , decltype(_impl_.enabled_){false}
    , decltype(_impl_.time_range_start_is_valid_){false}
    , decltype(_impl_.time_range_duration_is_valid_){false}
    , decltype(_impl_.time_range_duration_value_){int64_t{0}}
    , decltype(_impl_.preferred_transform_a_){0}
    , decltype(_impl_.preferred_transform_b_){0}
    , decltype(_impl_.preferred_transform_c_){0}
    , decltype(_impl_.preferred_transform_d_){0}
    , decltype(_impl_.preferred_transform_tx_){0}
    , decltype(_impl_.preferred_transform_ty_){0}
    , decltype(_impl_.preferred_volume_){0}
    , decltype(_impl_.time_range_duration_timescale_){0}
  };
  _impl_.media_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.media_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sample_data_digest_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sample_data_digest_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.extended_language_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extended_language_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MovieFingerprintTrack::~MovieFingerprintTrack() {
  // @@protoc_insertion_point(destructor:TSD.MovieFingerprintTrack)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MovieFingerprintTrack::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.media_type_.Destroy();
  _impl_.sample_data_digest_string_.Destroy();
  _impl_.language_code_.Destroy();
  _impl_.extended_language_tag_.Destroy();
  if (this != internal_default_instance()) delete _impl_.natural_size_;
}

void MovieFingerprintTrack::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MovieFingerprintTrack::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.MovieFingerprintTrack)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.media_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.sample_data_digest_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.language_code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.extended_language_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.natural_size_ != nullptr);
      _impl_.natural_size_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.total_sample_data_length_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.time_range_start_timescale_) -
        reinterpret_cast<char*>(&_impl_.total_sample_data_length_)) + sizeof(_impl_.time_range_start_timescale_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.preferred_transform_d_) -
        reinterpret_cast<char*>(&_impl_.enabled_)) + sizeof(_impl_.preferred_transform_d_));
  }
  if (cached_has_bits & 0x000f0000u) {
    ::memset(&_impl_.preferred_transform_tx_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.time_range_duration_timescale_) -
        reinterpret_cast<char*>(&_impl_.preferred_transform_tx_)) + sizeof(_impl_.time_range_duration_timescale_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MovieFingerprintTrack::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string media_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_media_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.MovieFingerprintTrack.media_type");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool enabled = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 total_sample_data_length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_total_sample_data_length(&has_bits);
          _impl_.total_sample_data_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string sample_data_digest_string = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_sample_data_digest_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.MovieFingerprintTrack.sample_data_digest_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int64 time_range_start_value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_time_range_start_value(&has_bits);
          _impl_.time_range_start_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 time_range_start_timescale = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_time_range_start_timescale(&has_bits);
          _impl_.time_range_start_timescale_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool time_range_start_is_valid = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_time_range_start_is_valid(&has_bits);
          _impl_.time_range_start_is_valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 time_range_duration_value = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_time_range_duration_value(&has_bits);
          _impl_.time_range_duration_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 time_range_duration_timescale = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_time_range_duration_timescale(&has_bits);
          _impl_.time_range_duration_timescale_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool time_range_duration_is_valid = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_time_range_duration_is_valid(&has_bits);
          _impl_.time_range_duration_is_valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size natural_size = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_natural_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double preferred_transform_a = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _Internal::set_has_preferred_transform_a(&has_bits);
          _impl_.preferred_transform_a_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double preferred_transform_b = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _Internal::set_has_preferred_transform_b(&has_bits);
          _impl_.preferred_transform_b_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double preferred_transform_c = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          _Internal::set_has_preferred_transform_c(&has_bits);
          _impl_.preferred_transform_c_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double preferred_transform_d = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 121)) {
          _Internal::set_has_preferred_transform_d(&has_bits);
          _impl_.preferred_transform_d_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double preferred_transform_tx = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          _Internal::set_has_preferred_transform_tx(&has_bits);
          _impl_.preferred_transform_tx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double preferred_transform_ty = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          _Internal::set_has_preferred_transform_ty(&has_bits);
          _impl_.preferred_transform_ty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double preferred_volume = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 145)) {
          _Internal::set_has_preferred_volume(&has_bits);
          _impl_.preferred_volume_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string language_code = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_language_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.MovieFingerprintTrack.language_code");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string extended_language_tag = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_extended_language_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.MovieFingerprintTrack.extended_language_tag");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MovieFingerprintTrack::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.MovieFingerprintTrack)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string media_type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_media_type().data(), static_cast<int>(this->_internal_media_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.MovieFingerprintTrack.media_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_media_type(), target);
  }

  // optional bool enabled = 2;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_enabled(), target);
  }

  // optional int64 total_sample_data_length = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_total_sample_data_length(), target);
  }

  // optional string sample_data_digest_string = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sample_data_digest_string().data(), static_cast<int>(this->_internal_sample_data_digest_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.MovieFingerprintTrack.sample_data_digest_string");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_sample_data_digest_string(), target);
  }

  // optional int64 time_range_start_value = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_time_range_start_value(), target);
  }

  // optional int32 time_range_start_timescale = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_time_range_start_timescale(), target);
  }

  // optional bool time_range_start_is_valid = 7;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_time_range_start_is_valid(), target);
  }

  // optional int64 time_range_duration_value = 8;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_time_range_duration_value(), target);
  }

  // optional int32 time_range_duration_timescale = 9;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_time_range_duration_timescale(), target);
  }

  // optional bool time_range_duration_is_valid = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_time_range_duration_is_valid(), target);
  }

  // optional .TSP.Size natural_size = 11;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::natural_size(this),
        _Internal::natural_size(this).GetCachedSize(), target, stream);
  }

  // optional double preferred_transform_a = 12;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(12, this->_internal_preferred_transform_a(), target);
  }

  // optional double preferred_transform_b = 13;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(13, this->_internal_preferred_transform_b(), target);
  }

  // optional double preferred_transform_c = 14;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(14, this->_internal_preferred_transform_c(), target);
  }

  // optional double preferred_transform_d = 15;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(15, this->_internal_preferred_transform_d(), target);
  }

  // optional double preferred_transform_tx = 16;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(16, this->_internal_preferred_transform_tx(), target);
  }

  // optional double preferred_transform_ty = 17;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(17, this->_internal_preferred_transform_ty(), target);
  }

  // optional double preferred_volume = 18;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(18, this->_internal_preferred_volume(), target);
  }

  // optional string language_code = 19;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_language_code().data(), static_cast<int>(this->_internal_language_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.MovieFingerprintTrack.language_code");
    target = stream->WriteStringMaybeAliased(
        19, this->_internal_language_code(), target);
  }

  // optional string extended_language_tag = 20;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_extended_language_tag().data(), static_cast<int>(this->_internal_extended_language_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.MovieFingerprintTrack.extended_language_tag");
    target = stream->WriteStringMaybeAliased(
        20, this->_internal_extended_language_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.MovieFingerprintTrack)
  return target;
}

size_t MovieFingerprintTrack::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.MovieFingerprintTrack)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string media_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_media_type());
    }

    // optional string sample_data_digest_string = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sample_data_digest_string());
    }

    // optional string language_code = 19;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language_code());
    }

    // optional string extended_language_tag = 20;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_extended_language_tag());
    }

    // optional .TSP.Size natural_size = 11;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.natural_size_);
    }

    // optional int64 total_sample_data_length = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_total_sample_data_length());
    }

    // optional int64 time_range_start_value = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_time_range_start_value());
    }

    // optional int32 time_range_start_timescale = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_time_range_start_timescale());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool enabled = 2;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool time_range_start_is_valid = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool time_range_duration_is_valid = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional int64 time_range_duration_value = 8;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_time_range_duration_value());
    }

    // optional double preferred_transform_a = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 8;
    }

    // optional double preferred_transform_b = 13;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 8;
    }

    // optional double preferred_transform_c = 14;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 8;
    }

    // optional double preferred_transform_d = 15;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x000f0000u) {
    // optional double preferred_transform_tx = 16;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 8;
    }

    // optional double preferred_transform_ty = 17;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 8;
    }

    // optional double preferred_volume = 18;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 8;
    }

    // optional int32 time_range_duration_timescale = 9;
    if (cached_has_bits & 0x00080000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_time_range_duration_timescale());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MovieFingerprintTrack::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MovieFingerprintTrack::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MovieFingerprintTrack::GetClassData() const { return &_class_data_; }


void MovieFingerprintTrack::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MovieFingerprintTrack*>(&to_msg);
  auto& from = static_cast<const MovieFingerprintTrack&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.MovieFingerprintTrack)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_media_type(from._internal_media_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_sample_data_digest_string(from._internal_sample_data_digest_string());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_language_code(from._internal_language_code());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_extended_language_tag(from._internal_extended_language_tag());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_natural_size()->::TSP::Size::MergeFrom(
          from._internal_natural_size());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.total_sample_data_length_ = from._impl_.total_sample_data_length_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.time_range_start_value_ = from._impl_.time_range_start_value_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.time_range_start_timescale_ = from._impl_.time_range_start_timescale_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.enabled_ = from._impl_.enabled_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.time_range_start_is_valid_ = from._impl_.time_range_start_is_valid_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.time_range_duration_is_valid_ = from._impl_.time_range_duration_is_valid_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.time_range_duration_value_ = from._impl_.time_range_duration_value_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.preferred_transform_a_ = from._impl_.preferred_transform_a_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.preferred_transform_b_ = from._impl_.preferred_transform_b_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.preferred_transform_c_ = from._impl_.preferred_transform_c_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.preferred_transform_d_ = from._impl_.preferred_transform_d_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x000f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.preferred_transform_tx_ = from._impl_.preferred_transform_tx_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.preferred_transform_ty_ = from._impl_.preferred_transform_ty_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.preferred_volume_ = from._impl_.preferred_volume_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.time_range_duration_timescale_ = from._impl_.time_range_duration_timescale_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MovieFingerprintTrack::CopyFrom(const MovieFingerprintTrack& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.MovieFingerprintTrack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MovieFingerprintTrack::IsInitialized() const {
  if (_internal_has_natural_size()) {
    if (!_impl_.natural_size_->IsInitialized()) return false;
  }
  return true;
}

void MovieFingerprintTrack::InternalSwap(MovieFingerprintTrack* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.media_type_, lhs_arena,
      &other->_impl_.media_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sample_data_digest_string_, lhs_arena,
      &other->_impl_.sample_data_digest_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_code_, lhs_arena,
      &other->_impl_.language_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.extended_language_tag_, lhs_arena,
      &other->_impl_.extended_language_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MovieFingerprintTrack, _impl_.time_range_duration_timescale_)
      + sizeof(MovieFingerprintTrack::_impl_.time_range_duration_timescale_)
      - PROTOBUF_FIELD_OFFSET(MovieFingerprintTrack, _impl_.natural_size_)>(
          reinterpret_cast<char*>(&_impl_.natural_size_),
          reinterpret_cast<char*>(&other->_impl_.natural_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MovieFingerprintTrack::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[79]);
}
#if !defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912)
const int ThemePresetsArchive::kExtensionFieldNumber;
#endif
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::TSS::ThemeArchive,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::TSD::ThemePresetsArchive >, 11, false>
  ThemePresetsArchive::extension(kExtensionFieldNumber, ::TSD::ThemePresetsArchive::default_instance(), nullptr);
#if !defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912)
const int FreehandDrawingArchive::kFreehandDrawingArchiveFieldNumber;
#endif
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::TSD::GroupArchive,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::TSD::FreehandDrawingArchive >, 11, false>
  FreehandDrawingArchive::freehand_drawing_archive(kFreehandDrawingArchiveFieldNumber, ::TSD::FreehandDrawingArchive::default_instance(), nullptr);
#if !defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912)
const int ImageDataAttributes::kImageDataAttributesFieldNumber;
#endif
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::TSP::DataAttributes,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::TSD::ImageDataAttributes >, 11, false>
  ImageDataAttributes::image_data_attributes(kImageDataAttributesFieldNumber, ::TSD::ImageDataAttributes::default_instance(), nullptr);
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::TSS::CommandPropertyEntryArchive,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::TSD::FillArchive >, 11, false>
  fill(kFillFieldNumber, ::TSD::FillArchive::default_instance(), nullptr);
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::TSS::CommandPropertyEntryArchive,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::TSD::StrokeArchive >, 11, false>
  stroke(kStrokeFieldNumber, ::TSD::StrokeArchive::default_instance(), nullptr);

// @@protoc_insertion_point(namespace_scope)
}  // namespace TSD
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::TSD::EdgeInsetsArchive*
Arena::CreateMaybeMessage< ::TSD::EdgeInsetsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::EdgeInsetsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::GeometryArchive*
Arena::CreateMaybeMessage< ::TSD::GeometryArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::GeometryArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::PointPathSourceArchive*
Arena::CreateMaybeMessage< ::TSD::PointPathSourceArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::PointPathSourceArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ScalarPathSourceArchive*
Arena::CreateMaybeMessage< ::TSD::ScalarPathSourceArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ScalarPathSourceArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::BezierPathSourceArchive*
Arena::CreateMaybeMessage< ::TSD::BezierPathSourceArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::BezierPathSourceArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::CalloutPathSourceArchive*
Arena::CreateMaybeMessage< ::TSD::CalloutPathSourceArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::CalloutPathSourceArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ConnectionLinePathSourceArchive*
Arena::CreateMaybeMessage< ::TSD::ConnectionLinePathSourceArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ConnectionLinePathSourceArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::EditableBezierPathSourceArchive_Node*
Arena::CreateMaybeMessage< ::TSD::EditableBezierPathSourceArchive_Node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::EditableBezierPathSourceArchive_Node >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::EditableBezierPathSourceArchive_Subpath*
Arena::CreateMaybeMessage< ::TSD::EditableBezierPathSourceArchive_Subpath >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::EditableBezierPathSourceArchive_Subpath >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::EditableBezierPathSourceArchive*
Arena::CreateMaybeMessage< ::TSD::EditableBezierPathSourceArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::EditableBezierPathSourceArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::PathSourceArchive*
Arena::CreateMaybeMessage< ::TSD::PathSourceArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::PathSourceArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::AngleGradientArchive*
Arena::CreateMaybeMessage< ::TSD::AngleGradientArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::AngleGradientArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::TransformGradientArchive*
Arena::CreateMaybeMessage< ::TSD::TransformGradientArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::TransformGradientArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::GradientArchive_GradientStop*
Arena::CreateMaybeMessage< ::TSD::GradientArchive_GradientStop >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::GradientArchive_GradientStop >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::GradientArchive*
Arena::CreateMaybeMessage< ::TSD::GradientArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::GradientArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ImageFillArchive*
Arena::CreateMaybeMessage< ::TSD::ImageFillArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ImageFillArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::FillArchive*
Arena::CreateMaybeMessage< ::TSD::FillArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::FillArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::StrokePatternArchive*
Arena::CreateMaybeMessage< ::TSD::StrokePatternArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::StrokePatternArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::StrokeArchive*
Arena::CreateMaybeMessage< ::TSD::StrokeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::StrokeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::SmartStrokeArchive*
Arena::CreateMaybeMessage< ::TSD::SmartStrokeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::SmartStrokeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::FrameArchive*
Arena::CreateMaybeMessage< ::TSD::FrameArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::FrameArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::PatternedStrokeArchive*
Arena::CreateMaybeMessage< ::TSD::PatternedStrokeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::PatternedStrokeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::LineEndArchive*
Arena::CreateMaybeMessage< ::TSD::LineEndArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::LineEndArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ShadowArchive*
Arena::CreateMaybeMessage< ::TSD::ShadowArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ShadowArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::DropShadowArchive*
Arena::CreateMaybeMessage< ::TSD::DropShadowArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::DropShadowArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ContactShadowArchive*
Arena::CreateMaybeMessage< ::TSD::ContactShadowArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ContactShadowArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::CurvedShadowArchive*
Arena::CreateMaybeMessage< ::TSD::CurvedShadowArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::CurvedShadowArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ReflectionArchive*
Arena::CreateMaybeMessage< ::TSD::ReflectionArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ReflectionArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ImageAdjustmentsArchive*
Arena::CreateMaybeMessage< ::TSD::ImageAdjustmentsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ImageAdjustmentsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ShapeStylePropertiesArchive*
Arena::CreateMaybeMessage< ::TSD::ShapeStylePropertiesArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ShapeStylePropertiesArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ShapeStyleArchive*
Arena::CreateMaybeMessage< ::TSD::ShapeStyleArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ShapeStyleArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::MediaStylePropertiesArchive*
Arena::CreateMaybeMessage< ::TSD::MediaStylePropertiesArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::MediaStylePropertiesArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::MediaStyleArchive*
Arena::CreateMaybeMessage< ::TSD::MediaStyleArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::MediaStyleArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ThemePresetsArchive*
Arena::CreateMaybeMessage< ::TSD::ThemePresetsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ThemePresetsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ThemeReplaceFillPresetCommandArchive*
Arena::CreateMaybeMessage< ::TSD::ThemeReplaceFillPresetCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ThemeReplaceFillPresetCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::DrawableArchive*
Arena::CreateMaybeMessage< ::TSD::DrawableArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::DrawableArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ContainerArchive*
Arena::CreateMaybeMessage< ::TSD::ContainerArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ContainerArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::GroupArchive*
Arena::CreateMaybeMessage< ::TSD::GroupArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::GroupArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::FreehandDrawingAnimationArchive*
Arena::CreateMaybeMessage< ::TSD::FreehandDrawingAnimationArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::FreehandDrawingAnimationArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::FreehandDrawingArchive*
Arena::CreateMaybeMessage< ::TSD::FreehandDrawingArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::FreehandDrawingArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ShapeArchive*
Arena::CreateMaybeMessage< ::TSD::ShapeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ShapeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ConnectionLineArchive*
Arena::CreateMaybeMessage< ::TSD::ConnectionLineArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ConnectionLineArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ImageArchive*
Arena::CreateMaybeMessage< ::TSD::ImageArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ImageArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::MaskArchive*
Arena::CreateMaybeMessage< ::TSD::MaskArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::MaskArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ImageDataAttributes*
Arena::CreateMaybeMessage< ::TSD::ImageDataAttributes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ImageDataAttributes >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::MovieArchive*
Arena::CreateMaybeMessage< ::TSD::MovieArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::MovieArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ExteriorTextWrapArchive*
Arena::CreateMaybeMessage< ::TSD::ExteriorTextWrapArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ExteriorTextWrapArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::DrawableContentDescription*
Arena::CreateMaybeMessage< ::TSD::DrawableContentDescription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::DrawableContentDescription >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::FreehandDrawingContentDescription*
Arena::CreateMaybeMessage< ::TSD::FreehandDrawingContentDescription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::FreehandDrawingContentDescription >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::FreehandDrawingToolkitUIState*
Arena::CreateMaybeMessage< ::TSD::FreehandDrawingToolkitUIState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::FreehandDrawingToolkitUIState >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::StandinCaptionArchive*
Arena::CreateMaybeMessage< ::TSD::StandinCaptionArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::StandinCaptionArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::GuideArchive*
Arena::CreateMaybeMessage< ::TSD::GuideArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::GuideArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::UserDefinedGuideArchive*
Arena::CreateMaybeMessage< ::TSD::UserDefinedGuideArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::UserDefinedGuideArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::GuideStorageArchive*
Arena::CreateMaybeMessage< ::TSD::GuideStorageArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::GuideStorageArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::CanvasSelectionArchive*
Arena::CreateMaybeMessage< ::TSD::CanvasSelectionArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::CanvasSelectionArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::DrawableSelectionArchive*
Arena::CreateMaybeMessage< ::TSD::DrawableSelectionArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::DrawableSelectionArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::GroupSelectionArchive*
Arena::CreateMaybeMessage< ::TSD::GroupSelectionArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::GroupSelectionArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::PathSelectionArchive*
Arena::CreateMaybeMessage< ::TSD::PathSelectionArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::PathSelectionArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::InfoHyperlinkSelectionArchive*
Arena::CreateMaybeMessage< ::TSD::InfoHyperlinkSelectionArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::InfoHyperlinkSelectionArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::CommentStorageArchive*
Arena::CreateMaybeMessage< ::TSD::CommentStorageArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::CommentStorageArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ReplaceAnnotationAuthorCommandArchive*
Arena::CreateMaybeMessage< ::TSD::ReplaceAnnotationAuthorCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ReplaceAnnotationAuthorCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::PencilAnnotationArchive*
Arena::CreateMaybeMessage< ::TSD::PencilAnnotationArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::PencilAnnotationArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::PencilAnnotationSelectionArchive*
Arena::CreateMaybeMessage< ::TSD::PencilAnnotationSelectionArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::PencilAnnotationSelectionArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::PencilAnnotationStorageArchive*
Arena::CreateMaybeMessage< ::TSD::PencilAnnotationStorageArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::PencilAnnotationStorageArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::SpecColorFillSetColorArchive*
Arena::CreateMaybeMessage< ::TSD::SpecColorFillSetColorArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::SpecColorFillSetColorArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::SpecFrameSetAssetScaleArchive*
Arena::CreateMaybeMessage< ::TSD::SpecFrameSetAssetScaleArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::SpecFrameSetAssetScaleArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::SpecGradientFillSetAngleArchive*
Arena::CreateMaybeMessage< ::TSD::SpecGradientFillSetAngleArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::SpecGradientFillSetAngleArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::SpecImageFillSetTechniqueArchive*
Arena::CreateMaybeMessage< ::TSD::SpecImageFillSetTechniqueArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::SpecImageFillSetTechniqueArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::SpecReflectionSetOpacityArchive*
Arena::CreateMaybeMessage< ::TSD::SpecReflectionSetOpacityArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::SpecReflectionSetOpacityArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::SpecShadowSetAngleArchive*
Arena::CreateMaybeMessage< ::TSD::SpecShadowSetAngleArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::SpecShadowSetAngleArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::SpecShadowSetColorArchive*
Arena::CreateMaybeMessage< ::TSD::SpecShadowSetColorArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::SpecShadowSetColorArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::SpecShadowSetOffsetArchive*
Arena::CreateMaybeMessage< ::TSD::SpecShadowSetOffsetArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::SpecShadowSetOffsetArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::SpecShadowSetOpacityArchive*
Arena::CreateMaybeMessage< ::TSD::SpecShadowSetOpacityArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::SpecShadowSetOpacityArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::SpecShadowSetRadiusArchive*
Arena::CreateMaybeMessage< ::TSD::SpecShadowSetRadiusArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::SpecShadowSetRadiusArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::SpecStrokeSetColorArchive*
Arena::CreateMaybeMessage< ::TSD::SpecStrokeSetColorArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::SpecStrokeSetColorArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::SpecStrokeSetPatternArchive*
Arena::CreateMaybeMessage< ::TSD::SpecStrokeSetPatternArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::SpecStrokeSetPatternArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::SpecStrokeSetWidthArchive*
Arena::CreateMaybeMessage< ::TSD::SpecStrokeSetWidthArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::SpecStrokeSetWidthArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::Attribution*
Arena::CreateMaybeMessage< ::TSD::Attribution >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::Attribution >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::MovieFingerprint*
Arena::CreateMaybeMessage< ::TSD::MovieFingerprint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::MovieFingerprint >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::MovieFingerprintTrack*
Arena::CreateMaybeMessage< ::TSD::MovieFingerprintTrack >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::MovieFingerprintTrack >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
